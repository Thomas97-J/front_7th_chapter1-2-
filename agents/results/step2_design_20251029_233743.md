명세를 분석하여 체계적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-12-31'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후일 수 없습니다' }` 반환

### Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 된 시작일과 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 처리되고 `{ isValid: true }` 반환

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 형식 문자열 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 파싱되고 `{ isValid: true }` 반환

#### 테스트 케이스 6
- **이름**: should accept mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 ISO 8601 문자열
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 처리되고 `{ isValid: true }` 반환

### Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 8
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }` 반환

#### 테스트 케이스 9
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 10
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }` 반환

#### 테스트 케이스 11
- **이름**: should return error when start date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 'invalid-date'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 시작일 형식입니다' }` 반환

#### 테스트 케이스 12
- **이름**: should return error when end date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 'not-a-date'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 종료일 형식입니다' }` 반환

#### 테스트 케이스 13
- **이름**: should return error when date string is malformed
- **타입**: unit
- **우선순위**: medium
- **Given**: 날짜 문자열 '2024-13-45' (존재하지 않는 월/일)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: ... }` 반환

### Edge Cases - 경계값 테스트

#### 테스트 케이스 14
- **이름**: should return valid when dates differ by exactly 1 day
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-01-02'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates differ by more than 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '1900-01-01'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 16
- **이름**: should handle dates at midnight correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-01-01T00:00:00Z'과 종료일 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 17
- **이름**: should handle dates at end of day correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-01-01T23:59:59Z'과 종료일 '2024-01-02T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 18
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-02-29'과 종료일 '2024-03-01' (2024는 윤년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 19
- **이름**: should handle year boundary correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2023-12-31'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 20
- **이름**: should handle very old dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '1900-01-01'과 종료일 '1900-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 21
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2100-01-01'과 종료일 '2100-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

### Edge Cases - 타임존 처리

#### 테스트 케이스 22
- **이름**: should handle different timezone formats
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-01-01T00:00:00+09:00'과 종료일 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 타임존을 고려하여 올바르게 비교

#### 테스트 케이스 23
- **이름**: should normalize dates to UTC for comparison
- **타입**: edge
- **우선순위**: low
- **Given**: 서로 다른 타임존의 날짜들
- **When**: validateDateRange 함수를 호출할 때
- **Then**: UTC 기준으로 정확히 비교

---

## 테스트 구현 가이드

### 테스트 파일 구조
```
src/__tests__/utils/validateDateRange.test.ts
```

### 주요 테스트 패턴

**AAA 패턴 예시:**
```typescript
test('should return valid when start date is before end date', () => {
  // Arrange
  const startDate = '2024-01-01';
  const endDate = '2024-12-31';
  
  // Act
  const result = validateDateRange(startDate, endDate);
  
  // Assert
  expect(result).toEqual({ isValid: true });
});
```

### 테스트 실행 우선순위
1. **High Priority** (13개): 핵심 기능과 에러 처리
2. **Medium Priority** (5개): 입력 형식 변환과 주요 엣지 케이스
3. **Low Priority** (5개): 상세한 경계값과 타임존 처리

이 설계는 총 23개의 테스트 케이스로 구성되어 있으며, 명세의 모든 요구사항을 커버합니다.
