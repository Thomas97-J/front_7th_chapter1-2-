```typescript
// filepath: src/__tests__/unit/scheduleRecurringRule.spec.ts

import { describe, it, expect } from 'vitest';
import { generateRecurringDates } from '../../utils/scheduleRecurringRule';

describe('Schedule Recurring Rule', () => {
  describe('Daily Repeat', () => {
    it('should generate next day when repeat type is daily', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const occurrences = 1;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-01']);
    });

    it('should generate consecutive daily dates when multiple occurrences requested', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const occurrences = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
    });

    it('should handle daily repeat across month boundary', () => {
      // Arrange
      const startDate = '2024-02-28';
      const repeatType = 'daily';
      const occurrences = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-01', '2024-03-02']);
    });
  });

  describe('Weekly Repeat', () => {
    it('should generate same weekday when repeat type is weekly', () => {
      // Arrange
      const startDate = '2024-01-31'; // Wednesday
      const repeatType = 'weekly';
      const occurrences = 1;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-07']); // Wednesday
      expect(new Date(result[0]).getDay()).toBe(new Date(startDate).getDay());
    });

    it('should generate consecutive weekly dates on same weekday', () => {
      // Arrange
      const startDate = '2024-01-31'; // Wednesday
      const repeatType = 'weekly';
      const occurrences = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-07', '2024-02-14', '2024-02-21']);
      result.forEach(date => {
        expect(new Date(date).getDay()).toBe(new Date(startDate).getDay());
      });
    });

    it('should preserve weekday across month and year boundaries', () => {
      // Arrange
      const startDate = '2024-12-30'; // Monday
      const repeatType = 'weekly';
      const occurrences = 2;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2025-01-06', '2025-01-13']);
      result.forEach(date => {
        expect(new Date(date).getDay()).toBe(new Date(startDate).getDay());
      });
    });
  });

  describe('Monthly Repeat', () => {
    it('should skip months without the original day when repeat type is monthly', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const occurrences = 2;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-03-31', '2024-05-31']);
    });

    it('should handle February when original day is 31st', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const occurrences = 5;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).not.toContain('2024-02-31');
      expect(result.filter(date => date.startsWith('2024-02'))).toHaveLength(0);
    });

    it('should generate monthly dates for day existing in all months', () => {
      // Arrange
      const startDate = '2024-01-15';
      const repeatType = 'monthly';
      const occurrences = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-15', '2024-03-15', '2024-04-15']);
    });

    it('should handle monthly repeat for 29th across leap and non-leap years', () => {
      // Arrange
      const startDate = '2024-01-29';
      const repeatType = 'monthly';
      const occurrences = 2;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-29']);
    });

    it('should skip February in non-leap year when original day is 30th or 31st', () => {
      // Arrange
      const startDate = '2023-01-30'; // Non-leap year
      const repeatType = 'monthly';
      const occurrences = 2;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2023-03-30', '2023-04-30']);
      expect(result.filter(date => date.startsWith('2023-02'))).toHaveLength(0);
    });
  });

  describe('Yearly Repeat', () => {
    it('should generate next year on same date when repeat type is yearly', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'yearly';
      const occurrences = 1;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2025-01-31']);
    });

    it('should only generate on leap year February 29th when original date is Feb 29', () => {
      // Arrange
      const startDate = '2024-02-29'; // Leap year
      const repeatType = 'yearly';
      const occurrences = 2;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29']);
    });

    it('should skip non-leap years when original date is February 29th', () => {
      // Arrange
      const startDate = '2024-02-29';
      const repeatType = 'yearly';
      const occurrences = 1;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result[0]).toBe('2028-02-29');
      expect(result[0]).not.toBe('2025-02-29');
      expect(result[0]).not.toBe('2026-02-29');
      expect(result[0]).not.toBe('2027-02-29');
    });

    it('should generate yearly dates for regular dates', () => {
      // Arrange
      const startDate = '2024-06-15';
      const repeatType = 'yearly';
      const occurrences = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2025-06-15', '2026-06-15', '2027-06-15']);
    });
  });

  describe('Duplicate Events Allowed', () => {
    it('should not check for existing events when generating recurring dates', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const occurrences = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
      expect(result).toHaveLength(3);
    });

    it('should allow duplicate dates in result when multiple events exist', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const occurrences = 2;

      // Act
      const result1 = generateRecurringDates(startDate, repeatType, occurrences);
      const result2 = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result1).toEqual(result2);
      expect(result1).toEqual(['2024-02-01', '2024-02-02']);
    });
  });

  describe('Input Validation', () => {
    it('should handle zero occurrences', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const occurrences = 0;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual([]);
    });

    it('should handle negative occurrences', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const occurrences = -1;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual([]);
    });

    it('should handle invalid date format gracefully', () => {
      // Arrange
      const startDate = 'invalid-date';
      const repeatType = 'daily';
      const occurrences = 1;

      // Act & Assert
      expect(() => generateRecurringDates(startDate, repeatType, occurrences)).toThrow();
    });

    it('should handle unknown repeat type', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'unknown' as any;
      const occurrences = 1;

      // Act & Assert
      expect(() => generateRecurringDates(startDate, repeatType, occurrences)).toThrow();
    });
  });
});
```
