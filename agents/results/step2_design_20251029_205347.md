명세를 분석하여 포괄적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### 1. 기본 동작 테스트 (Unit Tests)

#### 테스트 케이스 1.1
- **이름**: should return isValid true when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-12-31'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 1.2
- **이름**: should return isValid true when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-06-15'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 1.3
- **이름**: should return isValid false with error when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-12-31'과 종료일 '2024-01-01'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }`를 반환해야 함

### 2. 입력 형식 테스트 (Unit Tests)

#### 테스트 케이스 2.1
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체 형태의 시작일과 종료일
- **When**: validateDateRange(new Date('2024-01-01'), new Date('2024-12-31'))를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 2.2
- **이름**: should accept ISO 8601 string format as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 문자열 형태의 시작일 '2024-01-01T00:00:00Z'과 종료일 '2024-12-31T23:59:59Z'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 2.3
- **이름**: should accept mixed input types (Date object and ISO string)
- **타입**: unit
- **우선순위**: medium
- **Given**: Date 객체 시작일과 ISO 문자열 종료일
- **When**: validateDateRange(new Date('2024-01-01'), '2024-12-31')를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

### 3. 에러 처리 테스트 (Unit Tests)

#### 테스트 케이스 3.1
- **이름**: should return error when startDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 null이고 endDate는 유효한 날짜
- **When**: validateDateRange(null, '2024-12-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 3.2
- **이름**: should return error when startDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 undefined이고 endDate는 유효한 날짜
- **When**: validateDateRange(undefined, '2024-12-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 3.3
- **이름**: should return error when endDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜이고 endDate가 null
- **When**: validateDateRange('2024-01-01', null)를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 3.4
- **이름**: should return error when endDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜이고 endDate가 undefined
- **When**: validateDateRange('2024-01-01', undefined)를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 3.5
- **이름**: should return error when both dates are null
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate와 endDate가 모두 null
- **When**: validateDateRange(null, null)를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 3.6
- **이름**: should return error when startDate has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 잘못된 형식의 시작일 'invalid-date'와 유효한 종료일
- **When**: validateDateRange('invalid-date', '2024-12-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 3.7
- **이름**: should return error when endDate has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 유효한 시작일과 잘못된 형식의 종료일 'not-a-date'
- **When**: validateDateRange('2024-01-01', 'not-a-date')를 호출할 때
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 3.8
- **이름**: should return error when date string is empty
- **타입**: unit
- **우선순위**: medium
- **Given**: 빈 문자열 ''을 시작일로
- **When**: validateDateRange('', '2024-12-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 3.9
- **이름**: should return error when date is Invalid Date object
- **타입**: unit
- **우선순위**: medium
- **Given**: new Date('invalid')와 같은 Invalid Date 객체
- **When**: validateDateRange(new Date('invalid'), '2024-12-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }`를 반환해야 함

### 4. 엣지 케이스 테스트 (Edge Cases)

#### 테스트 케이스 4.1
- **이름**: should return isValid true when dates are exactly same
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일과 종료일이 동일한 '2024-06-15T12:00:00Z'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.2
- **이름**: should return isValid true when dates differ by one day
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일 '2024-06-15'과 종료일 '2024-06-16'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.3
- **이름**: should return isValid true when dates differ by exactly one millisecond
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-06-15T12:00:00.000Z'과 종료일 '2024-06-15T12:00:00.001Z'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.4
- **이름**: should return isValid true with warning when dates differ by more than 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '1900-01-01'과 종료일 '2024-12-31' (100년 이상 차이)
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환해야 함

#### 테스트 케이스 4.5
- **이름**: should return isValid true with warning when dates differ by exactly 100 years
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '1924-01-01'과 종료일 '2024-01-01' (정확히 100년)
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환해야 함

#### 테스트 케이스 4.6
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 윤년의 2월 29일 '2024-02-29'
- **When**: validateDateRange('2024-02-29', '2024-03-01')를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.7
- **이름**: should handle year boundary correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 연말 '2023-12-31'과 새해 '2024-01-01'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.8
- **이름**: should handle very old dates (past century)
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '1900-01-01'과 종료일 '1900-12-31'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.9
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2100-01-01'과 종료일 '2200-12-31'
- **When**: validateDateRange를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환해야 함

#### 테스트 케이스 4.10
- **이름**: should handle timezone differences in ISO strings
- **타입**: edge
- **우선순위**: medium
- **Given**: 다른 타임존의 ISO 문자열 '2024-06-15T23:00:00+09:00'과 '2024-06-15T15:00:00Z'
- **When**: validateDateRange를 호출할 때
- **Then**: 타임존을 고려하여 올바르게 비교해야 함

### 5. 통합 테스트 (Integration Tests)

#### 테스트 케이스 5.1
- **이름**: should work correctly when called multiple times with different inputs
- **타입**: integration
- **우선순위**: medium
- **Given**: 여러 개의 서로 다른 날짜 쌍
- **When**: validateDateRange를 연속으로 여러 번 호출할 때
- **Then**: 각 호출이 독립적으로 정확한 결과를 반환해야 함

#### 테스트 케이스 5.2
- **이름**: should not mutate input Date objects
- **타입**: integration
- **우선순위**: medium
- **Given**: Date 객체 형태의 시작일과 종료일
- **When**: validateDateRange를 호출할 때
- **Then**: 원본 Date 객체가 변경되지 않아야 함

#### 테스트 케이스 5.3
- **이름**: should be consistent between Date objects and ISO string inputs
- **타입**: integration
- **우선순위**: high
- **Given**: 동일한 날짜를 나타내는 Date 객체와 ISO 문자열
- **When**: 각각 validateDateRange를 호출할 때
- **Then**: 두 호출의 결과가 동일해야 함

---

## 테스트 실행 우선순위

### High Priority (15개)
- 기본 동작: 1.1, 1.2, 1.3
- 입력 형식: 2.1, 2.2
- 에러 처리: 3.1, 3.2, 3.3, 3.4, 3.6, 3.7
- 엣지 케이스: 4.1, 4.2
- 통합: 5.3

### Medium Priority (12개)
- 입력 형식: 2.3
- 에러 처리: 3.5, 3.8, 3.9
- 엣지 케이스: 4.3, 4.4, 4.6, 4.7, 4.10
- 통합: 5.1, 5.2

### Low Priority (3개)
- 엣지 케이스: 4.5, 4.8, 4.9

---

## 테스트 구조 권장사항

```typescript
// src/__tests__/unit/validateDateRange.spec.ts

describe('validateDateRange', () => {
  describe('기본 동작', () => {
    // 테스트 케이스 1.1, 1.2, 1.3
  });

  describe('입력 형식 처리', () => {
    // 테스트 케이스 2.1, 2.2, 2.3
  });

  describe('에러 처리', () => {
    describe('null/undefined 입력', () => {
      // 테스트 케이스 3.1-3.5
    });

    describe('잘못된 형식', () => {
      // 테스트 케이스 3.6-3.9
    });
  });

  describe('엣지 케이스', () => {
    describe('날짜 경계', () => {
      // 테스트 케이스 4.1-4.3
    });

    describe('긴 기간 범위', () => {
      // 테스트 케이스 4.4-4.5
    });

    describe('특수 날짜', () => {
      // 테스트 케이스 4.6-4.9
    });

    describe('타임존', () => {
      // 테스트 케이스 4.10
    });
  });

  describe('통합 테스트', () => {
    // 테스트 케이스 5.1-5.3
  });
});
```

이 테스트 설계는 총 **30개의 테스트 케이스**를 포함하며, AAA 패턴과 명확한 Given-When-Then 구조를 따릅니다. 각 테스트는 독립적으로 실행 가능하며, 명세의 모든 요구사항을 검증합니다.
