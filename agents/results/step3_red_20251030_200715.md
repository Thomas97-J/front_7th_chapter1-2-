```typescript
// filepath: src/__tests__/unit/scheduleRecurring.spec.ts

import { describe, it, expect } from 'vitest';

interface RecurringSchedule {
  startDate: string;
  repeatType: 'daily' | 'weekly' | 'monthly' | 'yearly';
}

function generateRecurringDates(
  schedule: RecurringSchedule,
  count: number
): string[] {
  const dates: string[] = [];
  const startDate = new Date(schedule.startDate);
  const startDay = startDate.getDate();
  const startMonth = startDate.getMonth();

  for (let i = 0; i < count; i++) {
    let nextDate = new Date(startDate);

    switch (schedule.repeatType) {
      case 'daily':
        nextDate.setDate(startDate.getDate() + i + 1);
        dates.push(nextDate.toISOString().split('T')[0]);
        break;

      case 'weekly':
        nextDate.setDate(startDate.getDate() + (i + 1) * 7);
        dates.push(nextDate.toISOString().split('T')[0]);
        break;

      case 'monthly':
        let monthsChecked = 0;
        let validDatesFound = 0;
        
        while (validDatesFound <= i) {
          monthsChecked++;
          const testDate = new Date(startDate);
          testDate.setMonth(startDate.getMonth() + monthsChecked);
          testDate.setDate(1);
          
          const lastDayOfMonth = new Date(
            testDate.getFullYear(),
            testDate.getMonth() + 1,
            0
          ).getDate();
          
          if (startDay <= lastDayOfMonth) {
            testDate.setDate(startDay);
            validDatesFound++;
            if (validDatesFound > i) {
              dates.push(testDate.toISOString().split('T')[0]);
            }
          }
        }
        break;

      case 'yearly':
        let yearsChecked = 0;
        let validYearDatesFound = 0;
        
        while (validYearDatesFound <= i) {
          yearsChecked++;
          const testDate = new Date(startDate);
          testDate.setFullYear(startDate.getFullYear() + yearsChecked);
          testDate.setMonth(startMonth);
          testDate.setDate(1);
          
          const lastDayOfMonth = new Date(
            testDate.getFullYear(),
            testDate.getMonth() + 1,
            0
          ).getDate();
          
          if (startDay <= lastDayOfMonth) {
            testDate.setDate(startDay);
            validYearDatesFound++;
            if (validYearDatesFound > i) {
              dates.push(testDate.toISOString().split('T')[0]);
            }
          }
        }
        break;
    }
  }

  return dates;
}

describe('Schedule Recurring Rule', () => {
  describe('매일 반복 (Daily Repeat)', () => {
    it('should generate next day from 2024-01-31', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'daily',
      };

      // Act
      const result = generateRecurringDates(schedule, 1);

      // Assert
      expect(result[0]).toBe('2024-02-01');
    });

    it('should generate 3 consecutive daily dates from 2024-01-31', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'daily',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
    });

    it('should handle daily repeat across month boundaries', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-02-28',
        repeatType: 'daily',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-01', '2024-03-02']);
    });

    it('should handle daily repeat across year boundaries', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-12-30',
        repeatType: 'daily',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2024-12-31', '2025-01-01', '2025-01-02']);
    });
  });

  describe('매주 반복 (Weekly Repeat)', () => {
    it('should generate next week same day from Wednesday 2024-01-31', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'weekly',
      };

      // Act
      const result = generateRecurringDates(schedule, 1);

      // Assert
      expect(result[0]).toBe('2024-02-07');
    });

    it('should generate 3 consecutive weekly dates from 2024-01-31', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'weekly',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2024-02-07', '2024-02-14', '2024-02-21']);
    });

    it('should maintain same weekday across month boundaries', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'weekly',
      };

      // Act
      const result = generateRecurringDates(schedule, 5);

      // Assert
      expect(result).toEqual([
        '2024-02-07',
        '2024-02-14',
        '2024-02-21',
        '2024-02-28',
        '2024-03-06',
      ]);
    });

    it('should handle weekly repeat from Monday', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-29',
        repeatType: 'weekly',
      };

      // Act
      const result = generateRecurringDates(schedule, 2);

      // Assert
      expect(result).toEqual(['2024-02-05', '2024-02-12']);
    });
  });

  describe('매월 반복 (Monthly Repeat)', () => {
    it('should skip February and generate March 31 from January 31', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'monthly',
      };

      // Act
      const result = generateRecurringDates(schedule, 1);

      // Assert
      expect(result[0]).toBe('2024-03-31');
    });

    it('should generate only 31st dates, skipping months without 31 days', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'monthly',
      };

      // Act
      const result = generateRecurringDates(schedule, 2);

      // Assert
      expect(result).toEqual(['2024-03-31', '2024-05-31']);
    });

    it('should handle monthly repeat for day 15 across all months', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-15',
        repeatType: 'monthly',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2024-02-15', '2024-03-15', '2024-04-15']);
    });

    it('should handle monthly repeat for day 30, skipping February', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-30',
        repeatType: 'monthly',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2024-03-30', '2024-04-30', '2024-05-30']);
    });

    it('should generate 31st dates across multiple years', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'monthly',
      };

      // Act
      const result = generateRecurringDates(schedule, 7);

      // Assert
      expect(result).toEqual([
        '2024-03-31',
        '2024-05-31',
        '2024-07-31',
        '2024-08-31',
        '2024-10-31',
        '2024-12-31',
        '2025-01-31',
      ]);
    });
  });

  describe('매년 반복 (Yearly Repeat)', () => {
    it('should generate next leap year Feb 29 from 2024-02-29', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-02-29',
        repeatType: 'yearly',
      };

      // Act
      const result = generateRecurringDates(schedule, 1);

      // Assert
      expect(result[0]).toBe('2028-02-29');
    });

    it('should generate two consecutive leap year Feb 29 dates', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-02-29',
        repeatType: 'yearly',
      };

      // Act
      const result = generateRecurringDates(schedule, 2);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29']);
    });

    it('should handle yearly repeat for regular date', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-03-15',
        repeatType: 'yearly',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2025-03-15', '2026-03-15', '2027-03-15']);
    });

    it('should handle yearly repeat for December 31', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-12-31',
        repeatType: 'yearly',
      };

      // Act
      const result = generateRecurringDates(schedule, 2);

      // Assert
      expect(result).toEqual(['2025-12-31', '2026-12-31']);
    });

    it('should skip non-leap years for Feb 29 start date', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-02-29',
        repeatType: 'yearly',
      };

      // Act
      const result = generateRecurringDates(schedule, 3);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29', '2036-02-29']);
    });
  });

  describe('Edge Cases', () => {
    it('should generate single date when count is 1', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-01-15',
        repeatType: 'daily',
      };

      // Act
      const result = generateRecurringDates(schedule, 1);

      // Assert
      expect(result).toHaveLength(1);
      expect(result[0]).toBe('2024-01-16');
    });

    it('should handle leap year boundary for daily repeat', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-02-28',
        repeatType: 'daily',
      };

      // Act
      const result = generateRecurringDates(schedule, 2);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-01']);
    });

    it('should handle non-leap year February for monthly repeat', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2023-01-31',
        repeatType: 'monthly',
      };

      // Act
      const result = generateRecurringDates(schedule, 2);

      // Assert
      expect(result).toEqual(['2023-03-31', '2023-05-31']);
    });

    it('should allow duplicate dates on same day (no overlap check)', () => {
      // Arrange
      const schedule1: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'daily',
      };
      const schedule2: RecurringSchedule = {
        startDate: '2024-01-31',
        repeatType: 'daily',
      };

      // Act
      const result1 = generateRecurringDates(schedule1, 1);
      const result2 = generateRecurringDates(schedule2, 1);

      // Assert
      expect(result1[0]).toBe('2024-02-01');
      expect(result2[0]).toBe('2024-02-01');
      expect(result1[0]).toBe(result2[0]);
    });

    it('should handle start date at year boundary for weekly repeat', () => {
      // Arrange
      const schedule: RecurringSchedule = {
        startDate: '2024-12-25',
        repeatType: 'weekly',
      };

      // Act
      const result = generateRecurringDates(schedule, 2);

      // Assert
      expect(result).toEqual(['2025-01-01', '2025-01-08']);
    });
  });
});
```
