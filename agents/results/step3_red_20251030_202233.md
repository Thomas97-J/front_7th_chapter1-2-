```typescript
// filepath: src/__tests__/unit/scheduleRecurringRule.spec.ts

import { describe, it, expect, vi } from 'vitest';
import { generateRecurringSchedules } from '../../utils/scheduleRecurringRule';

describe('Schedule Recurring Rule', () => {
  describe('1. 매일 반복 (Daily Recurrence)', () => {
    it('should generate next day when repeat type is daily', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-01']);
    });

    it('should generate consecutive daily schedules correctly', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
    });

    it('should handle month boundary correctly in daily recurrence', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result[0]).toBe('2024-02-01');
      expect(result[0].substring(0, 7)).toBe('2024-02');
    });

    it('should handle year boundary correctly in daily recurrence', () => {
      // Arrange
      const startDate = '2024-12-31';
      const repeatType = 'daily';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2025-01-01']);
    });
  });

  describe('2. 매주 반복 (Weekly Recurrence)', () => {
    it('should generate same weekday when repeat type is weekly', () => {
      // Arrange
      const startDate = '2024-01-31'; // Wednesday
      const repeatType = 'weekly';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-07']);
      const date = new Date(result[0]);
      expect(date.getDay()).toBe(3); // Wednesday
    });

    it('should generate consecutive weekly schedules with same weekday', () => {
      // Arrange
      const startDate = '2024-01-31'; // Wednesday
      const repeatType = 'weekly';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-07', '2024-02-14', '2024-02-21']);
      result.forEach(dateStr => {
        const date = new Date(dateStr);
        expect(date.getDay()).toBe(3); // All Wednesdays
      });
    });

    it('should handle month boundary in weekly recurrence', () => {
      // Arrange
      const startDate = '2024-01-31'; // Wednesday
      const repeatType = 'weekly';
      const count = 2;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-07', '2024-02-14']);
      const date1 = new Date(result[0]);
      const date2 = new Date(result[1]);
      expect(date2.getTime() - date1.getTime()).toBe(7 * 24 * 60 * 60 * 1000);
    });

    it('should handle year boundary in weekly recurrence', () => {
      // Arrange
      const startDate = '2024-12-25'; // Wednesday
      const repeatType = 'weekly';
      const count = 2;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2025-01-01', '2025-01-08']);
      result.forEach(dateStr => {
        const date = new Date(dateStr);
        expect(date.getDay()).toBe(3); // All Wednesdays
      });
    });
  });

  describe('3. 매월 반복 (Monthly Recurrence)', () => {
    it('should generate same date of month when repeat type is monthly', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-31']); // Skip February (no 31st)
    });

    it('should skip months without the target day in monthly recurrence', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-31', '2024-05-31', '2024-07-31']);
      // February, April, June skipped
    });

    it('should handle regular months correctly in monthly recurrence from day 31', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 7;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([
        '2024-03-31',
        '2024-05-31',
        '2024-07-31',
        '2024-08-31',
        '2024-10-31',
        '2024-12-31',
        '2025-01-31'
      ]);
    });

    it('should generate monthly schedules from day 15 without skipping', () => {
      // Arrange
      const startDate = '2024-01-15';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-15', '2024-03-15', '2024-04-15']);
    });

    it('should handle 30th day monthly recurrence correctly', () => {
      // Arrange
      const startDate = '2024-01-30';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-30', '2024-04-30', '2024-05-30']);
      // February skipped (no 30th)
    });

    it('should handle February 29 in leap year for monthly recurrence', () => {
      // Arrange
      const startDate = '2024-01-29';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-29', '2024-04-29']);
    });
  });

  describe('4. 매년 반복 (Yearly Recurrence)', () => {
    it('should generate same date next year when repeat type is yearly', () => {
      // Arrange
      const startDate = '2024-02-29'; // Leap year
      const repeatType = 'yearly';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2028-02-29']); // Skip 2025-2027 (non-leap years)
    });

    it('should skip non-leap years when starting from February 29', () => {
      // Arrange
      const startDate = '2024-02-29';
      const repeatType = 'yearly';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29', '2036-02-29']);
    });

    it('should generate yearly schedules without skipping for regular dates', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'yearly';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2025-01-31', '2026-01-31', '2027-01-31']);
    });

    it('should handle century leap year correctly', () => {
      // Arrange
      const startDate = '2096-02-29'; // Leap year
      const repeatType = 'yearly';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2104-02-29']); // Skip 2100 (not divisible by 400)
    });

    it('should handle year 2000 as leap year correctly', () => {
      // Arrange
      const startDate = '1996-02-29';
      const repeatType = 'yearly';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2000-02-29']); // 2000 is leap year (divisible by 400)
    });
  });

  describe('5. 일정 겹침 처리', () => {
    it('should allow duplicate schedules on same date', () => {
      // Arrange
      const existingSchedules = ['2024-02-01'];
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-01']);
      expect(result[0]).toBe(existingSchedules[0]); // Duplicate allowed
    });

    it('should not check for existing schedules during recurrence generation', () => {
      // Arrange
      const mockCheckSchedule = vi.fn();
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toHaveLength(3);
      expect(mockCheckSchedule).not.toHaveBeenCalled();
    });
  });

  describe('6. 입력 유효성 및 예외 처리', () => {
    it('should throw error when start date is invalid', () => {
      // Arrange
      const startDate = 'invalid-date';
      const repeatType = 'daily';
      const count = 1;

      // Act & Assert
      expect(() => generateRecurringSchedules(startDate, repeatType, count)).toThrow();
    });

    it('should throw error when repeat type is invalid', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'invalid-type';
      const count = 1;

      // Act & Assert
      expect(() => generateRecurringSchedules(startDate, repeatType, count)).toThrow();
    });

    it('should return empty array when count is zero', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 0;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([]);
    });

    it('should return single date when count is one', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-01']);
      expect(result).toHaveLength(1);
    });
  });

  describe('7. 날짜 형식 검증', () => {
    it('should return dates in ISO 8601 format', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      result.forEach(dateStr => {
        expect(dateStr).toMatch(/^\d{4}-\d{2}-\d{2}$/);
      });
    });

    it('should pad single digit months and days with zero', () => {
      // Arrange
      const startDate = '2024-01-09';
      const repeatType = 'daily';
      const count = 1;

      // Act
      const result = generateRecurringSchedules(startDate, repeatType, count);

      // Assert
      expect(result[0]).toBe('2024-01-10');
      expect(result[0]).toMatch(/^\d{4}-\d{2}-\d{2}$/);
    });
  });
});
```
