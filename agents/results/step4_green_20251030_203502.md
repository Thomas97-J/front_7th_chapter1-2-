Perfect! Now I can see the exact function signature and all test cases. Let me write the complete implementation:

```typescript
// filepath: src/utils/scheduleRecurringRule.ts

/**
 * Type definition for repeat types
 */
export type RepeatType = 'daily' | 'weekly' | 'monthly' | 'yearly';

/**
 * Generates recurring schedule dates based on start date, repeat type, and count
 * 
 * @param startDate - Starting date in YYYY-MM-DD format
 * @param repeatType - Type of recurrence: 'daily', 'weekly', 'monthly', or 'yearly'
 * @param count - Number of recurring dates to generate
 * @returns Array of date strings in YYYY-MM-DD format
 * @throws Error if date format is invalid, repeat type is invalid, or count is negative
 */
export function generateRecurringSchedule(
  startDate: string,
  repeatType: RepeatType,
  count: number
): string[] {
  // Validate count
  if (count < 0) {
    throw new Error('Count must be a non-negative number');
  }

  if (count === 0) {
    return [];
  }

  // Validate date format and parse
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(startDate)) {
    throw new Error('Invalid date format. Expected YYYY-MM-DD');
  }

  const date = new Date(startDate + 'T00:00:00Z');
  if (isNaN(date.getTime())) {
    throw new Error('Invalid date');
  }

  // Validate repeat type
  const validRepeatTypes: RepeatType[] = ['daily', 'weekly', 'monthly', 'yearly'];
  if (!validRepeatTypes.includes(repeatType)) {
    throw new Error(`Invalid repeat type. Must be one of: ${validRepeatTypes.join(', ')}`);
  }

  // Generate recurring dates based on type
  switch (repeatType) {
    case 'daily':
      return generateDailySchedule(date, count);
    case 'weekly':
      return generateWeeklySchedule(date, count);
    case 'monthly':
      return generateMonthlySchedule(date, count);
    case 'yearly':
      return generateYearlySchedule(date, count);
    default:
      throw new Error('Invalid repeat type');
  }
}

/**
 * Generates daily recurring dates
 */
function generateDailySchedule(startDate: Date, count: number): string[] {
  const results: string[] = [];
  const currentDate = new Date(startDate);

  for (let i = 0; i < count; i++) {
    currentDate.setUTCDate(currentDate.getUTCDate() + 1);
    results.push(formatDate(currentDate));
  }

  return results;
}

/**
 * Generates weekly recurring dates (same weekday)
 */
function generateWeeklySchedule(startDate: Date, count: number): string[] {
  const results: string[] = [];
  const currentDate = new Date(startDate);

  for (let i = 0; i < count; i++) {
    currentDate.setUTCDate(currentDate.getUTCDate() + 7);
    results.push(formatDate(currentDate));
  }

  return results;
}

/**
 * Generates monthly recurring dates
 * Only generates dates when the specific day exists in the month
 */
function generateMonthlySchedule(startDate: Date, count: number): string[] {
  const results: string[] = [];
  const targetDay = startDate.getUTCDate();
  let year = startDate.getUTCFullYear();
  let month = startDate.getUTCMonth();

  let generated = 0;
  while (generated < count) {
    // Move to next month
    month++;
    if (month > 11) {
      month = 0;
      year++;
    }

    // Check if target day exists in this month
    if (isValidDateInMonth(year, month, targetDay)) {
      const date = new Date(Date.UTC(year, month, targetDay));
      results.push(formatDate(date));
      generated++;
    }
  }

  return results;
}

/**
 * Generates yearly recurring dates
 * For Feb 29, only generates in leap years
 */
function generateYearlySchedule(startDate: Date, count: number): string[] {
  const results: string[] = [];
  const targetMonth = startDate.getUTCMonth();
  const targetDay = startDate.getUTCDate();
  let year = startDate.getUTCFullYear();

  let generated = 0;
  while (generated < count) {
    // Move to next year
    year++;

    // Check if target date exists in this year
    if (isValidDateInMonth(year, targetMonth, targetDay)) {
      const date = new Date(Date.UTC(year, targetMonth, targetDay));
      results.push(formatDate(date));
      generated++;
    }
  }

  return results;
}

/**
 * Checks if a specific day exists in a given month
 */
function isValidDateInMonth(year: number, month: number, day: number): boolean {
  const daysInMonth = getDaysInMonth(year, month);
  return day <= daysInMonth;
}

/**
 * Gets the number of days in a specific month
 */
function getDaysInMonth(year: number, month: number): number {
  // month is 0-indexed (0 = January, 1 = February, etc.)
  const daysInMonths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  
  if (month === 1 && isLeapYear(year)) {
    return 29;
  }
  
  return daysInMonths[month];
}

/**
 * Checks if a year is a leap year
 */
function isLeapYear(year: number): boolean {
  // Leap year rules:
  // - Divisible by 4: leap year
  // - EXCEPT divisible by 100: not a leap year
  // - EXCEPT divisible by 400: leap year
  if (year % 400 === 0) return true;
  if (year % 100 === 0) return false;
  if (year % 4 === 0) return true;
  return false;
}

/**
 * Formats a Date object to YYYY-MM-DD string
 */
function formatDate(date: Date): string {
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, '0');
  const day = String(date.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}
```

This implementation:

1. **Function signature**: `generateRecurringSchedule(startDate: string, repeatType: RepeatType, count: number): string[]`

2. **Input validation**:
   - Validates date format using regex and Date parsing
   - Validates repeat type against allowed values
   - Validates count (throws for negative, returns empty array for 0)

3. **Daily repeat**: Adds 1 day for each occurrence

4. **Weekly repeat**: Adds 7 days to maintain the same weekday

5. **Monthly repeat**: Only generates when the target day exists in the month (e.g., 31st skips February)

6. **Yearly repeat**: Only generates when the target date exists (e.g., Feb 29 only in leap years)

7. **Leap year logic**: Correctly handles century years (divisible by 400 rule)

8. **Pure function**: No side effects, always returns new arrays

9. **All edge cases handled**: Month boundaries, year boundaries, leap years, century years
