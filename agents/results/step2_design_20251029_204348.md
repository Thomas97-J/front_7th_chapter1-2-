프로젝트 구조를 파악했습니다. Vitest와 @testing-library/react를 사용하는 프로젝트이며, 기존 테스트 예제를 통해 프로젝트의 테스트 작성 스타일을 확인했습니다.

이제 날짜 범위 검증 함수에 대한 테스트 케이스를 설계하겠습니다:

---

# 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

## Unit Tests

### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 '2025-01-01', 종료일이 '2025-01-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2025-01-15'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 '2025-01-31', 종료일이 '2025-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }`를 반환한다

### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 생성된 시작일(2025-01-01)과 종료일(2025-01-31)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 문자열로 제공된 시작일('2025-01-01T00:00:00Z')과 종료일('2025-01-31T23:59:59Z')
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 6
- **이름**: should accept mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: Date 객체인 시작일과 ISO 8601 문자열인 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

---

## Error Handling Tests

### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null이고 종료일이 유효한 날짜인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 제공되지 않았습니다' }`를 반환한다

### 테스트 케이스 8
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 유효하고 종료일이 null인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일이 제공되지 않았습니다' }`를 반환한다

### 테스트 케이스 9
- **이름**: should return error when both dates are null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 null인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 제공되지 않았습니다' }`를 반환한다

### 테스트 케이스 10
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined이고 종료일이 유효한 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 제공되지 않았습니다' }`를 반환한다

### 테스트 케이스 11
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 유효하고 종료일이 undefined인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일이 제공되지 않았습니다' }`를 반환한다

### 테스트 케이스 12
- **이름**: should return error when start date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 'invalid-date-string'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 시작일 형식입니다' }`를 반환한다

### 테스트 케이스 13
- **이름**: should return error when end date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 'not-a-date'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 종료일 형식입니다' }`를 반환한다

### 테스트 케이스 14
- **이름**: should return error when start date is Invalid Date object
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 new Date('invalid')인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 시작일 형식입니다' }`를 반환한다

---

## Edge Cases Tests

### 테스트 케이스 15
- **이름**: should return valid when dates differ by 1 day
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2025-01-15', 종료일이 '2025-01-16'인 경우 (1일 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 16
- **이름**: should return valid with warning when dates differ by more than 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '1900-01-01', 종료일이 '2025-01-01'인 경우 (125년 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환한다

### 테스트 케이스 17
- **이름**: should return valid when range is exactly 100 years
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '1925-01-01', 종료일이 '2025-01-01'인 경우 (정확히 100년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다 (경고 없음)

### 테스트 케이스 18
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-02-29' (윤년), 종료일이 '2024-03-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 19
- **이름**: should handle year boundary crossing
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-12-31', 종료일이 '2025-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 20
- **이름**: should handle month boundary crossing
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2025-01-31', 종료일이 '2025-02-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 21
- **이름**: should handle dates with different time zones in ISO format
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2025-01-01T00:00:00+09:00', 종료일이 '2025-01-01T00:00:00Z'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 타임존을 고려하여 올바른 검증 결과를 반환한다

### 테스트 케이스 22
- **이름**: should handle dates at midnight
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2025-01-01T00:00:00', 종료일이 '2025-01-01T00:00:00'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 23
- **이름**: should handle dates at end of day
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2025-01-01T23:59:59', 종료일이 '2025-01-02T00:00:00'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 24
- **이름**: should handle very old dates (year 1000)
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '1000-01-01', 종료일이 '1000-12-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환한다 (현재 날짜 기준)

### 테스트 케이스 25
- **이름**: should handle far future dates (year 3000)
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '3000-01-01', 종료일이 '3000-12-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환한다

---

## Integration Tests (선택적 - React 컴포넌트 통합 시)

### 테스트 케이스 26
- **이름**: should integrate with date picker component
- **타입**: integration
- **우선순위**: medium
- **Given**: DateRangePicker 컴포넌트에서 시작일과 종료일을 선택한 경우
- **When**: 폼 제출 시 validateDateRange가 호출될 때
- **Then**: 검증 결과에 따라 적절한 UI 피드백이 표시된다

### 테스트 케이스 27
- **이름**: should display error message in UI when validation fails
- **타입**: integration
- **우선순위**: medium
- **Given**: 사용자가 종료일을 시작일보다 이전으로 선택한 경우
- **When**: 검증이 실행될 때
- **Then**: 에러 메시지가 화면에 표시된다

---

## 테스트 구현 시 고려사항

### AAA 패턴 준수
```typescript
describe('validateDateRange', () => {
  it('should return valid when start date is before end date', () => {
    // Arrange
    const startDate = '2025-01-01';
    const endDate = '2025-01-31';
    
    // Act
    const result = validateDateRange(startDate, endDate);
    
    // Assert
    expect(result).toEqual({ isValid: true });
  });
});
```

### 테스트 독립성
- 각 테스트는 독립적으로 실행 가능해야 함
- 공유 상태를 사용하지 않음
- 필요한 경우 `beforeEach`로 초기화

### 경계값 분석
- 같은 날짜 (경계)
- 1일 차이 (최소 유효 범위)
- 100년 (경고 임계값)
- null/undefined (입력 없음)
- Invalid Date (잘못된 형식)

### 명확한 의도
- 테스트 이름에 예상 동작과 조건을 명시
- Given-When-Then 주석으로 의도 명확화
- 단일 책임: 각 테스트는 하나의 시나리오만 검증

이 테스트 설계는 날짜 범위 검증 함수의 모든 주요 시나리오, 에러 케이스, 경계값을 포괄하며, Vitest와 프로젝트의 기존 테스트 스타일을 따릅니다.
