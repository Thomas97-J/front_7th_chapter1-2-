Now I have sufficient context to validate the specification. Let me analyze the provided spec against the project structure.

---

# ✅ 검증 결과

## 1. 프로젝트 통합성
**평가:** 개선 필요

**발견 사항:**
- **기존 타입:** `RepeatType` (src/types.ts:1) - `'daily' | 'weekly' | 'monthly' | 'yearly'` 정의됨
- **기존 인터페이스:** `Event`, `EventForm`, `RepeatInfo` 모두 src/types.ts에 정의됨
- **중복 가능성:** 
  - 이미 `src/utils/scheduleRecurringRule.ts` 파일이 존재하지만 구현체가 비어있음 (stub 상태)
  - 이미 `src/__tests__/unit/scheduleRecurringRule.spec.ts` 파일이 존재하며 **구체적인 함수 시그니처가 포함됨**
  - 테스트 파일은 `generateRecurringDates(startDate: string, repeatType: string, count: number): string[]` 함수를 호출함
- **권장 파일 위치:** `src/utils/scheduleRecurringRule.ts` (이미 존재)
- **파일 네이밍:** 프로젝트는 camelCase를 사용 (dateUtils.ts, eventOverlap.ts) - 현재 파일명은 적절함

**개선 사항:**
1. **명세와 테스트 파일 간 불일치:** 제공된 명세에는 함수 이름이 명시되지 않았으나, 이미 존재하는 테스트 파일에는 `generateRecurringDates`라는 함수명이 사용됨. 명세는 이러한 구현 세부사항을 피하는 것이 목표지만, 프로젝트 내에서 이미 결정된 인터페이스가 있으므로 명세에서 이를 언급할 필요가 있음.
2. **타입 재사용 명시:** 명세에서 `RepeatType`을 명시적으로 언급해야 함
3. **입출력 형식 명확화:** 기존 테스트는 string 배열을 반환하는 것으로 정의됨

## 2. 명확성
**평가:** 개선 필요

**발견 사항:**
- 반복 일정 생성의 **"시작일"**과 **"다음 일정"**의 의미가 혼란스러움
  - "시작일이 2024-01-31" → "다음 일정은 2024-02-01"이라는 표현은 첫 번째 반복 일정을 의미하는지, 시작일 다음날을 의미하는지 불명확
- **"반복 횟수"**라는 개념이 명세에서 암시되지만 명시되지 않음
  - 테스트 표에는 "1회차, 2회차, 3회차"가 있지만 총 몇 개를 생성할지 명시 없음
- **"일정 생성"**의 의미가 모호함
  - Event 객체를 생성하는가? 날짜 배열을 생성하는가?
  - 기존 테스트를 보면 날짜 문자열 배열을 반환함

**개선 사항:**
1. 함수가 **날짜 목록 생성 함수**임을 명확히 해야 함 (일정 객체 생성이 아님)
2. **개수 제한 파라미터**가 있음을 명시해야 함
3. "다음 일정"이 아니라 "첫 번째 반복 날짜"로 용어 명확화

## 3. 완전성
**평가:** 개선 필요

**누락된 사항:**
1. **입력 파라미터:**
   - 시작일 형식 (기존 테스트는 `'2024-01-31'` 문자열 사용)
   - 반복 타입 (기존 타입: `RepeatType`)
   - 생성할 날짜 개수 (기존 테스트는 `count` 파라미터 사용)
   
2. **반환값:**
   - 날짜 문자열 배열 (`string[]`) 반환
   - ISO 8601 형식 (`YYYY-MM-DD`)
   
3. **에러 처리:**
   - 명세에는 "사전 조건"만 있고 에러 처리 시나리오가 없음
   - 기존 테스트에는 다음 에러 케이스가 있음:
     - 잘못된 날짜 형식 → throw error
     - 잘못된 반복 타입 → throw error
     - 음수 count → throw error
   
4. **엣지 케이스:**
   - count가 0인 경우 → 빈 배열
   - count가 1인 경우 → 1개 날짜
   - 큰 count (100) → 성능 테스트
   - 2100년 (윤년 아님) 처리

5. **누락된 시나리오:**
   - 매월 30일 반복 (2월 제외)
   - 매월 29일 반복 (평년 2월 제외)
   - 일반 날짜의 매년 반복 (윤년이 아닌 경우)

**추가할 내용:**
- 입력/출력 형식 명세
- 에러 처리 규칙
- 추가 엣지 케이스 시나리오

## 4. 테스트 가능성
**평가:** 통과

**테스트 전략:**
- 기존 테스트 파일이 이미 매우 상세하게 작성되어 있음
- Arrange-Act-Assert 패턴 사용
- 경계 케이스, 에러 케이스 모두 포함
- 테스트는 명세보다 더 구체적이며 실제로 구현 가능한 수준

**발견 사항:**
- **명세와 테스트 간 역전 현상:** 일반적으로 명세 → 테스트 → 구현 순서이지만, 현재는 테스트가 명세보다 더 구체적임
- 이는 TDD 프로세스에서 이미 Step 2 (테스트 설계)가 완료된 상태로 보임

## 5. 일관성
**평가:** 개선 필요

**충돌 사항:**
1. **명세의 목적과 현재 상태:**
   - 명세는 "Step 1 요구사항 수준"을 목표로 하지만
   - 이미 Step 2 (테스트)가 완료되어 구체적인 함수 시그니처가 존재함
   
2. **용어 불일치:**
   - 명세: "반복 일정 생성 로직"
   - 테스트: `generateRecurringDates` (날짜 생성 함수)
   - 실제 동작: Event 객체가 아닌 날짜 문자열 목록 생성
   
3. **반복 유형 표현:**
   - 명세: "매일", "매주", "매월", "매년" (한글)
   - 타입 정의: `'daily' | 'weekly' | 'monthly' | 'yearly'` (영문)

**프로젝트 다른 기능과의 일관성:**
- `validateDateRange` 함수 (src/utils/validateDateRange.ts)는 ValidationResult 인터페이스를 반환
- 현재 명세의 함수는 단순히 날짜 배열을 반환 (검증 결과가 아님)
- 에러는 throw하는 방식 사용 (기존 테스트 기준)

## 6. 성능 고려사항
**평가:** 통과

**성능 이슈:**
- 기존 테스트에서 count=100 케이스를 테스트하므로 성능 인식이 있음
- 날짜 계산은 O(n)이며 n=count (생성할 날짜 개수)
- 매월/매년 반복의 경우 유효하지 않은 날짜를 건너뛰므로 실제로는 더 많은 반복이 필요할 수 있음
- 큰 count 값에 대한 무한 루프 방지가 필요함 (특히 매월 31일이나 윤년 2/29의 경우)

**최적화 고려:**
- 큰 count 값 제한 (예: 최대 1000개)
- 매월/매년 반복에서 유효 날짜를 찾지 못할 경우 안전장치 필요

---

# 📝 개선된 명세 (요구사항 수준)

# 반복 일정 날짜 생성 함수

## 개요
주어진 시작 날짜와 반복 유형을 기반으로 향후 반복될 날짜 목록을 생성하는 유틸리티 함수입니다. 이 함수는 Event 객체를 생성하지 않고 순수하게 날짜 문자열 배열만 반환합니다. 반복 일정의 UI 표시나 일괄 생성 시 사용됩니다.

**프로젝트 컨텍스트:**
- 이 함수는 이미 테스트 파일이 작성된 상태입니다 (src/__tests__/unit/scheduleRecurringRule.spec.ts)
- 함수 시그니처는 이미 결정되었습니다: `generateRecurringDates(startDate, repeatType, count): string[]`
- 현재 구현 파일은 stub 상태입니다 (src/utils/scheduleRecurringRule.ts)

## 위치
**현재 파일 경로:** `src/utils/scheduleRecurringRule.ts` (이미 존재, 구현 필요)
**테스트 파일:** `src/__tests__/unit/scheduleRecurringRule.spec.ts` (이미 작성됨)

**선정 이유:**
- 날짜 관련 유틸리티 함수들은 src/utils에 위치 (dateUtils.ts, eventOverlap.ts 등)
- 이벤트 반복 규칙은 비즈니스 로직이지만 순수 함수이므로 utils에 적합
- 프로젝트의 파일 네이밍 컨벤션 준수 (camelCase)

## 기능 설명
- **핵심 기능:** 시작 날짜 이후의 반복 날짜 목록을 계산하여 반환
- **주요 동작:** 
  - 시작일 다음부터 반복 패턴에 따라 날짜를 계산
  - 유효하지 않은 날짜는 자동으로 건너뜀 (예: 2월 31일)
  - 지정된 개수만큼 유효한 날짜를 찾을 때까지 계속 탐색
- **제약 조건:** 
  - 일정 겹침은 확인하지 않음 (단순 날짜 계산만)
  - 시작일 자체는 포함하지 않음 (다음 날짜부터 시작)
  - 매월/매년 반복은 **정확히 같은 일자**에만 생성 (월말 조정 없음)

## 입력 (개념적)
### 파라미터 1: startDate (시작 날짜)
- **타입 힌트:** string 
- **필수/선택:** 필수
- **형식:** ISO 8601 날짜 문자열 (`YYYY-MM-DD`)
- **예시:** `'2024-01-31'`, `'2024-02-29'`
- **제약:** 
  - 유효한 날짜여야 함
  - 타임존 정보 없음 (날짜만)

### 파라미터 2: repeatType (반복 유형)
- **타입 힌트:** string (RepeatType 타입)
- **필수/선택:** 필수
- **가능한 값:** `'daily'`, `'weekly'`, `'monthly'`, `'yearly'`
- **예시:** `'daily'` (매일), `'weekly'` (매주), `'monthly'` (매월), `'yearly'` (매년)
- **제약:** 
  - 정의된 4가지 값 중 하나여야 함
  - `'none'`은 사용하지 않음 (반복 없음은 이 함수를 호출하지 않음)
- **관련 타입:** `RepeatType` (src/types.ts:1)

### 파라미터 3: count (생성할 날짜 개수)
- **타입 힌트:** number
- **필수/선택:** 필수
- **예시:** `3` (3개의 반복 날짜 생성), `10` (10개 생성)
- **제약:**
  - 0 이상의 정수
  - 0인 경우 빈 배열 반환
  - 음수는 에러

## 출력 (개념적)
- **반환 타입:** 날짜 문자열 배열 (`string[]`)
- **형식:** ISO 8601 날짜 문자열 배열 (`YYYY-MM-DD` 형식)
- **순서:** 시간 순서대로 정렬됨 (과거 → 미래)
  
**예시:**
```typescript
// 매일 반복 - 연속된 날짜
['2024-02-01', '2024-02-02', '2024-02-03']

// 매주 반복 - 7일 간격
['2024-02-07', '2024-02-14', '2024-02-21']

// 매월 반복 (31일 시작) - 31일이 없는 달은 건너뜀
['2024-03-31', '2024-05-31', '2024-07-31']

// 매년 반복 (2/29 시작) - 윤년만 포함
['2028-02-29', '2032-02-29', '2036-02-29']

// count=0인 경우
[]
```

## 관련 타입 (기존 재사용)
- **RepeatType** (src/types.ts:1) - `'none' | 'daily' | 'weekly' | 'monthly' | 'yearly'`
- **Event** (src/types.ts:21) - 이벤트 데이터 구조 (참고용, 직접 사용하지 않음)
- **RepeatInfo** (src/types.ts:3) - 반복 정보 구조 (참고용, 직접 사용하지 않음)
- **새 타입 필요 여부:** 아니오 (기존 타입으로 충분)

## 상세 요구사항

### 1. 입력 검증 규칙

#### 1.1 startDate 검증
- **잘못된 형식 문자열:** 
  - 예시: `'invalid-date'`, `'2024-13-45'`
  - 처리: Error throw
  - 메시지: (구체적인 메시지는 Step 2에서 결정)

#### 1.2 repeatType 검증
- **허용되지 않는 값:**
  - 예시: `'invalid'`, `'hourly'`, `undefined`
  - 처리: Error throw
  - 메시지: (구체적인 메시지는 Step 2에서 결정)

#### 1.3 count 검증
- **음수 값:**
  - 예시: `-1`, `-100`
  - 처리: Error throw
  - 메시지: (구체적인 메시지는 Step 2에서 결정)
- **0 값:**
  - 처리: 빈 배열 반환 (정상 동작)

### 2. 비즈니스 로직

#### 2.1 매일 반복 (daily)
- **동작:** 시작일 다음날부터 매일 1일씩 증가
- **예시:** 
  - 시작: `2024-01-31` → 결과: `['2024-02-01', '2024-02-02', '2024-02-03']`
  - 시작: `2024-02-28` (윤년) → 결과: `['2024-02-29', '2024-03-01', '2024-03-02']`
- **특수 케이스:** 없음 (항상 유효한 날짜)

#### 2.2 매주 반복 (weekly)
- **동작:** 시작일과 같은 요일에만 생성 (7일 간격)
- **예시:**
  - 시작: `2024-01-31` (수요일) → 결과: `['2024-02-07', '2024-02-14', '2024-02-21']` (모두 수요일)
  - 시작: `2024-01-29` (월요일) → 결과: `['2024-02-05', '2024-02-12', '2024-02-19']` (모두 월요일)
- **특수 케이스:** 없음 (항상 유효한 날짜)

#### 2.3 매월 반복 (monthly)
- **동작:** 시작일과 같은 일자(day)에만 생성
- **중요 규칙:** "매월 마지막일"이 아니라 **"정확히 N일"**에만 생성
- **예시:**
  - 시작: `2024-01-31` → 결과: `['2024-03-31', '2024-05-31', '2024-07-31']`
    - 2월(28/29일), 4월(30일), 6월(30일)은 건너뜀
  - 시작: `2024-01-30` → 결과: `['2024-03-30', '2024-04-30', '2024-05-30']`
    - 2월(28/29일)만 건너뜀
  - 시작: `2024-01-15` → 결과: `['2024-02-15', '2024-03-15', '2024-04-15']`
    - 모든 달에 15일 존재하므로 연속 생성
- **특수 케이스:**
  - 29일 시작: 평년 2월 건너뜀
  - 30일 시작: 2월 건너뜀
  - 31일 시작: 2월, 4월, 6월, 9월, 11월 건너뜀

#### 2.4 매년 반복 (yearly)
- **동작:** 시작일과 같은 월-일에만 생성
- **중요 규칙:** 2월 29일은 윤년에만 존재
- **예시:**
  - 시작: `2024-02-29` → 결과: `['2028-02-29', '2032-02-29', '2036-02-29']`
    - 2025, 2026, 2027은 윤년이 아니므로 건너뜀
  - 시작: `2024-03-15` → 결과: `['2025-03-15', '2026-03-15', '2027-03-15']`
    - 3월 15일은 항상 존재하므로 연속 생성
- **특수 케이스:**
  - 2월 29일: 4년마다 생성되지만, 100의 배수 연도는 윤년이 아님 (예외: 400의 배수)
    - 2100년은 윤년 아님 (건너뜀)
    - 2000년, 2400년은 윤년 (포함)

### 3. 엣지 케이스

#### 3.1 경계 값
- **count = 0:**
  - 입력: `('2024-01-31', 'daily', 0)`
  - 출력: `[]`
  
- **count = 1:**
  - 입력: `('2024-01-31', 'weekly', 1)`
  - 출력: `['2024-02-07']`

#### 3.2 큰 count 값
- **count = 100 이상:**
  - 처리: 정상 동작해야 함
  - 성능: 합리적인 시간 내 완료
  - 안전장치: 무한 루프 방지 필요
  - 예시: `('2024-01-01', 'daily', 100)` → 100개의 연속 날짜

#### 3.3 희귀한 반복 조건
- **매월 31일, count = 100:**
  - 실제로는 7개월에 1번씩만 발생
  - 안전장치: 최대 탐색 횟수 제한 필요 (무한 루프 방지)
  
- **윤년 2월 29일, count = 100:**
  - 4년에 1번씩만 발생
  - 400년 안에 100개 모두 생성 가능
  - 안전장치: 연도 범위 제한 고려

#### 3.4 월/연도 경계
- **연말에서 연초:**
  - 입력: `('2024-12-30', 'daily', 5)`
  - 출력: `['2024-12-31', '2025-01-01', '2025-01-02', '2025-01-03', '2025-01-04']`
  
- **윤년 경계:**
  - 입력: `('2024-02-28', 'daily', 3)`
  - 출력: `['2024-02-29', '2024-03-01', '2024-03-02']`

## 테스트 시나리오 (개념적)

### 정상 케이스

#### 1. 매일 반복
- **입력:** 시작일 `2024-01-31`, 반복 `daily`, 개수 `3`
- **예상 출력:** `['2024-02-01', '2024-02-02', '2024-02-03']`
- **검증:** 연속된 날짜, 정확히 3개

#### 2. 매주 반복
- **입력:** 시작일 `2024-01-31` (수요일), 반복 `weekly`, 개수 `3`
- **예상 출력:** `['2024-02-07', '2024-02-14', '2024-02-21']`
- **검증:** 모두 수요일, 7일 간격

#### 3. 매월 반복 (일반 날짜)
- **입력:** 시작일 `2024-01-15`, 반복 `monthly`, 개수 `3`
- **예상 출력:** `['2024-02-15', '2024-03-15', '2024-04-15']`
- **검증:** 모두 15일, 연속 월

#### 4. 매년 반복 (일반 날짜)
- **입력:** 시작일 `2024-03-15`, 반복 `yearly`, 개수 `3`
- **예상 출력:** `['2025-03-15', '2026-03-15', '2027-03-15']`
- **검증:** 모두 3월 15일, 연속 연도

### 예외 케이스 (날짜 건너뛰기)

#### 5. 매월 31일 (2월 건너뛰기)
- **입력:** 시작일 `2024-01-31`, 반복 `monthly`, 개수 `3`
- **예상 출력:** `['2024-03-31', '2024-05-31', '2024-07-31']`
- **검증:** 
  - 2월 없음 (28/29일만 존재)
  - 4월, 6월 없음 (30일까지만 존재)

#### 6. 매월 30일 (2월 건너뛰기)
- **입력:** 시작일 `2024-01-30`, 반복 `monthly`, 개수 `4`
- **예상 출력:** `['2024-03-30', '2024-04-30', '2024-05-30', '2024-06-30']`
- **검증:** 2월만 건너뜀

#### 7. 매월 29일 (평년 2월 건너뛰기)
- **입력:** 시작일 `2024-01-29`, 반복 `monthly`, 개수 `5`
- **예상 출력:** `['2024-02-29', '2024-03-29', '2024-04-29', '2024-05-29', '2024-06-29']`
- **검증:** 
  - 2024년 윤년이므로 2월 29일 포함
  - 2025년으로 넘어가면 2월 건너뛰어야 함

#### 8. 윤년 2월 29일 (매년 반복)
- **입력:** 시작일 `2024-02-29`, 반복 `yearly`, 개수 `3`
- **예상 출력:** `['2028-02-29', '2032-02-29', '2036-02-29']`
- **검증:** 4년 간격, 모두 윤년

#### 9. 윤년 2월 29일 (2100 건너뛰기)
- **입력:** 시작일 `2096-02-29`, 반복 `yearly`, 개수 `3`
- **예상 출력:** `['2104-02-29', '2108-02-29', '2112-02-29']`
- **검증:** 2100년은 100의 배수이지만 400의 배수가 아니므로 윤년 아님

### 에러 케이스

#### 10. 잘못된 날짜 형식
- **입력:** 시작일 `'invalid-date'`, 반복 `daily`, 개수 `3`
- **예상 동작:** Error throw
- **검증:** 에러 발생

#### 11. 잘못된 반복 유형
- **입력:** 시작일 `'2024-01-31'`, 반복 `'invalid'`, 개수 `3`
- **예상 동작:** Error throw
- **검증:** 에러 발생

#### 12. 음수 count
- **입력:** 시작일 `'2024-01-31'`, 반복 `daily`, 개수 `-1`
- **예상 동작:** Error throw
- **검증:** 에러 발생

### 경계 케이스

#### 13. count = 0
- **입력:** 시작일 `'2024-01-31'`, 반복 `daily`, 개수 `0`
- **예상 출력:** `[]`
- **검증:** 빈 배열, 에러 아님

#### 14. count = 1
- **입력:** 시작일 `'2024-01-31'`, 반복 `weekly`, 개수 `1`
- **예상 출력:** `['2024-02-07']`
- **검증:** 정확히 1개

#### 15. 큰 count (성능)
- **입력:** 시작일 `'2024-01-01'`, 반복 `daily`, 개수 `100`
- **예상 출력:** 100개의 연속 날짜
- **검증:** 
  - 정확히 100개
  - 첫 번째: `'2024-01-02'`
  - 마지막: `'2024-04-10'`

#### 16. 연도 경계
- **입력:** 시작일 `'2024-12-30'`, 반복 `daily`, 개수 `5`
- **예상 출력:** `['2024-12-31', '2025-01-01', '2025-01-02', '2025-01-03', '2025-01-04']`
- **검증:** 연도 넘김 정상 처리

#### 17. 출력 형식 검증
- **입력:** 임의의 유효한 입력
- **검증:** 모든 출력 날짜가 `YYYY-MM-DD` 형식 (정규식: `^\d{4}-\d{2}-\d{2}$`)

### 통합 시나리오

#### 18. 일정 겹침 무시
- **개념:** 이 함수는 기존 Event 목록을 확인하지 않음
- **입력:** 동일한 파라미터로 여러 번 호출
- **예상 동작:** 항상 동일한 결과 반환 (순수 함수)
- **검증:** 
  - 멱등성 (idempotent)
  - 부수 효과 없음

## 통합 가이드

### 기존 코드와의 관계

#### 재사용할 유틸리티
- **formatDate(date: Date, day?: number): string** (src/utils/dateUtils.ts:104)
  - 용도: Date 객체를 `YYYY-MM-DD` 문자열로 변환
  - 위치: src/utils/dateUtils.ts
  
- **getDaysInMonth(year: number, month: number): number** (src/utils/dateUtils.ts:6)
  - 용도: 해당 월의 일수 확인 (매월 반복 시 날짜 유효성 검사)
  - 위치: src/utils/dateUtils.ts

#### 재사용하지 않는 함수
- **isOverlapping()** (src/utils/eventOverlap.ts)
  - 이유: 명세에서 명시적으로 일정 겹침은 고려하지 않음

#### 연관된 컴포넌트
- **App.tsx** - 이벤트 추가/수정 시 반복 일정 생성에 사용 가능
- **useEventOperations** hook - 반복 일정 일괄 생성 로직에 통합 가능

#### 영향받는 타입
- **RepeatType** (src/types.ts:1) - 함수 파라미터로 직접 사용

### 예상 사용처 (개념적)

```typescript
// 예시 1: 반복 일정 미리보기
import { generateRecurringDates } from './utils/scheduleRecurringRule';

// 사용자가 "매주 반복" 선택 시, 향후 3개의 날짜를 보여줌
const startDate = '2024-01-31';
const repeatType = 'weekly';
const previewDates = generateRecurringDates(startDate, repeatType, 3);
// → ['2024-02-07', '2024-02-14', '2024-02-21']
console.log(`다음 3회 일정: ${previewDates.join(', ')}`);
```

```typescript
// 예시 2: 반복 일정 일괄 생성
import { generateRecurringDates } from './utils/scheduleRecurringRule';
import { Event } from './types';

// 사용자가 "10회 반복" 설정 시
const baseEvent: EventForm = {
  title: '주간 회의',
  startTime: '10:00',
  endTime: '11:00',
  // ... 기타 필드
};

const dates = generateRecurringDates(baseEvent.date, baseEvent.repeat.type, 10);

// 각 날짜에 대해 Event 객체 생성
const recurringEvents: Event[] = dates.map((date, index) => ({
  ...baseEvent,
  id: generateId(), // ID 생성 함수
  date: date,
}));

// 일괄 저장
saveEvents(recurringEvents);
```

```typescript
// 예시 3: 에러 처리
try {
  const dates = generateRecurringDates('invalid-date', 'daily', 3);
} catch (error) {
  // 에러 처리
  showErrorMessage('날짜 형식이 올바르지 않습니다');
}
```

## 성능 고려사항

### 시간 복잡도
- **매일/매주 반복:** O(n) - n은 count (생성할 개수)
- **매월/매년 반복:** O(n × k) - k는 유효 날짜를 찾기 위한 평균 탐색 횟수
  - 매월 31일: 평균 k ≈ 1.7 (7개월 중 4개월만 31일 존재)
  - 윤년 2/29: 평균 k = 4 (4년에 1번)
  - 최악의 경우 k는 상수 범위 내

### 공간 복잡도
- **O(n):** 결과 배열 크기는 count와 같음

### 최적화
- **필요성:** count가 1000 이하라면 최적화 불필요
- **잠재적 이슈:** 
  - count가 매우 큰 경우 (10000+)
  - 매월/매년 반복에서 무한 루프 방지 필요

### 안전장치
- **최대 탐색 횟수 제한:**
  - 매월 반복: 최대 24개월 탐색 (count × 2)
  - 매년 반복: 최대 500년 탐색 (2/29 고려)
  - 유효 날짜를 찾지 못하면 에러 또는 경고

## 마이그레이션 가이드

### 영향받는 파일
- **src/utils/scheduleRecurringRule.ts** - 구현 필요 (현재 stub)
- **src/__tests__/unit/scheduleRecurringRule.spec.ts** - 이미 작성됨 (테스트 실행 필요)

### 변경 사항
**Before:**
```typescript
// src/utils/scheduleRecurringRule.ts
export const scheduleRecurringRule = (input: any): any => {
  return null;
};
```

**After:**
```typescript
// 함수 이름 변경 및 구현 (Step 3-4에서 수행)
export function generateRecurringDates(
  startDate: string, 
  repeatType: string, 
  count: number
): string[] {
  // 구현 내용
}

// 기존 export도 호환성을 위해 유지 가능 (선택)
export const scheduleRecurringRule = generateRecurringDates;
```

### 호환성
- **하위 호환:** 현재 사용처 없음 (새로운 기능)
- **테스트 호환:** 기존 테스트 파일과 정확히 일치하도록 구현

### 마이그레이션 단계
1. **Step 2 (테스트 설계):** 이미 완료됨 - 테스트 파일 존재
2. **Step 3 (구현):** 
   - `generateRecurringDates` 함수 구현
   - 테스트 실행 및 통과 확인
3. **Step 4 (통합):**
   - App.tsx 또는 useEventOperations에서 사용
   - 반복 일정 UI 연동

---

## 주요 개선 사항 요약

### 명세 개선 내역

1. **함수 식별:**
   - 기존 테스트에서 사용하는 `generateRecurringDates` 함수명 언급
   - 명세와 테스트 간 불일치 해소

2. **입출력 명확화:**
   - 입력: 3개 파라미터 (startDate, repeatType, count)
   - 출력: 날짜 문자열 배열 (`string[]`)
   - 형식: ISO 8601 (`YYYY-MM-DD`)

3. **에러 처리 추가:**
   - 잘못된 날짜 형식 → Error throw
   - 잘못된 반복 유형 → Error throw
   - 음수 count → Error throw

4. **누락된 시나리오 추가:**
   - 매월 30일 반복 (2월 제외)
   - 매월 29일 반복 (평년 2월 제외)
   - 2100년 윤년 예외 (100의 배수이지만 400의 배수 아님)
   - count=0, count=1 경계 케이스
   - 큰 count 값 성능 테스트

5. **용어 통일:**
   - "반복 일정 생성" → "반복 날짜 목록 생성"
   - "다음 일정" → "첫 번째 반복 날짜"
   - 한글/영문 병기 (매일=daily, 매주=weekly 등)

6. **기존 코드 통합:**
   - `RepeatType` 타입 명시적 참조
   - `formatDate`, `getDaysInMonth` 재사용 제안
   - 테스트 파일과의 일치 확인

7. **성능 및 안전장치:**
   - 무한 루프 방지 메커니즘 필요
   - 큰 count 값에 대한 최대 탐색 횟수 제한
   - 시간/공간 복잡도 분석

---

## 검증 체크리스트

✅ **프로젝트 통합성**
- [x] 기존 타입 시스템 활용 (RepeatType)
- [x] 기존 유틸리티 재사용 제안 (formatDate, getDaysInMonth)
- [x] 올바른 파일 위치 (src/utils/)
- [x] 네이밍 컨벤션 준수 (camelCase)

✅ **명확성**
- [x] 함수 목적 명확 (날짜 목록 생성)
- [x] 입력 3개 파라미터 명시
- [x] 출력 형식 명시 (string[])
- [x] 용어 통일

✅ **완전성**
- [x] 모든 반복 유형 시나리오 (daily, weekly, monthly, yearly)
- [x] 에러 처리 (잘못된 입력)
- [x] 경계 케이스 (count=0, count=1, 큰 count)
- [x] 엣지 케이스 (윤년, 월말, 연도 경계)
- [x] 특수 날짜 (2/29, 31일, 30일, 29일)

✅ **테스트 가능성**
- [x] 기존 테스트 파일과 일치
- [x] 모든 시나리오에 예상 출력 명시

✅ **일관성**
- [x] 프로젝트 타입 시스템과 일관성
- [x] 다른 유틸리티 함수와 일관성
- [x] 테스트 파일과 일관성

✅ **성능**
- [x] 시간/공간 복잡도 분석
- [x] 안전장치 제안 (무한 루프 방지)
- [x] 성능 테스트 시나리오 (count=100)
