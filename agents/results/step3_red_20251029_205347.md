```typescript
// filepath: src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('기본 동작', () => {
    it('should return isValid true when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid true when start date equals end date', () => {
      // Arrange
      const startDate = '2024-06-15';
      const endDate = '2024-06-15';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid false with error when start date is after end date', () => {
      // Arrange
      const startDate = '2024-12-31';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });
  });

  describe('입력 형식 처리', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 string format as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00Z';
      const endDate = '2024-12-31T23:59:59Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept mixed input types (Date object and ISO string)', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('에러 처리', () => {
    describe('null/undefined 입력', () => {
      it('should return error when startDate is null', () => {
        // Arrange
        const startDate = null;
        const endDate = '2024-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('시작일은 필수입니다');
      });

      it('should return error when startDate is undefined', () => {
        // Arrange
        const startDate = undefined;
        const endDate = '2024-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('시작일은 필수입니다');
      });

      it('should return error when endDate is null', () => {
        // Arrange
        const startDate = '2024-01-01';
        const endDate = null;

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('종료일은 필수입니다');
      });

      it('should return error when endDate is undefined', () => {
        // Arrange
        const startDate = '2024-01-01';
        const endDate = undefined;

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('종료일은 필수입니다');
      });

      it('should return error when both dates are null', () => {
        // Arrange
        const startDate = null;
        const endDate = null;

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('시작일은 필수입니다');
      });
    });

    describe('잘못된 형식', () => {
      it('should return error when startDate has invalid format', () => {
        // Arrange
        const startDate = 'invalid-date';
        const endDate = '2024-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
      });

      it('should return error when endDate has invalid format', () => {
        // Arrange
        const startDate = '2024-01-01';
        const endDate = 'not-a-date';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('종료일 형식이 올바르지 않습니다');
      });

      it('should return error when date string is empty', () => {
        // Arrange
        const startDate = '';
        const endDate = '2024-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
      });

      it('should return error when date is Invalid Date object', () => {
        // Arrange
        const startDate = new Date('invalid');
        const endDate = '2024-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
      });
    });
  });

  describe('엣지 케이스', () => {
    describe('날짜 경계', () => {
      it('should return isValid true when dates are exactly same', () => {
        // Arrange
        const startDate = '2024-06-15T12:00:00Z';
        const endDate = '2024-06-15T12:00:00Z';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
      });

      it('should return isValid true when dates differ by one day', () => {
        // Arrange
        const startDate = '2024-06-15';
        const endDate = '2024-06-16';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
      });

      it('should return isValid true when dates differ by exactly one millisecond', () => {
        // Arrange
        const startDate = '2024-06-15T12:00:00.000Z';
        const endDate = '2024-06-15T12:00:00.001Z';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
      });
    });

    describe('긴 기간 범위', () => {
      it('should return isValid true with warning when dates differ by more than 100 years', () => {
        // Arrange
        const startDate = '1900-01-01';
        const endDate = '2024-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
        expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
      });

      it('should return isValid true with warning when dates differ by exactly 100 years', () => {
        // Arrange
        const startDate = '1924-01-01';
        const endDate = '2024-01-01';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
        expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
      });
    });

    describe('특수 날짜', () => {
      it('should handle leap year dates correctly', () => {
        // Arrange
        const startDate = '2024-02-29';
        const endDate = '2024-03-01';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
      });

      it('should handle year boundary correctly', () => {
        // Arrange
        const startDate = '2023-12-31';
        const endDate = '2024-01-01';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
      });

      it('should handle very old dates (past century)', () => {
        // Arrange
        const startDate = '1900-01-01';
        const endDate = '1900-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
      });

      it('should handle far future dates', () => {
        // Arrange
        const startDate = '2100-01-01';
        const endDate = '2200-12-31';

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
        expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
      });
    });

    describe('타임존', () => {
      it('should handle timezone differences in ISO strings', () => {
        // Arrange
        const startDate = '2024-06-15T23:00:00+09:00'; // KST
        const endDate = '2024-06-15T15:00:00Z'; // UTC (same time as above)

        // Act
        const result = validateDateRange(startDate, endDate);

        // Assert
        expect(result.isValid).toBe(true);
      });
    });
  });

  describe('통합 테스트', () => {
    it('should work correctly when called multiple times with different inputs', () => {
      // Arrange & Act & Assert
      const result1 = validateDateRange('2024-01-01', '2024-12-31');
      expect(result1.isValid).toBe(true);

      const result2 = validateDateRange('2024-12-31', '2024-01-01');
      expect(result2.isValid).toBe(false);

      const result3 = validateDateRange(null, '2024-12-31');
      expect(result3.isValid).toBe(false);

      const result4 = validateDateRange('2024-06-15', '2024-06-15');
      expect(result4.isValid).toBe(true);
    });

    it('should not mutate input Date objects', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');
      const startDateCopy = new Date(startDate);
      const endDateCopy = new Date(endDate);

      // Act
      validateDateRange(startDate, endDate);

      // Assert
      expect(startDate.getTime()).toBe(startDateCopy.getTime());
      expect(endDate.getTime()).toBe(endDateCopy.getTime());
    });

    it('should be consistent between Date objects and ISO string inputs', () => {
      // Arrange
      const dateStr = '2024-06-15T12:00:00Z';
      const dateObj = new Date(dateStr);
      const endDateStr = '2024-12-31T12:00:00Z';
      const endDateObj = new Date(endDateStr);

      // Act
      const result1 = validateDateRange(dateStr, endDateStr);
      const result2 = validateDateRange(dateObj, endDateObj);

      // Assert
      expect(result1.isValid).toBe(result2.isValid);
      expect(result1.error).toBe(result2.error);
      expect(result1.warning).toBe(result2.warning);
    });
  });
});
```

```typescript
// filepath: src/utils/validateDateRange.ts

type DateInput = Date | string | null | undefined;

interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

export function validateDateRange(
  startDate: DateInput,
  endDate: DateInput
): ValidationResult {
  // Check for null/undefined
  if (startDate === null || startDate === undefined) {
    return { isValid: false, error: '시작일은 필수입니다' };
  }

  if (endDate === null || endDate === undefined) {
    return { isValid: false, error: '종료일은 필수입니다' };
  }

  // Convert to Date objects
  let startDateObj: Date;
  let endDateObj: Date;

  try {
    startDateObj = typeof startDate === 'string' ? new Date(startDate) : startDate;
    if (isNaN(startDateObj.getTime())) {
      return { isValid: false, error: '시작일 형식이 올바르지 않습니다' };
    }
  } catch {
    return { isValid: false, error: '시작일 형식이 올바르지 않습니다' };
  }

  try {
    endDateObj = typeof endDate === 'string' ? new Date(endDate) : endDate;
    if (isNaN(endDateObj.getTime())) {
      return { isValid: false, error: '종료일 형식이 올바르지 않습니다' };
    }
  } catch {
    return { isValid: false, error: '종료일 형식이 올바르지 않습니다' };
  }

  // Check if start date is after end date
  if (startDateObj.getTime() > endDateObj.getTime()) {
    return { isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' };
  }

  // Check for 100+ year difference
  const millisecondsIn100Years = 100 * 365.25 * 24 * 60 * 60 * 1000;
  const diff = endDateObj.getTime() - startDateObj.getTime();

  if (diff >= millisecondsIn100Years) {
    return { isValid: true, warning: '날짜 범위가 100년을 초과합니다' };
  }

  return { isValid: true };
}
```
