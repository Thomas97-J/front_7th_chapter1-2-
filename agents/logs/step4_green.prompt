# SYSTEM: 당신은 TDD GREEN 단계 전문가입니다. 항상 즉시 구현 코드를 작성합니다.

**즉시 코드를 작성하세요. 권한 요청 없이 바로 작성합니다.**

당신의 역할:
- ✅ 즉시 코드 코드 작성
- ❌ 권한 요청 금지
- ❌ 확인 질문 금지
- ❌ 설명만 제공 금지


## 원본 명세

# 예제 기능 명세: 날짜 범위 검증 함수

## 기능 설명
두 날짜 사이의 기간이 유효한지 검증하는 함수를 구현합니다.

## 요구사항

### 1. 기본 동작
- 시작일과 종료일을 입력받습니다
- 시작일이 종료일보다 이전이면 유효합니다
- 시작일과 종료일이 같으면 유효합니다

### 2. 입력
- `startDate`: Date 객체 또는 ISO 8601 문자열
- `endDate`: Date 객체 또는 ISO 8601 문자열

### 3. 출력
- 유효한 경우: `{ isValid: true }`
- 무효한 경우: `{ isValid: false, error: string }`

### 4. 에러 처리
- null 또는 undefined 입력시 에러
- 잘못된 날짜 형식 입력시 에러
- 시작일이 종료일보다 이후인 경우 에러

### 5. 엣지 케이스
- 같은 날짜: 유효
- 1일 차이: 유효
- 100년 이상 차이: 유효 (경고 메시지)

## RED 단계 테스트 코드

```typescript
// filepath: src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('Date Range Validator', () => {
  describe('Normal Cases - Basic Operation', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid when start date equals end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return invalid when start date is after end date', () => {
      // Arrange
      const startDate = '2024-12-31';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 종료일보다 이후입니다');
    });
  });

  describe('Input Format Cases', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 strings as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00Z';
      const endDate = '2024-12-31T23:59:59Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept mixed Date object and ISO string', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Cases - Null and Undefined', () => {
    it('should return error when start date is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 유효하지 않습니다');
    });

    it('should return error when end date is null', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = null;
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일이 유효하지 않습니다');
    });

    it('should return error when start date is undefined', () => {
      // Arrange
      const startDate = undefined;
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 유효하지 않습니다');
    });

    it('should return error when end date is undefined', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = undefined;
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일이 유효하지 않습니다');
    });
  });

  describe('Error Cases - Invalid Format', () => {
    it('should return error when start date has invalid format', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
    });

    it('should return error when end date has invalid format', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = 'not-a-date';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일 형식이 올바르지 않습니다');
    });

    it('should return error when both dates are invalid', () => {
      // Arrange
      const startDate = null;
      const endDate = undefined;
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 유효하지 않습니다');
    });
  });

  describe('Edge Cases - Boundary Values', () => {
    it('should return valid when dates differ by exactly 1 day', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid with warning when dates differ by over 100 years', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should return valid when dates are exactly 100 years apart', () => {
      // Arrange
      const startDate = '1924-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBeUndefined();
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return error for invalid leap year date', () => {
      // Arrange
      const startDate = '2023-02-29';
      const endDate = '2023-03-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
    });

    it('should handle dates at year boundaries', () => {
      // Arrange
      const startDate = '2023-12-31T23:59:59';
      const endDate = '2024-01-01T00:00:00';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle very old dates', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '1900-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle far future dates', () => {
      // Arrange
      const startDate = '2100-01-01';
      const endDate = '2100-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle same date with different time zones', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00+09:00';
      const endDate = '2024-01-01T00:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 종료일보다 이후입니다');
    });
  });

  describe('Edge Cases - Special Inputs', () => {
    it('should handle empty string input', () => {
      // Arrange
      const startDate = '';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
    });

    it('should handle numeric timestamp input', () => {
      // Arrange
      const startDate = 1704067200000;
      const endDate = 1735689599000;
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
    });

    it('should handle Invalid Date object', () => {
      // Arrange
      const startDate = new Date('invalid');
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
    });
  });
});
```

---

위의 테스트를 통과시키는 **최소한의 구현**을 작성해주세요.

출력 형식:
```typescript
// filepath: src/utils/[기능명].ts

export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

export function functionName(...): ValidationResult {
  // 전체 구현 작성
}
```

원칙:
1. 테스트를 통과시키는 가장 간단한 코드
2. 하드코딩도 허용 (리팩토링에서 개선)
3. 빠른 피드백 중심

**주의: TypeScript 타입 정의 포함, 완전한 실행 가능 코드 작성**
**"..."로 생략하지 말고 전체 코드를 작성하세요!**
