테스트를 직접 실행하는 대신, 테스트 파일의 내용을 기반으로 TDD GREEN 단계의 최소 구현을 작성하겠습니다. 테스트를 분석한 결과, 다음과 같은 유틸리티 파일들이 필요합니다:

1. **dateUtils.ts** - 날짜 관련 유틸리티 함수들
2. **eventOverlap.ts** - 이벤트 겹침 검사 함수들
3. **eventUtils.ts** - 이벤트 필터링 함수들
4. **notificationUtils.ts** - 알림 관련 함수들
5. **timeValidation.ts** - 시간 유효성 검사 함수들

각 파일에 대해 테스트를 통과시키는 최소한의 구현을 제공하겠습니다:

## 1. src/utils/dateUtils.ts

```typescript
import { Event } from '../types';

export function getDaysInMonth(year: number, month: number): number {
  return new Date(year, month, 0).getDate();
}

export function getWeekDates(date: Date): Date[] {
  const day = date.getDay();
  const diff = day === 0 ? 0 : day;
  const sunday = new Date(date);
  sunday.setDate(date.getDate() - diff);
  
  const weekDates: Date[] = [];
  for (let i = 0; i < 7; i++) {
    const newDate = new Date(sunday);
    newDate.setDate(sunday.getDate() + i);
    weekDates.push(newDate);
  }
  
  return weekDates;
}

export function getWeeksAtMonth(date: Date): (number | null)[][] {
  const year = date.getFullYear();
  const month = date.getMonth();
  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  const daysInMonth = lastDay.getDate();
  const startDayOfWeek = firstDay.getDay();
  
  const weeks: (number | null)[][] = [];
  let week: (number | null)[] = new Array(startDayOfWeek).fill(null);
  
  for (let day = 1; day <= daysInMonth; day++) {
    week.push(day);
    if (week.length === 7) {
      weeks.push(week);
      week = [];
    }
  }
  
  if (week.length > 0) {
    while (week.length < 7) {
      week.push(null);
    }
    weeks.push(week);
  }
  
  return weeks;
}

export function getEventsForDay(events: Event[], day: number): Event[] {
  if (day === 0 || day > 31) {
    return [];
  }
  
  return events.filter((event) => {
    const eventDay = parseInt(event.date.split('-')[2], 10);
    return eventDay === day;
  });
}

export function formatWeek(date: Date): string {
  const weekDates = getWeekDates(date);
  const sunday = weekDates[0];
  const saturday = weekDates[6];
  
  const sundayMonth = sunday.getMonth() + 1;
  const saturdayMonth = saturday.getMonth() + 1;
  
  let targetMonth: number;
  let targetYear: number;
  
  if (saturdayMonth !== sundayMonth) {
    targetYear = saturday.getFullYear();
    targetMonth = saturdayMonth;
  } else {
    targetYear = date.getFullYear();
    targetMonth = date.getMonth() + 1;
  }
  
  const firstDayOfMonth = new Date(targetYear, targetMonth - 1, 1);
  const weekNumber = Math.ceil((saturday.getDate() + firstDayOfMonth.getDay()) / 7);
  
  return `${targetYear}년 ${targetMonth}월 ${weekNumber}주`;
}

export function formatMonth(date: Date): string {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return `${year}년 ${month}월`;
}

export function isDateInRange(date: Date, rangeStart: Date, rangeEnd: Date): boolean {
  return date >= rangeStart && date <= rangeEnd;
}

export function fillZero(value: number, size: number = 2): string {
  return String(value).padStart(size, '0');
}

export function formatDate(date: Date, day?: number): string {
  const year = date.getFullYear();
  const month = fillZero(date.getMonth() + 1);
  const dateDay = day !== undefined ? fillZero(day) : fillZero(date.getDate());
  return `${year}-${month}-${dateDay}`;
}
```

## 2. src/utils/eventOverlap.ts

```typescript
import { Event } from '../types';

export function parseDateTime(date: string, time: string): Date {
  return new Date(`${date}T${time}:00`);
}

export function convertEventToDateRange(event: Event): { start: Date; end: Date } {
  return {
    start: parseDateTime(event.date, event.startTime),
    end: parseDateTime(event.date, event.endTime),
  };
}

export function isOverlapping(event1: Event, event2: Event): boolean {
  const range1 = convertEventToDateRange(event1);
  const range2 = convertEventToDateRange(event2);
  
  return range1.start < range2.end && range2.start < range1.end;
}

export function findOverlappingEvents(newEvent: Event, events: Event[]): Event[] {
  return events.filter((event) => isOverlapping(newEvent, event));
}
```

## 3. src/utils/eventUtils.ts

```typescript
import { Event } from '../types';
import { getWeekDates } from './dateUtils';

export function getFilteredEvents(
  events: Event[],
  searchTerm: string,
  currentDate: Date,
  view: 'week' | 'month'
): Event[] {
  return events.filter((event) => {
    const matchesSearch = searchTerm === '' || event.title.toLowerCase().includes(searchTerm.toLowerCase());
    
    const eventDate = new Date(event.date);
    let matchesView = false;
    
    if (view === 'week') {
      const weekDates = getWeekDates(currentDate);
      const weekStart = weekDates[0];
      const weekEnd = weekDates[6];
      weekStart.setHours(0, 0, 0, 0);
      weekEnd.setHours(23, 59, 59, 999);
      matchesView = eventDate >= weekStart && eventDate <= weekEnd;
    } else if (view === 'month') {
      const year = currentDate.getFullYear();
      const month = currentDate.getMonth();
      matchesView = eventDate.getFullYear() === year && eventDate.getMonth() === month;
    }
    
    return matchesSearch && matchesView;
  });
}
```

## 4. src/utils/notificationUtils.ts

```typescript
import { Event } from '../types';

export function getUpcomingEvents(
  events: Event[],
  now: Date,
  notifiedEvents: string[]
): Event[] {
  return events.filter((event) => {
    if (notifiedEvents.includes(event.id)) {
      return false;
    }
    
    const eventDate = new Date(`${event.date}T${event.startTime}:00`);
    const notificationTime = new Date(eventDate.getTime() - event.notificationTime * 60000);
    
    return now >= notificationTime && now < eventDate;
  });
}

export function createNotificationMessage(event: Event): string {
  return `${event.notificationTime}분 후 ${event.title} 일정이 시작됩니다.`;
}
```

## 5. src/utils/timeValidation.ts

```typescript
export function getTimeErrorMessage(
  startTime: string,
  endTime: string
): {
  startTimeError: string | null;
  endTimeError: string | null;
} {
  if (!startTime || !endTime) {
    return {
      startTimeError: null,
      endTimeError: null,
    };
  }
  
  if (startTime >= endTime) {
    return {
      startTimeError: '시작 시간은 종료 시간보다 빨라야 합니다.',
      endTimeError: '종료 시간은 시작 시간보다 늦어야 합니다.',
    };
  }
  
  return {
    startTimeError: null,
    endTimeError: null,
  };
}
```

---

위의 구현은 TDD의 GREEN 단계에 충실하게 작성되었습니다:

- **테스트를 통과시키는 최소한의 코드**만 작성
- **하드코딩된 값**이나 간단한 로직 사용
- **리팩토링은 다음 단계**에서 수행

각 함수는 테스트 케이스를 통과하기 위한 가장 단순한 구현을 제공하며, 추후 리팩토링 단계에서 코드를 개선할 수 있습니다.
