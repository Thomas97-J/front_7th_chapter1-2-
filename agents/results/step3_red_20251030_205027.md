```typescript
// filepath: src/__tests__/unit/scheduleRecurringRule.spec.ts

import { describe, it, expect } from 'vitest';
import { scheduleRecurringRule } from '../../utils/scheduleRecurringRule';

describe('Schedule Recurring Rule', () => {
  describe('Daily Recurrence', () => {
    it('should generate next day when recurring daily', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'daily' as const,
        count: 1
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-02-01']);
    });

    it('should generate multiple consecutive days when recurring daily', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'daily' as const,
        count: 3
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
    });

    it('should handle month boundary correctly when recurring daily', () => {
      // Arrange
      const options = {
        startDate: '2024-01-30',
        recurrenceType: 'daily' as const,
        count: 5
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual([
        '2024-01-31',
        '2024-02-01',
        '2024-02-02',
        '2024-02-03',
        '2024-02-04'
      ]);
    });
  });

  describe('Weekly Recurrence', () => {
    it('should generate same weekday when recurring weekly', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'weekly' as const,
        count: 1
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-02-07']);
    });

    it('should generate multiple weeks with same weekday when recurring weekly', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'weekly' as const,
        count: 3
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-02-07', '2024-02-14', '2024-02-21']);
    });

    it('should preserve weekday across month boundaries when recurring weekly', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'weekly' as const,
        count: 5
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual([
        '2024-02-07',
        '2024-02-14',
        '2024-02-21',
        '2024-02-28',
        '2024-03-06'
      ]);
      
      result.forEach(date => {
        const dayOfWeek = new Date(date).getDay();
        expect(dayOfWeek).toBe(3); // Wednesday
      });
    });
  });

  describe('Monthly Recurrence', () => {
    it('should skip February when starting on 31st and recurring monthly', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'monthly' as const,
        count: 1
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-03-31']);
    });

    it('should only generate on 31st when recurring monthly from 31st', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'monthly' as const,
        count: 2
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-03-31', '2024-05-31']);
    });

    it('should generate all months when starting from a day that exists in all months', () => {
      // Arrange
      const options = {
        startDate: '2024-01-15',
        recurrenceType: 'monthly' as const,
        count: 3
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-02-15', '2024-03-15', '2024-04-15']);
    });

    it('should handle 30th correctly when recurring monthly', () => {
      // Arrange
      const options = {
        startDate: '2024-01-30',
        recurrenceType: 'monthly' as const,
        count: 3
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-03-30', '2024-04-30', '2024-05-30']);
    });

    it('should handle year boundary when recurring monthly', () => {
      // Arrange
      const options = {
        startDate: '2024-11-15',
        recurrenceType: 'monthly' as const,
        count: 3
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-12-15', '2025-01-15', '2025-02-15']);
    });
  });

  describe('Yearly Recurrence', () => {
    it('should skip non-leap years when starting from Feb 29th and recurring yearly', () => {
      // Arrange
      const options = {
        startDate: '2024-02-29',
        recurrenceType: 'yearly' as const,
        count: 1
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2028-02-29']);
    });

    it('should generate only leap years when starting from Feb 29th and recurring yearly', () => {
      // Arrange
      const options = {
        startDate: '2024-02-29',
        recurrenceType: 'yearly' as const,
        count: 2
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29']);
    });

    it('should generate every year when starting from a regular date and recurring yearly', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'yearly' as const,
        count: 3
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2025-01-31', '2026-01-31', '2027-01-31']);
    });

    it('should handle century leap year rule correctly when recurring yearly', () => {
      // Arrange
      const options = {
        startDate: '2096-02-29',
        recurrenceType: 'yearly' as const,
        count: 2
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2104-02-29', '2108-02-29']);
    });
  });

  describe('Edge Cases & Validation', () => {
    it('should return empty array when count is 0', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'daily' as const,
        count: 0
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual([]);
    });

    it('should handle negative count gracefully', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'daily' as const,
        count: -1
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual([]);
    });

    it('should handle invalid date format', () => {
      // Arrange
      const options = {
        startDate: 'invalid-date',
        recurrenceType: 'daily' as const,
        count: 1
      };

      // Act & Assert
      expect(() => scheduleRecurringRule(options)).toThrow();
    });

    it('should handle invalid recurrence type', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'invalid-type' as any,
        count: 1
      };

      // Act & Assert
      expect(() => scheduleRecurringRule(options)).toThrow();
    });

    it('should allow duplicate dates (no overlap check)', () => {
      // Arrange
      const options = {
        startDate: '2024-01-31',
        recurrenceType: 'daily' as const,
        count: 3
      };

      // Act
      const result = scheduleRecurringRule(options);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
      expect(result.length).toBe(3);
    });
  });
});
```
