프로젝트 구조를 파악했습니다. 이제 날짜 범위 검증 함수에 대한 포괄적인 테스트 케이스를 설계하겠습니다.

---

# 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

## 개요
`validateDateRange` 함수는 시작일과 종료일을 입력받아 날짜 범위의 유효성을 검증합니다. Date 객체와 ISO 8601 문자열 형식을 모두 지원하며, 다양한 엣지 케이스를 처리합니다.

---

## Unit Tests: 기본 동작

### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 2025-01-01이고 종료일이 2025-01-10인 Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 2025-01-01인 Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 2025-01-10이고 종료일이 2025-01-01인 Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }`를 반환한다

---

## Unit Tests: ISO 8601 문자열 입력

### 테스트 케이스 4
- **이름**: should handle ISO 8601 string format for valid date range
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 "2025-01-01"이고 종료일이 "2025-01-10"인 ISO 8601 문자열
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 5
- **이름**: should handle ISO 8601 string format with time information
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 "2025-01-01T09:00:00Z"이고 종료일이 "2025-01-01T17:00:00Z"인 ISO 8601 문자열
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 6
- **이름**: should handle mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 Date 객체이고 종료일이 ISO 8601 문자열인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다 (유효한 범위인 경우)

---

## Unit Tests: 에러 처리

### 테스트 케이스 7
- **이름**: should return error when startDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null이고 종료일이 유효한 Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환한다

### 테스트 케이스 8
- **이름**: should return error when endDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 유효한 Date 객체이고 종료일이 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환한다

### 테스트 케이스 9
- **이름**: should return error when startDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined이고 종료일이 유효한 Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환한다

### 테스트 케이스 10
- **이름**: should return error when endDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 유효한 Date 객체이고 종료일이 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환한다

### 테스트 케이스 11
- **이름**: should return error when both dates are null
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일과 종료일이 모두 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일과 종료일은 필수입니다' }`를 반환한다

### 테스트 케이스 12
- **이름**: should return error for invalid date string format
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 "invalid-date"인 잘못된 문자열
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 날짜 형식입니다' }`를 반환한다

### 테스트 케이스 13
- **이름**: should return error for malformed ISO 8601 string
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 "2025/01/01"인 잘못된 구분자를 사용한 문자열
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 날짜 형식입니다' }`를 반환한다

### 테스트 케이스 14
- **이름**: should return error for Invalid Date object
- **타입**: unit
- **우선순위**: high
- **Given**: new Date("invalid")로 생성된 Invalid Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 날짜입니다' }`를 반환한다

---

## Edge Cases: 경계값 테스트

### 테스트 케이스 15
- **이름**: should return valid for same date with different time zones
- **타입**: edge
- **우선순위**: medium
- **Given**: 동일한 날짜이지만 다른 타임존을 가진 두 날짜 ("2025-01-01T00:00:00+09:00", "2025-01-01T00:00:00Z")
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다 (날짜 부분만 비교)

### 테스트 케이스 16
- **이름**: should return valid for 1 day difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 2025-01-01이고 종료일이 2025-01-02
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 17
- **이름**: should return valid with warning for 100+ years difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 1900-01-01이고 종료일이 2025-01-01 (125년 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환한다

### 테스트 케이스 18
- **이름**: should handle leap year date (Feb 29)
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 2024-02-29이고 종료일이 2024-03-01 (윤년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 19
- **이름**: should return error for Feb 29 in non-leap year
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 "2025-02-29"인 문자열 (평년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 날짜입니다' }`를 반환한다

### 테스트 케이스 20
- **이름**: should handle year boundary crossing (year-end to new year)
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 2024-12-31이고 종료일이 2025-01-01
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 21
- **이름**: should handle minimum JavaScript date
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 new Date(-8640000000000000) (JavaScript 최소 날짜)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 유효한 날짜로 처리하거나 적절한 에러를 반환한다

### 테스트 케이스 22
- **이름**: should handle maximum JavaScript date
- **타입**: edge
- **우선순위**: low
- **Given**: 종료일이 new Date(8640000000000000) (JavaScript 최대 날짜)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 유효한 날짜로 처리하거나 적절한 에러를 반환한다

### 테스트 케이스 23
- **이름**: should handle midnight edge case
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 "2025-01-01T00:00:00"이고 종료일이 "2025-01-01T23:59:59"
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 24
- **이름**: should handle month boundary (Jan 31 to Feb 1)
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 2025-01-31이고 종료일이 2025-02-01
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

---

## Integration Tests: 실제 사용 시나리오

### 테스트 케이스 25
- **이름**: should validate event date range in calendar application
- **타입**: integration
- **우선순위**: high
- **Given**: 이벤트 객체가 startDate와 endDate 속성을 가지고 있음
- **When**: 이벤트 생성 시 validateDateRange로 날짜를 검증할 때
- **Then**: 유효한 이벤트만 저장되고 무효한 이벤트는 에러 메시지를 표시한다

### 테스트 케이스 26
- **이름**: should work with form validation in React component
- **타입**: integration
- **우선순위**: high
- **Given**: React 폼에서 사용자가 시작일과 종료일을 입력
- **When**: 폼 제출 시 validateDateRange로 검증할 때
- **Then**: 검증 결과에 따라 적절한 UI 피드백을 제공한다

### 테스트 케이스 27
- **이름**: should handle consecutive validation calls with different inputs
- **타입**: integration
- **우선순위**: medium
- **Given**: 여러 이벤트에 대해 연속적으로 검증을 수행
- **When**: validateDateRange를 여러 번 호출할 때
- **Then**: 각 호출은 독립적으로 정확한 결과를 반환한다

---

## 성능 및 추가 테스트

### 테스트 케이스 28
- **이름**: should handle empty string inputs
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 또는 종료일이 빈 문자열("")
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '날짜는 필수입니다' }`를 반환한다

### 테스트 케이스 29
- **이름**: should handle whitespace-only string inputs
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 또는 종료일이 공백 문자열("   ")
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 날짜 형식입니다' }`를 반환한다

### 테스트 케이스 30
- **이름**: should handle date with milliseconds precision
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 "2025-01-01T12:00:00.123Z"이고 종료일이 "2025-01-01T12:00:00.456Z"
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다 (날짜 부분만 비교하는 경우)

---

## 추천 테스트 파일 구조

```typescript
// src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/dateValidation';

describe('validateDateRange', () => {
  describe('기본 동작', () => {
    // 테스트 케이스 1-3
  });

  describe('ISO 8601 문자열 입력', () => {
    // 테스트 케이스 4-6
  });

  describe('에러 처리', () => {
    // 테스트 케이스 7-14
  });

  describe('경계값 테스트', () => {
    // 테스트 케이스 15-24, 28-30
  });

  describe('통합 테스트', () => {
    // 테스트 케이스 25-27
  });
});
```

---

## 테스트 실행 우선순위

1. **High Priority (먼저 구현)**: 테스트 케이스 1-3, 4, 7-10, 12-14, 25-26
2. **Medium Priority (다음 구현)**: 테스트 케이스 5-6, 11, 15-20, 24, 27-28
3. **Low Priority (마지막 구현)**: 테스트 케이스 21-22, 29-30

---

이 테스트 스위트는 총 30개의 테스트 케이스로 구성되어 있으며, AAA 패턴을 따르고 있습니다. 각 테스트는 독립적으로 실행 가능하며, 명확한 의도를 가지고 있습니다. 프로젝트의 Vitest 프레임워크와 기존 테스트 패턴을 따르도록 설계되었습니다.
