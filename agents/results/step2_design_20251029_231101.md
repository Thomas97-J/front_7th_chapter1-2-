제공하신 명세를 바탕으로 포괄적인 테스트 케이스를 설계하겠습니다.

---

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: should return isValid true when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 '2024-01-31'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 2
- **이름**: should return isValid true when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate와 endDate가 모두 '2024-01-01'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 3
- **이름**: should return isValid false with error when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-31', endDate는 '2024-01-01'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후일 수 없습니다' }` 반환

### Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 `new Date('2024-01-01')`, endDate는 `new Date('2024-01-31')`
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01T00:00:00Z', endDate는 '2024-01-31T23:59:59Z'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 6
- **이름**: should accept mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate는 `new Date('2024-01-01')`, endDate는 '2024-01-31'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

### Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: should return error when startDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 null, endDate는 '2024-01-31'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 8
- **이름**: should return error when endDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 null
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '종료일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 9
- **이름**: should return error when startDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 undefined, endDate는 '2024-01-31'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 10
- **이름**: should return error when endDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 undefined
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '종료일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 11
- **이름**: should return error when both dates are null
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate와 endDate가 모두 null
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 12
- **이름**: should return error for invalid date string format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 'invalid-date', endDate는 '2024-01-31'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '잘못된 날짜 형식입니다' }` 반환

#### 테스트 케이스 13
- **이름**: should return error for malformed ISO string
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate는 '2024-13-01' (잘못된 월), endDate는 '2024-01-31'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '잘못된 날짜 형식입니다' }` 반환

#### 테스트 케이스 14
- **이름**: should return error for invalid Date object (Invalid Date)
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate는 `new Date('invalid')`, endDate는 '2024-01-31'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '잘못된 날짜 형식입니다' }` 반환

### Edge Cases - 경계값 테스트

#### 테스트 케이스 15
- **이름**: should return isValid true for dates with 1 day difference
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2024-01-01', endDate는 '2024-01-02'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 16
- **이름**: should return isValid true with warning for dates with 100+ years difference
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '1900-01-01', endDate는 '2024-01-01'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 17
- **이름**: should handle dates at year boundaries
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2023-12-31', endDate는 '2024-01-01'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 18
- **이름**: should handle leap year dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2024-02-29', endDate는 '2024-03-01' (2024는 윤년)
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 19
- **이름**: should handle dates with time components (same day, different times)
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2024-01-01T08:00:00Z', endDate는 '2024-01-01T17:00:00Z'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 20
- **이름**: should handle very distant past dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '1000-01-01', endDate는 '2024-01-01'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 21
- **이름**: should handle very distant future dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2024-01-01', endDate는 '3024-01-01'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 22
- **이름**: should handle minimum valid date difference (1 millisecond)
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2024-01-01T00:00:00.000Z', endDate는 '2024-01-01T00:00:00.001Z'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

### Edge Cases - 타임존 처리

#### 테스트 케이스 23
- **이름**: should handle dates with different timezone offsets
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2024-01-01T00:00:00+09:00', endDate는 '2024-01-01T00:00:00Z'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후일 수 없습니다' }` 반환 (UTC 기준으로 시작일이 더 늦음)

#### 테스트 케이스 24
- **이름**: should normalize dates without timezone to UTC
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2024-01-01', endDate는 '2024-01-02'
- **When**: validateDateRange를 호출
- **Then**: `{ isValid: true }` 반환

### Integration Tests

#### 테스트 케이스 25
- **이름**: should work correctly when called multiple times with different inputs
- **타입**: integration
- **우선순위**: medium
- **Given**: 여러 다른 날짜 쌍을 순차적으로 입력
- **When**: validateDateRange를 여러 번 호출
- **Then**: 각 호출이 독립적으로 올바른 결과를 반환

#### 테스트 케이스 26
- **이름**: should not mutate input Date objects
- **타입**: integration
- **우선순위**: medium
- **Given**: Date 객체 2개를 생성하고 원본 값을 저장
- **When**: validateDateRange를 호출
- **Then**: 입력 Date 객체들이 변경되지 않음

---

## 테스트 구현 가이드

### 테스트 파일 구조
```
src/__tests__/
  └── validateDateRange.test.ts
```

### 우선순위별 구현 순서
1. **High 우선순위**: 핵심 기능과 에러 처리 (테스트 1-14)
2. **Medium 우선순위**: 엣지 케이스와 통합 테스트 (테스트 15-26)
3. **Low 우선순위**: 세부 경계값 테스트

### 테스트 데이터 헬퍼 함수 권장
- `createValidDatePair()`: 유효한 날짜 쌍 생성
- `createInvalidDatePair()`: 무효한 날짜 쌍 생성
- `createEdgeCaseDates()`: 경계값 날짜 생성

이 테스트 설계가 도움이 되시나요? 실제 구현 코드를 작성해드릴까요?
