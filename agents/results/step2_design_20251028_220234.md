테스트 설계를 시작하겠습니다. 날짜 범위 검증 함수의 명세를 바탕으로 체계적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### 1. 기본 동작 테스트

#### 테스트 케이스 1.1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 '2024-01-01'이고 종료일이 '2024-01-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 1.2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 1.3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 '2024-01-31'이고 종료일이 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Start date must be before or equal to end date' }`를 반환해야 함

### 2. 입력 형식 테스트

#### 테스트 케이스 2.1
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 생성된 시작일과 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 검증하고 `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 2.2
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 형식 문자열 '2024-01-01T00:00:00.000Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 파싱하고 `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 2.3
- **이름**: should accept mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 ISO 8601 문자열
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 검증하고 `{ isValid: true }`를 반환해야 함

### 3. 에러 처리 테스트

#### 테스트 케이스 3.1
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Start date is required' }`를 반환해야 함

#### 테스트 케이스 3.2
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 undefined인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'End date is required' }`를 반환해야 함

#### 테스트 케이스 3.3
- **이름**: should return error when start date is invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 'invalid-date' 문자열인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Invalid start date format' }`를 반환해야 함

#### 테스트 케이스 3.4
- **이름**: should return error when end date is invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 'not-a-date' 문자열인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Invalid end date format' }`를 반환해야 함

#### 테스트 케이스 3.5
- **이름**: should return error when both dates are null
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일과 종료일이 모두 null인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Start date is required' }`를 반환해야 함

### 4. 엣지 케이스 테스트

#### 테스트 케이스 4.1
- **이름**: should return valid for same date at different times
- **타입**: edge
- **우선순위**: medium
- **Given**: 같은 날짜지만 다른 시간 (2024-01-01T10:00:00 vs 2024-01-01T15:00:00)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.2
- **이름**: should return valid for one day difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-01-01'이고 종료일이 '2024-01-02'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.3
- **이름**: should return valid with warning for 100+ years difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '1900-01-01'이고 종료일이 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: 'Date range exceeds 100 years' }`를 반환해야 함

#### 테스트 케이스 4.4
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2024-02-29' (윤년)인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 처리하고 `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.5
- **이름**: should handle year boundary correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2023-12-31'이고 종료일이 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.6
- **이름**: should handle very old dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '1900-01-01'이고 종료일이 '1900-12-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.7
- **이름**: should handle future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2100-01-01'이고 종료일이 '2100-12-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 4.8
- **이름**: should handle dates with milliseconds
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2024-01-01T00:00:00.000Z'이고 종료일이 '2024-01-01T00:00:00.001Z'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

### 5. 타임존 처리 테스트

#### 테스트 케이스 5.1
- **이름**: should handle different timezone formats correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-01-01T00:00:00+09:00'이고 종료일이 '2024-01-01T00:00:00Z'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 타임존을 고려하여 올바르게 검증해야 함

#### 테스트 케이스 5.2
- **이름**: should handle daylight saving time transitions
- **타입**: edge
- **우선순위**: low
- **Given**: 서머타임 전환 시점의 날짜들
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 처리하고 `{ isValid: true }`를 반환해야 함

### 6. 성능 테스트

#### 테스트 케이스 6.1
- **이름**: should validate dates within acceptable time limit
- **타입**: unit
- **우선순위**: low
- **Given**: 유효한 날짜 범위
- **When**: validateDateRange 함수를 1000번 반복 호출할 때
- **Then**: 전체 실행 시간이 100ms 이하여야 함

### 7. 통합 테스트

#### 테스트 케이스 7.1
- **이름**: should work with date picker component
- **타입**: integration
- **우선순위**: high
- **Given**: React 컴포넌트에서 날짜 선택 시
- **When**: 사용자가 시작일과 종료일을 선택하고 validateDateRange가 호출될 때
- **Then**: UI에 적절한 검증 메시지가 표시되어야 함

#### 테스트 케이스 7.2
- **이름**: should integrate with form validation
- **타입**: integration
- **우선순위**: medium
- **Given**: 폼 제출 시 날짜 검증이 필요한 경우
- **When**: validateDateRange 함수가 폼 검증 체인의 일부로 호출될 때
- **Then**: 검증 결과가 올바르게 폼 상태에 반영되어야 함

---

## 테스트 구현 우선순위

### Phase 1 (High Priority)
- 기본 동작 테스트 (1.1, 1.2, 1.3)
- 입력 형식 테스트 (2.1, 2.2)
- 필수 에러 처리 (3.1, 3.2, 3.3, 3.4)
- 통합 테스트 (7.1)

### Phase 2 (Medium Priority)
- 혼합 입력 테스트 (2.3)
- 추가 에러 처리 (3.5)
- 주요 엣지 케이스 (4.1, 4.2, 4.3, 4.5)
- 타임존 처리 (5.1)
- 폼 통합 (7.2)

### Phase 3 (Low Priority)
- 나머지 엣지 케이스 (4.4, 4.6, 4.7, 4.8)
- 타임존 엣지 케이스 (5.2)
- 성능 테스트 (6.1)

---

## 예상 테스트 커버리지

- **Statements**: 95%+
- **Branches**: 90%+
- **Functions**: 100%
- **Lines**: 95%+

이 테스트 설계는 명세의 모든 요구사항을 커버하며, AAA 패턴을 따르고 테스트 독립성을 보장합니다. 각 테스트는 명확한 의도를 가지고 있으며, 경계값 테스트를 포함하고 있습니다.
