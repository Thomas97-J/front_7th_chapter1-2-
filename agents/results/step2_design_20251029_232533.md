기존 구현을 확인했습니다. 이제 체계적인 테스트 케이스를 설계하겠습니다.

---

## 테스트 스위트: validateDateRange

### 📋 Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: `should return valid when start date is before end date`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-01-01', 종료일 '2024-12-31'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 2
- **이름**: `should return valid when start date equals end date`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 같은 날짜 '2024-01-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 3
- **이름**: `should return invalid when start date is after end date`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-12-31', 종료일 '2024-01-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }` 반환

---

### 📋 Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: `should accept Date objects as input`
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 생성된 시작일과 종료일
- **When**: validateDateRange 함수 호출
- **Then**: 정상적으로 처리되고 `{ isValid: true }` 반환

#### 테스트 케이스 5
- **이름**: `should accept ISO 8601 strings as input`
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 형식 문자열 '2024-01-01T00:00:00.000Z'
- **When**: validateDateRange 함수 호출
- **Then**: 정상적으로 처리되고 `{ isValid: true }` 반환

#### 테스트 케이스 6
- **이름**: `should accept mixed input types (Date and string)`
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 문자열
- **When**: validateDateRange 함수 호출
- **Then**: 정상적으로 처리되고 `{ isValid: true }` 반환

---

### 📋 Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: `should return error when startDate is null`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 null, endDate는 유효한 날짜
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 8
- **이름**: `should return error when endDate is null`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜, endDate가 null
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }` 반환

#### 테스트 케이스 9
- **이름**: `should return error when both dates are null`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate와 endDate가 모두 null
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일과 종료일은 필수입니다' }` 반환

#### 테스트 케이스 10
- **이름**: `should return error when startDate is undefined`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 undefined, endDate는 유효한 날짜
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 11
- **이름**: `should return error when endDate is undefined`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜, endDate가 undefined
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }` 반환

#### 테스트 케이스 12
- **이름**: `should return error when both dates are undefined`
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate와 endDate가 모두 undefined
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일과 종료일은 필수입니다' }` 반환

#### 테스트 케이스 13
- **이름**: `should return error when startDate is invalid string`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 'invalid-date', endDate는 유효한 날짜
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 14
- **이름**: `should return error when endDate is invalid string`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜, endDate가 'not-a-date'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 15
- **이름**: `should return error when startDate is invalid Date object`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 `new Date('invalid')`, endDate는 유효한 날짜
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 16
- **이름**: `should return error when endDate is invalid Date object`
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜, endDate가 `new Date('invalid')`
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다' }` 반환

---

### 📋 Edge Cases - 경계값

#### 테스트 케이스 17
- **이름**: `should return valid when dates are 1 day apart`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-01-01', 종료일 '2024-01-02'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 18
- **이름**: `should return valid with warning when dates are 100 years apart`
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일 '1924-01-01', 종료일 '2024-01-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년 이상입니다' }` 반환

#### 테스트 케이스 19
- **이름**: `should return valid with warning when dates are more than 100 years apart`
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일 '1900-01-01', 종료일 '2024-01-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년 이상입니다' }` 반환

#### 테스트 케이스 20
- **이름**: `should return valid when dates are exactly 99 years apart`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '1925-01-01', 종료일 '2024-01-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환 (경고 없음)

#### 테스트 케이스 21
- **이름**: `should handle dates at the boundary of valid Date range`
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '1970-01-01' (Unix epoch), 종료일 현재 날짜
- **When**: validateDateRange 함수 호출
- **Then**: 정상적으로 처리됨

#### 테스트 케이스 22
- **이름**: `should handle leap year dates correctly`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-02-29' (윤년), 종료일 '2024-03-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 23
- **이름**: `should handle dates with time components`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-01-01T23:59:59.999Z', 종료일 '2024-01-02T00:00:00.000Z'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 24
- **이름**: `should handle same date with different times (end time earlier)`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-01-01T10:00:00Z', 종료일 '2024-01-01T09:00:00Z'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }` 반환

---

### 📋 Integration Tests - 실제 사용 시나리오

#### 테스트 케이스 25
- **이름**: `should validate date range for hotel booking scenario`
- **타입**: integration
- **우선순위**: medium
- **Given**: 체크인 날짜와 체크아웃 날짜
- **When**: 예약 시스템에서 validateDateRange 호출
- **Then**: 유효한 예약 기간으로 확인됨

#### 테스트 케이스 26
- **이름**: `should validate date range for event scheduling`
- **타입**: integration
- **우선순위**: medium
- **Given**: 이벤트 시작일과 종료일
- **When**: 스케줄 시스템에서 validateDateRange 호출
- **Then**: 유효한 이벤트 기간으로 확인됨

---

### 📊 테스트 커버리지 요약

| 카테고리 | 테스트 케이스 수 | 우선순위 분포 |
|---------|--------------|------------|
| 기본 동작 | 3 | High: 3 |
| 입력 형식 | 3 | High: 2, Medium: 1 |
| 에러 처리 | 10 | High: 9, Medium: 1 |
| 경계값 | 8 | High: 3, Medium: 4, Low: 1 |
| 통합 테스트 | 2 | Medium: 2 |
| **총계** | **26** | **High: 17, Medium: 8, Low: 1** |

---

이 테스트 설계를 실제 테스트 코드로 구현하시겠습니까? Vitest를 사용하여 `src/__tests__/validateDateRange.test.ts` 파일을 생성해드릴 수 있습니다.
