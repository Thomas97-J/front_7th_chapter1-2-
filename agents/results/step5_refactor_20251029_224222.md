## Step 1: List improvements (brief)

- Extract duplicate error messages to constants (DRY)
- Consolidate date parsing and validation logic
- Remove redundant null/Date checks after parsing
- Extract magic number (100 years) to constant
- Simplify error message structure (avoid repetition)
- Add comprehensive JSDoc documentation
- Create reusable helper functions for error/warning results

## Step 2: Complete refactored code

```typescript
// filepath: src/utils/validateDateRange.ts

/**
 * Validation result interface
 */
export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

/**
 * Error message constants
 */
const ERROR_MESSAGES = {
  BOTH_REQUIRED: '시작일과 종료일은 필수입니다',
  START_REQUIRED: '시작일은 필수입니다',
  END_REQUIRED: '종료일은 필수입니다',
  INVALID_DATE_FORMAT: '형식이 올바르지 않습니다',
  START_AFTER_END: '시작일은 종료일보다 이전이어야 합니다',
} as const;

/**
 * Warning thresholds
 */
const WARNING_THRESHOLD = {
  MAX_YEARS: 100,
} as const;

/**
 * Constants for date calculations
 */
const MILLISECONDS_PER_YEAR = 365.25 * 24 * 60 * 60 * 1000;

/**
 * Validates a date range to ensure start date is before or equal to end date
 * 
 * @param startDate - Start date (Date object or ISO 8601 string)
 * @param endDate - End date (Date object or ISO 8601 string)
 * @returns Validation result with error or warning if applicable
 * 
 * @example
 * ```typescript
 * validateDateRange('2024-01-01', '2024-12-31')
 * // Returns: { isValid: true }
 * 
 * validateDateRange('2024-12-31', '2024-01-01')
 * // Returns: { isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }
 * ```
 */
export function validateDateRange(
  startDate: Date | string | null | undefined,
  endDate: Date | string | null | undefined
): ValidationResult {
  // Check for null/undefined inputs
  const nullCheckResult = checkForNullInputs(startDate, endDate);
  if (nullCheckResult) {
    return nullCheckResult;
  }

  // Parse and validate dates
  const parsedStart = parseAndValidateDate(startDate!);
  const parsedEnd = parseAndValidateDate(endDate!);

  if (!parsedStart) {
    return createError(`시작일 ${ERROR_MESSAGES.INVALID_DATE_FORMAT}`);
  }

  if (!parsedEnd) {
    return createError(`종료일 ${ERROR_MESSAGES.INVALID_DATE_FORMAT}`);
  }

  // Compare dates
  if (parsedStart.getTime() > parsedEnd.getTime()) {
    return createError(ERROR_MESSAGES.START_AFTER_END);
  }

  // Check for long date range warning
  const yearsDifference = calculateYearsDifference(parsedStart, parsedEnd);
  if (yearsDifference > WARNING_THRESHOLD.MAX_YEARS) {
    return createWarning(`날짜 범위가 ${WARNING_THRESHOLD.MAX_YEARS}년을 초과합니다`);
  }

  return { isValid: true };
}

/**
 * Checks if start or end dates are null/undefined
 * 
 * @param startDate - Start date to check
 * @param endDate - End date to check
 * @returns ValidationResult if there's an error, null otherwise
 */
function checkForNullInputs(
  startDate: Date | string | null | undefined,
  endDate: Date | string | null | undefined
): ValidationResult | null {
  if (!startDate && !endDate) {
    return createError(ERROR_MESSAGES.BOTH_REQUIRED);
  }

  if (!startDate) {
    return createError(ERROR_MESSAGES.START_REQUIRED);
  }

  if (!endDate) {
    return createError(ERROR_MESSAGES.END_REQUIRED);
  }

  return null;
}

/**
 * Parses and validates a date input
 * 
 * @param date - Date object or string to parse
 * @returns Valid Date object or null if invalid
 */
function parseAndValidateDate(date: Date | string): Date | null {
  const parsed = parseDate(date);
  return parsed && isValidDate(parsed) ? parsed : null;
}

/**
 * Parses a date from string or Date object
 * 
 * @param date - Date to parse
 * @returns Date object or null if parsing fails
 */
function parseDate(date: Date | string): Date | null {
  if (date instanceof Date) {
    return date;
  }

  if (typeof date === 'string') {
    return new Date(date);
  }

  return null;
}

/**
 * Checks if a date is valid
 * 
 * @param date - Date to validate
 * @returns true if date is valid, false otherwise
 */
function isValidDate(date: Date): boolean {
  return date instanceof Date && !isNaN(date.getTime());
}

/**
 * Calculates the difference in years between two dates
 * 
 * @param startDate - Start date
 * @param endDate - End date
 * @returns Number of years between dates
 */
function calculateYearsDifference(startDate: Date, endDate: Date): number {
  return (endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_YEAR;
}

/**
 * Creates an error validation result
 * 
 * @param message - Error message
 * @returns ValidationResult with error
 */
function createError(message: string): ValidationResult {
  return {
    isValid: false,
    error: message,
  };
}

/**
 * Creates a warning validation result
 * 
 * @param message - Warning message
 * @returns ValidationResult with warning
 */
function createWarning(message: string): ValidationResult {
  return {
    isValid: true,
    warning: message,
  };
}
```
