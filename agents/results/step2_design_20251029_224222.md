명세를 분석하여 체계적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 종료일보다 이른 두 개의 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 동일한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 종료일보다 늦은 두 개의 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이후일 수 없습니다' }`를 반환해야 함

### Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체 형태의 시작일과 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되고 올바른 결과를 반환해야 함

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 문자열 형태의 시작일과 종료일 (예: '2024-01-15')
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되고 올바른 결과를 반환해야 함

#### 테스트 케이스 6
- **이름**: should accept mixed input types (Date and ISO string)
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 ISO 문자열 (또는 반대)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되고 올바른 결과를 반환해야 함

### Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null이고 종료일은 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 8
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일은 유효하고 종료일이 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 9
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined이고 종료일은 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 10
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일은 유효하고 종료일이 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 11
- **이름**: should return error when start date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 잘못된 날짜 문자열 (예: 'invalid-date', '2024-13-45')
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 12
- **이름**: should return error when end date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일은 유효하고 종료일이 잘못된 형식
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 13
- **이름**: should return error when date string is empty
- **타입**: unit
- **우선순위**: medium
- **Given**: 빈 문자열('')을 날짜로 전달
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '[시작일/종료일] 형식이 올바르지 않습니다' }`를 반환해야 함

### Edge Cases - 경계값

#### 테스트 케이스 14
- **이름**: should return valid when dates differ by exactly 1 day
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일과 종료일이 정확히 1일 차이
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates differ by more than 100 years
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일과 종료일이 100년 이상 차이 (예: 1900-01-01 ~ 2024-01-01)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환해야 함

#### 테스트 케이스 16
- **이름**: should return valid when dates differ by exactly 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일과 종료일이 정확히 100년 차이
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함 (경고 없음)

#### 테스트 케이스 17
- **이름**: should handle dates at year boundary (December 31 to January 1)
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 12월 31일, 종료일 다음 해 1월 1일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 18
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 윤년의 2월 29일을 포함하는 날짜 범위
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 처리되고 `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 19
- **이름**: should handle very old dates (historical dates)
- **타입**: edge
- **우선순위**: low
- **Given**: 매우 오래된 날짜 (예: 1900년 이전)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되어야 함

#### 테스트 케이스 20
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 먼 미래의 날짜 (예: 2100년 이후)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되어야 함

### Edge Cases - 시간대 및 정밀도

#### 테스트 케이스 21
- **이름**: should compare dates by day only, ignoring time
- **타입**: edge
- **우선순위**: high
- **Given**: 같은 날짜이지만 다른 시간 (예: 2024-01-01 09:00 vs 2024-01-01 23:59)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 같은 날짜로 간주하고 `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 22
- **이름**: should handle ISO strings with timezone information
- **타입**: edge
- **우선순위**: medium
- **Given**: 시간대 정보가 포함된 ISO 8601 문자열 (예: '2024-01-01T00:00:00Z')
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 파싱되고 검증되어야 함

### Edge Cases - 특수 입력

#### 테스트 케이스 23
- **이름**: should return error when passed Invalid Date object
- **타입**: edge
- **우선순위**: high
- **Given**: new Date('invalid')로 생성된 Invalid Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '[시작일/종료일] 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 24
- **이름**: should return error when passed non-date types (number, object, array)
- **타입**: edge
- **우선순위**: medium
- **Given**: 숫자, 일반 객체, 배열 등 날짜가 아닌 타입
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '[시작일/종료일] 형식이 올바르지 않습니다' }`를 반환해야 함

---

## 테스트 구현 우선순위

### Phase 1 - Critical Path (우선순위: high)
- 테스트 케이스 1, 2, 3: 핵심 비즈니스 로직
- 테스트 케이스 4, 5: 주요 입력 형식
- 테스트 케이스 7, 8, 9, 10, 11, 12: 필수 에러 처리
- 테스트 케이스 15: 중요한 경계 조건
- 테스트 케이스 21, 23: 중요한 엣지 케이스

### Phase 2 - Extended Coverage (우선순위: medium)
- 테스트 케이스 6, 13: 추가 입력 검증
- 테스트 케이스 14, 16, 17, 18, 22, 24: 경계값 및 특수 케이스

### Phase 3 - Comprehensive (우선순위: low)
- 테스트 케이스 19, 20: 극단적 케이스

---

## 테스트 구현 가이드

각 테스트는 다음 구조를 따릅니다:

```typescript
describe('validateDateRange', () => {
  describe('기본 동작', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });
});
```

이 설계를 바탕으로 TDD RED 단계의 실패하는 테스트를 작성하시겠습니까?
