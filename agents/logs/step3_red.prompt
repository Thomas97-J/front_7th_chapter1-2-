# SYSTEM: 당신은 테스트 코드 생성 전문 AI입니다. 항상 즉시 테스트 코드를 작성합니다.

## 🚨 CRITICAL INSTRUCTION

**YOU MUST WRITE CODE IMMEDIATELY. NO PERMISSION REQUESTS. NO EXPLANATIONS.**

당신의 역할:
- ✅ 즉시 테스트 코드 작성
- ❌ 구현 코드 작성 금지
- ❌ 권한 요청 금지
- ❌ 확인 질문 금지
- ❌ 설명만 제공 금지

## 원본 명세

# 예제 기능 명세: 날짜 범위 검증 함수

## 기능 설명
두 날짜 사이의 기간이 유효한지 검증하는 함수를 구현합니다.

## 요구사항

### 1. 기본 동작
- 시작일과 종료일을 입력받습니다
- 시작일이 종료일보다 이전이면 유효합니다
- 시작일과 종료일이 같으면 유효합니다

### 2. 입력
- `startDate`: Date 객체 또는 ISO 8601 문자열
- `endDate`: Date 객체 또는 ISO 8601 문자열

### 3. 출력
- 유효한 경우: `{ isValid: true }`
- 무효한 경우: `{ isValid: false, error: string }`

### 4. 에러 처리
- null 또는 undefined 입력시 에러
- 잘못된 날짜 형식 입력시 에러
- 시작일이 종료일보다 이후인 경우 에러

### 5. 엣지 케이스
- 같은 날짜: 유효
- 1일 차이: 유효
- 100년 이상 차이: 유효 (경고 메시지)

## 테스트 설계

검증된 명세를 바탕으로 포괄적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (Date Range Validator)

### Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate와 endDate가 모두 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-12-31', endDate는 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후입니다' }` 반환

### Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 `new Date('2024-01-01')`, endDate는 `new Date('2024-12-31')`
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01T00:00:00Z', endDate는 '2024-12-31T23:59:59Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 6
- **이름**: should accept mixed Date object and ISO string
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate는 `new Date('2024-01-01')`, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

### Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 null, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 8
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 9
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 undefined, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 10
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 11
- **이름**: should return error when start date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 'invalid-date', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 12
- **이름**: should return error when end date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 'not-a-date'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 13
- **이름**: should return error when both dates are invalid
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate는 null, endDate는 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환 (첫 번째 에러 우선)

### Edge Cases - 경계값

#### 테스트 케이스 14
- **이름**: should return valid when dates differ by exactly 1 day
- **타입**: edge
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 '2024-01-02'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates differ by over 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '1900-01-01', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 16
- **이름**: should return valid when dates are exactly 100 years apart
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '1924-01-01', endDate는 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환 (정확히 100년은 경고 없음)

#### 테스트 케이스 17
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2024-02-29', endDate는 '2024-03-01' (윤년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 18
- **이름**: should return error for invalid leap year date
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2023-02-29', endDate는 '2023-03-01' (평년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 19
- **이름**: should handle dates at year boundaries
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2023-12-31T23:59:59', endDate는 '2024-01-01T00:00:00'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 20
- **이름**: should handle very old dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '1900-01-01', endDate는 '1900-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 21
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2100-01-01', endDate는 '2100-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 22
- **이름**: should handle same date with different time zones
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2024-01-01T00:00:00+09:00', endDate는 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후입니다' }` 반환 (또는 UTC 기준으로 비교)

### Edge Cases - 특수 입력

#### 테스트 케이스 23
- **이름**: should handle empty string input
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 24
- **이름**: should handle numeric timestamp input
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 1704067200000 (timestamp), endDate는 1735689599000
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환 (명세에 명시되지 않은 형식)

#### 테스트 케이스 25
- **이름**: should handle Invalid Date object
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 `new Date('invalid')`, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

### Integration Tests

#### 테스트 케이스 26
- **이름**: should integrate with date picker component
- **타입**: integration
- **우선순위**: high
- **Given**: 사용자가 날짜 선택 컴포넌트에서 시작일과 종료일을 선택
- **When**: validateDateRange가 선택된 값으로 호출될 때
- **Then**: 컴포넌트에 검증 결과가 표시됨

#### 테스트 케이스 27
- **이름**: should integrate with form validation
- **타입**: integration
- **우선순위**: high
- **Given**: 폼에 날짜 범위 입력 필드가 있고 검증 로직이 연결됨
- **When**: 사용자가 잘못된 날짜 범위를 입력하고 제출할 때
- **Then**: 폼 제출이 차단되고 에러 메시지가 표시됨

#### 테스트 케이스 28
- **이름**: should handle sequential validation calls
- **타입**: integration
- **우선순위**: medium
- **Given**: 여러 날짜 범위를 순차적으로 검증해야 하는 상황
- **When**: validateDateRange가 여러 번 연속으로 호출될 때
- **Then**: 각 호출이 독립적으로 올바른 결과를 반환

---

## 테스트 구현 가이드

### 테스트 파일 구조
```
src/__tests__/
  ├── unit/
  │   ├── validateDateRange.test.ts
  │   └── dateParser.test.ts
  ├── integration/
  │   └── dateRangeForm.test.tsx
  └── edge-cases/
      └── dateRangeBoundaries.test.ts
```

### 우선순위별 실행 순서
1. **High 우선순위** (18개): 핵심 기능과 주요 에러 처리
2. **Medium 우선순위** (8개): 입력 형식 변형과 경계값
3. **Low 우선순위** (2개): 특수 케이스와 확장 기능

### 테스트 커버리지 목표
- 라인 커버리지: 100%
- 브랜치 커버리지: 100%
- 함수 커버리지: 100%

이 테스트 케이스 설계를 바탕으로 실제 테스트 코드를 작성하시겠습니까?

---

## TASK: Write Vitest Test Code

### Requirements:
- Vitest framework
- TypeScript
- AAA pattern
- 15+ test cases
- All edge cases
- Ready to run

### Output Format:

**START YOUR RESPONSE WITH CODE BLOCK. NO TEXT BEFORE CODE.**

```typescript
// filepath: src/__tests__/unit/[name].spec.ts

import { describe, it, expect } from 'vitest';
import { functionName } from '../../utils/fileName';

describe('Feature Name', () => {
  describe('Normal Cases', () => {
    it('should work with valid input', () => {
      // Arrange
      const input = 'test';
      
      // Act
      const result = functionName(input);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Cases', () => {
    it('should handle null', () => {
      // Arrange
      const input = null;
      
      // Act
      const result = functionName(input);
      
      // Assert
      expect(result.isValid).toBe(false);
    });
  });
});
```

### FORBIDDEN:
- ❌ "I need permission to..."
- ❌ "Please approve..."
- ❌ "..." or "existing code"

### MANDATORY:
- ✅ Start with ```typescript
- ✅ Include // filepath: comment
- ✅ Write complete code
- ✅ 15+ test cases

## 🚀 BEGIN NOW
