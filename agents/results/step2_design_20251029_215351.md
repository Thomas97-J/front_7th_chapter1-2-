명세를 확인했습니다. 날짜 범위 검증 함수에 대한 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: validateDateRange

### 1. 기본 동작 테스트

#### 테스트 케이스 1.1
- **이름**: should return isValid true when startDate is before endDate
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 '2024-01-01'이고 endDate가 '2024-12-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 를 반환해야 함

#### 테스트 케이스 1.2
- **이름**: should return isValid true when startDate equals endDate
- **타입**: unit
- **우선순위**: high
- **Given**: startDate와 endDate가 모두 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 를 반환해야 함

#### 테스트 케이스 1.3
- **이름**: should return isValid false when startDate is after endDate
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 '2024-12-31'이고 endDate가 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: string }` 을 반환해야 함

---

### 2. 입력 형식 테스트

#### 테스트 케이스 2.1
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate와 endDate가 Date 객체인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증을 수행해야 함

#### 테스트 케이스 2.2
- **이름**: should accept ISO 8601 string as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate와 endDate가 ISO 8601 문자열('2024-01-01T00:00:00Z')인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증을 수행해야 함

#### 테스트 케이스 2.3
- **이름**: should handle mixed input types (Date object and ISO string)
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate가 Date 객체이고 endDate가 ISO 8601 문자열인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증을 수행해야 함

---

### 3. 에러 처리 테스트

#### 테스트 케이스 3.1
- **이름**: should return error when startDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 null인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'startDate는 필수입니다' }` 형태의 에러를 반환해야 함

#### 테스트 케이스 3.2
- **이름**: should return error when endDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: endDate가 undefined인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'endDate는 필수입니다' }` 형태의 에러를 반환해야 함

#### 테스트 케이스 3.3
- **이름**: should return error when startDate is invalid date format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 'invalid-date' 문자열인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '잘못된 날짜 형식입니다' }` 형태의 에러를 반환해야 함

#### 테스트 케이스 3.4
- **이름**: should return error when endDate is invalid date format
- **타입**: unit
- **우선순위**: high
- **Given**: endDate가 'not-a-date' 문자열인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '잘못된 날짜 형식입니다' }` 형태의 에러를 반환해야 함

#### 테스트 케이스 3.5
- **이름**: should return error when both dates are null
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate와 endDate가 모두 null인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: string }` 형태의 에러를 반환해야 함

---

### 4. 엣지 케이스 테스트

#### 테스트 케이스 4.1
- **이름**: should return isValid true for same date
- **타입**: edge
- **우선순위**: high
- **Given**: startDate와 endDate가 완전히 동일한 시각('2024-01-01T12:00:00Z')인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 를 반환해야 함

#### 테스트 케이스 4.2
- **이름**: should return isValid true for 1 day difference
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate가 '2024-01-01'이고 endDate가 '2024-01-02'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 를 반환해야 함

#### 테스트 케이스 4.3
- **이름**: should return isValid true with warning for 100+ years difference
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate가 '1900-01-01'이고 endDate가 '2024-01-01'인 경우 (124년 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '100년 이상의 기간입니다' }` 를 반환해야 함

#### 테스트 케이스 4.4
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: low
- **Given**: startDate가 '2024-02-29'(윤년)이고 endDate가 '2024-03-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 를 반환해야 함

#### 테스트 케이스 4.5
- **이름**: should handle year boundary correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate가 '2023-12-31T23:59:59Z'이고 endDate가 '2024-01-01T00:00:00Z'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 를 반환해야 함

#### 테스트 케이스 4.6
- **이름**: should handle timezone differences in ISO strings
- **타입**: edge
- **우선순위**: low
- **Given**: startDate가 '2024-01-01T23:00:00+09:00'이고 endDate가 '2024-01-01T15:00:00+01:00'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정확한 UTC 시간으로 비교하여 검증해야 함

#### 테스트 케이스 4.7
- **이름**: should handle very distant future dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate가 '2024-01-01'이고 endDate가 '2999-12-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: string }` 를 반환해야 함

#### 테스트 케이스 4.8
- **이름**: should handle millisecond precision
- **타입**: edge
- **우선순위**: low
- **Given**: startDate가 '2024-01-01T12:00:00.000Z'이고 endDate가 '2024-01-01T12:00:00.001Z'인 경우 (1ms 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 를 반환해야 함

---

### 5. 통합 테스트

#### 테스트 케이스 5.1
- **이름**: should handle sequential validation calls independently
- **타입**: integration
- **우선순위**: medium
- **Given**: 여러 개의 서로 다른 날짜 범위가 주어진 경우
- **When**: validateDateRange 함수를 순차적으로 여러 번 호출할 때
- **Then**: 각 호출이 독립적으로 정확한 결과를 반환해야 함

#### 테스트 케이스 5.2
- **이름**: should work correctly with date parsing utilities
- **타입**: integration
- **우선순위**: low
- **Given**: 외부 날짜 파싱 라이브러리를 통해 생성된 Date 객체인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증을 수행해야 함

---

## 테스트 우선순위 요약

### High Priority (필수 테스트)
- 기본 동작: 이전/동일/이후 날짜 비교
- 입력 형식: Date 객체, ISO 8601 문자열
- 에러 처리: null/undefined, 잘못된 형식
- 엣지 케이스: 동일 날짜

### Medium Priority (중요 테스트)
- 혼합 입력 타입
- 1일 차이, 100년 이상 차이
- 연도 경계
- 독립성 테스트

### Low Priority (추가 테스트)
- 윤년, 타임존, 밀리초 정밀도
- 먼 미래 날짜
- 외부 라이브러리 통합

---

## 테스트 구현 예시 구조

```typescript
// src/__tests__/validateDateRange.test.ts
import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('기본 동작', () => {
    it('should return isValid true when startDate is before endDate', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
    
    // ... 추가 테스트
  });
  
  describe('에러 처리', () => {
    // ... 에러 케이스 테스트
  });
  
  describe('엣지 케이스', () => {
    // ... 엣지 케이스 테스트
  });
});
```

이 테스트 설계는 총 **23개의 테스트 케이스**를 포함하며, 명세의 모든 요구사항을 검증합니다.
