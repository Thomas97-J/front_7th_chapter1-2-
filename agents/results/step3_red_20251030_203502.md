```typescript
// filepath: src/__tests__/unit/scheduleRecurringRule.spec.ts

import { describe, it, expect } from 'vitest';
import { generateRecurringSchedule } from '../../utils/scheduleRecurringRule';

describe('Schedule Recurring Rule', () => {
  describe('매일 반복', () => {
    it('should generate next day schedule from 2024-01-31', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 1;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-01']);
    });

    it('should generate consecutive daily schedules', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
    });

    it('should handle month boundary correctly', () => {
      // Arrange
      const startDate = '2024-02-28';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-01', '2024-03-02']);
    });

    it('should handle year boundary correctly', () => {
      // Arrange
      const startDate = '2024-12-30';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-12-31', '2025-01-01', '2025-01-02']);
    });
  });

  describe('매주 반복', () => {
    it('should generate same weekday (Wednesday) from 2024-01-31', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'weekly';
      const count = 1;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-07']);
    });

    it('should generate consecutive weekly schedules on same weekday', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'weekly';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-07', '2024-02-14', '2024-02-21']);
    });

    it('should handle year boundary with weekly repeat', () => {
      // Arrange
      const startDate = '2024-12-25';
      const repeatType = 'weekly';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2025-01-01', '2025-01-08', '2025-01-15']);
    });

    it('should maintain weekday across months', () => {
      // Arrange
      const startDate = '2024-01-29';
      const repeatType = 'weekly';
      const count = 5;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-05', '2024-02-12', '2024-02-19', '2024-02-26', '2024-03-04']);
    });
  });

  describe('매월 반복', () => {
    it('should skip February when starting from 31st', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 2;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-31', '2024-05-31']);
    });

    it('should only generate on 31st day of months', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 5;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-31', '2024-05-31', '2024-07-31', '2024-08-31', '2024-10-31']);
    });

    it('should handle normal day monthly repeat', () => {
      // Arrange
      const startDate = '2024-01-15';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-15', '2024-03-15', '2024-04-15']);
    });

    it('should handle 30th day monthly repeat', () => {
      // Arrange
      const startDate = '2024-01-30';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-30', '2024-04-30', '2024-05-30']);
    });

    it('should handle 29th day in leap year', () => {
      // Arrange
      const startDate = '2024-01-29';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-29', '2024-04-29']);
    });
  });

  describe('매년 반복', () => {
    it('should generate only on leap years for Feb 29', () => {
      // Arrange
      const startDate = '2024-02-29';
      const repeatType = 'yearly';
      const count = 2;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29']);
    });

    it('should skip non-leap years for Feb 29', () => {
      // Arrange
      const startDate = '2024-02-29';
      const repeatType = 'yearly';
      const count = 5;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29', '2036-02-29', '2040-02-29', '2044-02-29']);
    });

    it('should handle normal date yearly repeat', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'yearly';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2025-01-31', '2026-01-31', '2027-01-31']);
    });

    it('should handle century year leap rule for Feb 29', () => {
      // Arrange
      const startDate = '2096-02-29';
      const repeatType = 'yearly';
      const count = 3;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2104-02-29', '2108-02-29', '2112-02-29']);
    });
  });

  describe('일정 겹침 무시', () => {
    it('should allow duplicate dates without checking conflicts', () => {
      // Arrange
      const startDate = '2024-01-15';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result1 = generateRecurringSchedule(startDate, repeatType, count);
      const result2 = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result1).toEqual(result2);
      expect(result1).toEqual(['2024-01-16', '2024-01-17', '2024-01-18']);
    });

    it('should be pure function without side effects', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'weekly';
      const count = 2;

      // Act
      const result1 = generateRecurringSchedule(startDate, repeatType, count);
      const result2 = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result1).toEqual(result2);
      expect(result1).not.toBe(result2);
    });
  });

  describe('입력 검증', () => {
    it('should handle invalid date format', () => {
      // Arrange
      const startDate = 'invalid-date';
      const repeatType = 'daily';
      const count = 1;

      // Act & Assert
      expect(() => generateRecurringSchedule(startDate, repeatType, count)).toThrow();
    });

    it('should handle invalid repeat type', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'invalid' as any;
      const count = 1;

      // Act & Assert
      expect(() => generateRecurringSchedule(startDate, repeatType, count)).toThrow();
    });

    it('should handle zero or negative count', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';

      // Act & Assert
      expect(() => generateRecurringSchedule(startDate, repeatType, 0)).toThrow();
      expect(() => generateRecurringSchedule(startDate, repeatType, -1)).toThrow();
    });

    it('should return empty array for zero valid count', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 0;

      // Act
      const result = generateRecurringSchedule(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([]);
    });
  });
});
```
