---

## 🧪 테스트 스위트: Schedule Recurring Rule

### 📁 파일명: `src/__tests__/unit/scheduleRecurringRule.spec.ts`

---

## 🔴 RED Phase: 실패하는 테스트부터 시작

### 1️⃣ 매일 반복 (Daily)

#### 테스트 케이스 1.1
- **이름**: `should generate next day when repeat type is daily`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `매일`로 설정되고 1회 반복 요청
- **Then**: `2024-02-01`을 반환해야 함
- **Mocking**: 불필요 (순수 함수)

#### 테스트 케이스 1.2
- **이름**: `should generate consecutive daily dates when multiple occurrences requested`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `매일`로 설정되고 3회 반복 요청
- **Then**: `['2024-02-01', '2024-02-02', '2024-02-03']`을 반환해야 함
- **Mocking**: 불필요

#### 테스트 케이스 1.3 (Edge Case)
- **이름**: `should handle daily repeat across month boundary`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-02-28`
- **When**: 반복 유형이 `매일`로 설정되고 3회 반복 요청
- **Then**: `['2024-02-29', '2024-03-01', '2024-03-02']`을 반환해야 함
- **Mocking**: 불필요

---

### 2️⃣ 매주 반복 (Weekly)

#### 테스트 케이스 2.1
- **이름**: `should generate same weekday when repeat type is weekly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31 (수요일)`
- **When**: 반복 유형이 `매주`로 설정되고 1회 반복 요청
- **Then**: `2024-02-07 (수요일)`을 반환해야 함
- **Mocking**: 불필요

#### 테스트 케이스 2.2
- **이름**: `should generate consecutive weekly dates on same weekday`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31 (수요일)`
- **When**: 반복 유형이 `매주`로 설정되고 3회 반복 요청
- **Then**: `['2024-02-07', '2024-02-14', '2024-02-21']` 모두 수요일이어야 함
- **Mocking**: 불필요

#### 테스트 케이스 2.3 (Edge Case)
- **이름**: `should preserve weekday across month and year boundaries`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-12-30 (월요일)`
- **When**: 반복 유형이 `매주`로 설정되고 2회 반복 요청
- **Then**: `['2025-01-06', '2025-01-13']` 모두 월요일이어야 함
- **Mocking**: 불필요

---

### 3️⃣ 매월 반복 (Monthly)

#### 테스트 케이스 3.1
- **이름**: `should skip months without the original day when repeat type is monthly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `매월`로 설정되고 2회 반복 요청
- **Then**: `['2024-03-31', '2024-05-31']`을 반환해야 함 (2월, 4월 제외)
- **Mocking**: 불필요

#### 테스트 케이스 3.2 (Edge Case)
- **이름**: `should handle February when original day is 31st`
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `매월`로 설정되고 다음 달 확인
- **Then**: 2월에는 일정이 생성되지 않아야 함
- **Mocking**: 불필요

#### 테스트 케이스 3.3
- **이름**: `should generate monthly dates for day existing in all months`
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-15`
- **When**: 반복 유형이 `매월`로 설정되고 3회 반복 요청
- **Then**: `['2024-02-15', '2024-03-15', '2024-04-15']`을 반환해야 함
- **Mocking**: 불필요

#### 테스트 케이스 3.4 (Edge Case)
- **이름**: `should handle monthly repeat for 29th across leap and non-leap years`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-29`
- **When**: 반복 유형이 `매월`로 설정되고 2회 반복 요청
- **Then**: `['2024-02-29', '2024-03-29']`을 반환해야 함 (윤년 2월 포함)
- **Mocking**: 불필요

#### 테스트 케이스 3.5 (Edge Case)
- **이름**: `should skip February in non-leap year when original day is 30th or 31st`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2023-01-30` (비윤년)
- **When**: 반복 유형이 `매월`로 설정되고 2회 반복 요청
- **Then**: `['2023-03-30', '2023-04-30']`을 반환해야 함 (2월 제외)
- **Mocking**: 불필요

---

### 4️⃣ 매년 반복 (Yearly)

#### 테스트 케이스 4.1
- **이름**: `should generate next year on same date when repeat type is yearly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `매년`로 설정되고 1회 반복 요청
- **Then**: `2025-01-31`을 반환해야 함
- **Mocking**: 불필요

#### 테스트 케이스 4.2 (Edge Case - Critical)
- **이름**: `should only generate on leap year February 29th when original date is Feb 29`
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일이 `2024-02-29` (윤년)
- **When**: 반복 유형이 `매년`로 설정되고 2회 반복 요청
- **Then**: `['2028-02-29', '2032-02-29']`을 반환해야 함 (다음 윤년들만)
- **Mocking**: 불필요

#### 테스트 케이스 4.3 (Edge Case)
- **이름**: `should skip non-leap years when original date is February 29th`
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일이 `2024-02-29`
- **When**: 반복 유형이 `매년`로 설정되고 다음 5년 확인
- **Then**: 2025, 2026, 2027은 제외되고 2028만 포함되어야 함
- **Mocking**: 불필요

#### 테스트 케이스 4.4
- **이름**: `should generate yearly dates for regular dates`
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 `2024-06-15`
- **When**: 반복 유형이 `매년`로 설정되고 3회 반복 요청
- **Then**: `['2025-06-15', '2026-06-15', '2027-06-15']`을 반환해야 함
- **Mocking**: 불필요

---

### 5️⃣ 반복 일정 겹침 무시

#### 테스트 케이스 5.1
- **이름**: `should not check for existing events when generating recurring dates`
- **타입**: unit
- **우선순위**: high
- **Given**: 이미 일정이 존재하는 날짜들
- **When**: 반복 일정 생성 함수 호출
- **Then**: 기존 일정 확인 없이 날짜만 계산하여 반환해야 함
- **Mocking**: 불필요 (순수 함수이므로 외부 상태 접근 없음)
- **참고**: 이 테스트는 함수가 외부 이벤트 데이터를 참조하지 않음을 확인

#### 테스트 케이스 5.2
- **이름**: `should allow duplicate dates in result when multiple events exist`
- **타입**: integration
- **우선순위**: medium
- **Given**: 동일한 날짜에 대한 반복 일정 요청
- **When**: 같은 파라미터로 함수를 두 번 호출
- **Then**: 두 호출 모두 동일한 날짜 배열을 반환해야 함 (중복 허용)
- **Mocking**: 불필요

---

### 6️⃣ 입력 유효성 검증 (Defensive Programming)

#### 테스트 케이스 6.1 (Edge Case)
- **이름**: `should handle invalid date format gracefully`
- **타입**: edge
- **우선순위**: medium
- **Given**: 잘못된 날짜 형식 `"invalid-date"`
- **When**: 함수 호출
- **Then**: 에러를 던지거나 빈 배열을 반환해야 함
- **Mocking**: 불필요

#### 테스트 케이스 6.2 (Edge Case)
- **이름**: `should handle zero or negative occurrences`
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 유효하고 반복 횟수가 `0` 또는 음수
- **When**: 함수 호출
- **Then**: 빈 배열을 반환해야 함
- **Mocking**: 불필요

#### 테스트 케이스 6.3 (Edge Case)
- **이름**: `should handle unknown repeat type`
- **타입**: edge
- **우선순위**: medium
- **Given**: 반복 유형이 `"unknown"` 또는 `null`
- **When**: 함수 호출
- **Then**: 에러를 던지거나 빈 배열을 반환해야 함
- **Mocking**: 불필요

---

## 📊 테스트 우선순위 요약

### 🔴 High Priority (Red Phase 우선)
1. 매일 반복 기본 동작 (1.1, 1.2)
2. 매주 반복 기본 동작 (2.1, 2.2)
3. 매월 31일 예외 처리 (3.1, 3.2)
4. 매년 윤년 2/29 예외 처리 (4.2, 4.3)
5. 일정 겹침 무시 (5.1)

### 🟡 Medium Priority
- 경계값 테스트 (월/년 경계)
- 다양한 날짜에 대한 매월/매년 처리
- 입력 유효성 검증

### ⚪ Low Priority
- 엣지 케이스 중 낮은 빈도 시나리오

---

## 🎯 TDD 실천 가이드

### Red Phase
1. **가장 단순한 테스트부터**: 1.1 (매일 반복 1회)
2. **점진적 확장**: 1.2 (매일 반복 여러 회)
3. **예외 케이스**: 3.2, 4.2 (31일, 윤년)

### Green Phase
- 테스트를 통과할 만큼만 구현
- 하드코딩도 허용 (리팩토링에서 개선)

### Refactor Phase
- 중복 제거
- 명확성 개선
- 성능 최적화

---

## 🛠️ 구현 힌트

### 함수 시그니처 예상
```typescript
type RepeatType = 'daily' | 'weekly' | 'monthly' | 'yearly';

function generateRecurringDates(
  startDate: string,
  repeatType: RepeatType,
  occurrences: number
): string[]
```

### AAA 패턴 적용 예시
```typescript
describe('Schedule Recurring Rule', () => {
  describe('Daily Repeat', () => {
    it('should generate next day when repeat type is daily', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const occurrences = 1;

      // Act
      const result = generateRecurringDates(startDate, repeatType, occurrences);

      // Assert
      expect(result).toEqual(['2024-02-01']);
    });
  });
});
```

---

## ✅ 품질 체크리스트

- ✅ 각 테스트는 단일 동작만 검증
- ✅ 테스트 이름이 의도를 명확히 표현
- ✅ AAA 패턴 준수
- ✅ 외부 의존성 없음 (순수 함수)
- ✅ 테스트 독립성 보장
- ✅ 경계값 및 예외 케이스 포함
- ✅ 실패 메시지가 명확함

---

이 테스트 설계는 Kent Beck의 "작게 시작하여 단계적으로 확장" 원칙을 따르며, 각 테스트가 단일 책임을 가지고 명확한 의도를 드러내도록 설계되었습니다. Red → Green → Refactor 사이클을 반복하며 구현하시면 됩니다.
