```typescript
// filepath: src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('Normal Cases - Basic Validation', () => {
    it('should return isValid true when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid true when start date equals end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid false with error when start date is after end date', () => {
      // Arrange
      const startDate = '2024-01-31';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 종료일보다 이후일 수 없습니다');
    });
  });

  describe('Input Format - Date Objects and Strings', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 strings as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00Z';
      const endDate = '2024-01-31T23:59:59Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept mixed input types (Date and string)', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-01-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Cases - Null and Undefined', () => {
    it('should return error when startDate is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2024-01-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 유효하지 않습니다');
    });

    it('should return error when endDate is null', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = null;
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일이 유효하지 않습니다');
    });

    it('should return error when startDate is undefined', () => {
      // Arrange
      const startDate = undefined;
      const endDate = '2024-01-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 유효하지 않습니다');
    });

    it('should return error when endDate is undefined', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = undefined;
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일이 유효하지 않습니다');
    });

    it('should return error when both dates are null', () => {
      // Arrange
      const startDate = null;
      const endDate = null;
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 유효하지 않습니다');
    });
  });

  describe('Error Cases - Invalid Date Formats', () => {
    it('should return error for invalid date string format', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-01-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });

    it('should return error for malformed ISO string with invalid month', () => {
      // Arrange
      const startDate = '2024-13-01';
      const endDate = '2024-01-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });

    it('should return error for invalid Date object (Invalid Date)', () => {
      // Arrange
      const startDate = new Date('invalid');
      const endDate = '2024-01-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });
  });

  describe('Edge Cases - Boundary Values', () => {
    it('should return isValid true for dates with 1 day difference', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid true with warning for dates with 100+ years difference', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should handle dates at year boundaries', () => {
      // Arrange
      const startDate = '2023-12-31';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle leap year dates', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle dates with time components (same day, different times)', () => {
      // Arrange
      const startDate = '2024-01-01T08:00:00Z';
      const endDate = '2024-01-01T17:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle very distant past dates', () => {
      // Arrange
      const startDate = '1000-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should handle very distant future dates', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '3024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should handle minimum valid date difference (1 millisecond)', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-01-01T00:00:00.001Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Edge Cases - Timezone Handling', () => {
    it('should handle dates with different timezone offsets', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00+09:00';
      const endDate = '2024-01-01T00:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 종료일보다 이후일 수 없습니다');
    });

    it('should normalize dates without timezone to UTC', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Integration Tests', () => {
    it('should work correctly when called multiple times with different inputs', () => {
      // Arrange & Act
      const result1 = validateDateRange('2024-01-01', '2024-01-31');
      const result2 = validateDateRange('2024-02-01', '2024-01-31');
      const result3 = validateDateRange(null, '2024-01-31');
      
      // Assert
      expect(result1.isValid).toBe(true);
      expect(result2.isValid).toBe(false);
      expect(result3.isValid).toBe(false);
    });

    it('should not mutate input Date objects', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-31');
      const originalStartTime = startDate.getTime();
      const originalEndTime = endDate.getTime();
      
      // Act
      validateDateRange(startDate, endDate);
      
      // Assert
      expect(startDate.getTime()).toBe(originalStartTime);
      expect(endDate.getTime()).toBe(originalEndTime);
    });
  });
});
```
