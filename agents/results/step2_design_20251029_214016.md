날짜 범위 검증 함수의 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: validateDateRange

### 기본 동작 (Basic Operations)

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-06-15'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-12-31'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Start date must be before or equal to end date' }`를 반환해야 함

---

### 입력 형식 검증 (Input Format Validation)

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체 형식의 시작일과 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 string format as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 문자열 형식의 시작일 '2024-01-01T00:00:00Z'과 종료일 '2024-12-31T23:59:59Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 6
- **이름**: should accept mixed input types (Date object and ISO string)
- **타입**: unit
- **우선순위**: medium
- **Given**: Date 객체 형식의 시작일과 ISO 8601 문자열 형식의 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

---

### 에러 처리 (Error Handling)

#### 테스트 케이스 7
- **이름**: should return error when startDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 null이고 endDate는 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Start date is required' }`를 반환해야 함

#### 테스트 케이스 8
- **이름**: should return error when endDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜이고 endDate가 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'End date is required' }`를 반환해야 함

#### 테스트 케이스 9
- **이름**: should return error when startDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 undefined이고 endDate는 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Start date is required' }`를 반환해야 함

#### 테스트 케이스 10
- **이름**: should return error when endDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜이고 endDate가 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'End date is required' }`를 반환해야 함

#### 테스트 케이스 11
- **이름**: should return error when startDate has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate가 'invalid-date'이고 endDate는 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Invalid start date format' }`를 반환해야 함

#### 테스트 케이스 12
- **이름**: should return error when endDate has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 유효한 날짜이고 endDate가 'not-a-date'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Invalid end date format' }`를 반환해야 함

#### 테스트 케이스 13
- **이름**: should return error when both dates are invalid
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate와 endDate 모두 잘못된 형식
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Invalid start date format' }`를 반환해야 함 (첫 번째 에러 우선)

---

### 엣지 케이스 (Edge Cases)

#### 테스트 케이스 14
- **이름**: should return valid when dates are exactly 1 day apart
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-06-15'과 종료일 '2024-06-16'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates are more than 100 years apart
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '1920-01-01'과 종료일 '2024-12-31' (100년 이상 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: 'Date range exceeds 100 years' }`를 반환해야 함

#### 테스트 케이스 16
- **이름**: should handle dates at year boundaries
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2023-12-31T23:59:59'과 종료일 '2024-01-01T00:00:00'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 17
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-02-29' (윤년)과 종료일 '2024-03-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 18
- **이름**: should handle dates with different timezones
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-01-01T00:00:00+09:00'과 종료일 '2024-01-01T00:00:00-05:00'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함 (UTC 기준으로 비교)

#### 테스트 케이스 19
- **이름**: should handle dates in distant past
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '1900-01-01'과 종료일 '1900-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 20
- **이름**: should handle dates in distant future
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2100-01-01'과 종료일 '2100-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 21
- **이름**: should handle same date with different time components
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-06-15T09:00:00'과 종료일 '2024-06-15T17:00:00'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 22
- **이름**: should return invalid when same date but start time is after end time
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-06-15T17:00:00'과 종료일 '2024-06-15T09:00:00'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Start date must be before or equal to end date' }`를 반환해야 함

---

### 성능 및 경계 테스트 (Performance & Boundary Tests)

#### 테스트 케이스 23
- **이름**: should execute within acceptable time for valid inputs
- **타입**: unit
- **우선순위**: low
- **Given**: 유효한 시작일과 종료일
- **When**: validateDateRange 함수를 100회 연속 호출할 때
- **Then**: 평균 실행 시간이 1ms 미만이어야 함

#### 테스트 케이스 24
- **이름**: should handle empty string inputs
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate가 빈 문자열 ''
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: 'Invalid start date format' }`를 반환해야 함

---

## 테스트 실행 우선순위

### High Priority (반드시 통과해야 함)
- 테스트 케이스 1, 2, 3: 기본 동작 검증
- 테스트 케이스 4, 5: 입력 형식 지원
- 테스트 케이스 7-12: 에러 처리

### Medium Priority (중요한 기능)
- 테스트 케이스 6: 혼합 입력 타입
- 테스트 케이스 13-15, 17, 21-22, 24: 엣지 케이스

### Low Priority (추가 검증)
- 테스트 케이스 16, 18-20, 23: 특수 상황 및 성능

---

## 구현 예시 (Vitest)

```typescript
// src/__tests__/validateDateRange.test.ts
import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('Basic Operations', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    // ... 나머지 테스트 케이스들
  });

  describe('Error Handling', () => {
    // ... 에러 처리 테스트들
  });

  describe('Edge Cases', () => {
    // ... 엣지 케이스 테스트들
  });
});
```

이제 이 테스트 설계를 바탕으로 실제 테스트 코드를 작성하시겠습니까?
