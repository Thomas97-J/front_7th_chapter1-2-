```typescript
// filepath: src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('Basic Functionality', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid when start date equals end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return invalid when start date is after end date', () => {
      // Arrange
      const startDate = '2024-01-31';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });
  });

  describe('Input Type Handling', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-31');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 string format as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-01-31T00:00:00.000Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept mixed input types (Date and string)', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Handling', () => {
    it('should return error when start date is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2024-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 제공되지 않았습니다');
    });

    it('should return error when end date is undefined', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = undefined;

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일이 제공되지 않았습니다');
    });

    it('should return error when both dates are null', () => {
      // Arrange
      const startDate = null;
      const endDate = null;

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일과 종료일이 제공되지 않았습니다');
    });

    it('should return error when invalid date string is provided', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });

    it('should return error when date string is in wrong format', () => {
      // Arrange
      const startDate = '01/01/2024';
      const endDate = '01/31/2024';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });

    it('should return error when Invalid Date object is provided', () => {
      // Arrange
      const startDate = new Date('invalid');
      const endDate = new Date('2024-01-31');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });
  });

  describe('Edge Cases', () => {
    it('should return valid for same date at different times', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00Z';
      const endDate = '2024-01-01T23:59:59Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid for one day difference', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid with warning for more than 100 years difference', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should return valid for exactly 100 years difference', () => {
      // Arrange
      const startDate = '1924-01-01';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBeUndefined();
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return error for non-existent leap year date', () => {
      // Arrange
      const startDate = '2023-02-29';
      const endDate = '2023-03-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });

    it('should handle timezone differences correctly', () => {
      // Arrange
      const startDate = '2024-01-01T23:00:00+09:00';
      const endDate = '2024-01-01T15:00:00+01:00';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle very old dates (before 1900)', () => {
      // Arrange
      const startDate = '1800-01-01';
      const endDate = '1850-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle future dates far ahead', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2999-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should handle midnight edge case', () => {
      // Arrange
      const startDate = '2024-01-01T23:59:59.999Z';
      const endDate = '2024-01-02T00:00:00.000Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Additional Boundary Cases', () => {
    it('should handle end date one millisecond before start date', () => {
      // Arrange
      const startDate = new Date('2024-01-01T12:00:00.000Z');
      const endDate = new Date('2024-01-01T11:59:59.999Z');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });

    it('should handle end date exactly at 100 year boundary plus one day', () => {
      // Arrange
      const startDate = '1924-01-01';
      const endDate = '2024-01-02';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should handle both dates as undefined', () => {
      // Arrange
      const startDate = undefined;
      const endDate = undefined;

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일과 종료일이 제공되지 않았습니다');
    });

    it('should handle empty string as date input', () => {
      // Arrange
      const startDate = '';
      const endDate = '2024-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('잘못된 날짜 형식입니다');
    });

    it('should handle year boundaries correctly', () => {
      // Arrange
      const startDate = '2023-12-31T23:59:59.999Z';
      const endDate = '2024-01-01T00:00:00.000Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });
});
```
