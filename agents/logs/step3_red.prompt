당신은 TDD RED 단계 전문가입니다.

## 원본 명세

# 예제 기능 명세: 날짜 범위 검증 함수

## 기능 설명
두 날짜 사이의 기간이 유효한지 검증하는 함수를 구현합니다.

## 요구사항

### 1. 기본 동작
- 시작일과 종료일을 입력받습니다
- 시작일이 종료일보다 이전이면 유효합니다
- 시작일과 종료일이 같으면 유효합니다

### 2. 입력
- `startDate`: Date 객체 또는 ISO 8601 문자열
- `endDate`: Date 객체 또는 ISO 8601 문자열

### 3. 출력
- 유효한 경우: `{ isValid: true }`
- 무효한 경우: `{ isValid: false, error: string }`

### 4. 에러 처리
- null 또는 undefined 입력시 에러
- 잘못된 날짜 형식 입력시 에러
- 시작일이 종료일보다 이후인 경우 에러

### 5. 엣지 케이스
- 같은 날짜: 유효
- 1일 차이: 유효
- 100년 이상 차이: 유효 (경고 메시지)

## 테스트 설계 결과 (Step 2)

명세를 바탕으로 날짜 범위 검증 함수에 대한 포괄적인 테스트 케이스를 설계하겠습니다.

---

## 테스트 스위트: 날짜 범위 검증 함수 (Date Range Validation)

### **Unit Tests - 기본 동작**

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-12-31'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일 모두 '2024-06-15'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-12-31'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }` 반환

---

### **Unit Tests - 입력 형식 처리**

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 생성된 시작일과 종료일
- **When**: validateDateRange(new Date('2024-01-01'), new Date('2024-12-31')) 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 문자열 '2024-01-01T00:00:00Z'와 '2024-12-31T23:59:59Z'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 6
- **이름**: should accept mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 ISO 8601 문자열
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환 (날짜가 유효한 경우)

---

### **Unit Tests - 에러 처리**

#### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null, 종료일은 유효한 날짜
- **When**: validateDateRange(null, '2024-12-31') 호출
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 8
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일은 유효한 날짜, 종료일이 undefined
- **When**: validateDateRange('2024-01-01', undefined) 호출
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }` 반환

#### 테스트 케이스 9
- **이름**: should return error when both dates are null
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일과 종료일 모두 null
- **When**: validateDateRange(null, null) 호출
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 10
- **이름**: should return error when start date format is invalid
- **타입**: unit
- **우선순위**: high
- **Given**: 잘못된 형식의 시작일 'invalid-date'
- **When**: validateDateRange('invalid-date', '2024-12-31') 호출
- **Then**: `{ isValid: false, error: '유효하지 않은 시작일 형식입니다' }` 반환

#### 테스트 케이스 11
- **이름**: should return error when end date format is invalid
- **타입**: unit
- **우선순위**: high
- **Given**: 유효한 시작일과 잘못된 형식의 종료일 '2024/13/32'
- **When**: validateDateRange('2024-01-01', '2024/13/32') 호출
- **Then**: `{ isValid: false, error: '유효하지 않은 종료일 형식입니다' }` 반환

#### 테스트 케이스 12
- **이름**: should return error when date string is not ISO 8601 format
- **타입**: unit
- **우선순위**: medium
- **Given**: 'MM/DD/YYYY' 형식의 날짜 문자열
- **When**: validateDateRange('01/01/2024', '12/31/2024') 호출
- **Then**: `{ isValid: false, error: '유효하지 않은 날짜 형식입니다' }` 반환 또는 파싱 후 유효성 검증

---

### **Edge Cases - 경계값 테스트**

#### 테스트 케이스 13
- **이름**: should return valid when dates differ by exactly 1 day
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-06-15'과 종료일 '2024-06-16'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 14
- **이름**: should return valid when dates differ by exactly 1 second
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-06-15T12:00:00Z'과 종료일 '2024-06-15T12:00:01Z'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates differ by more than 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '1900-01-01'과 종료일 '2024-12-31'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 16
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-02-29' (윤년), 종료일 '2024-03-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 17
- **이름**: should return error when using non-leap year Feb 29
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2023-02-29' (평년), 종료일 '2023-03-01'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '유효하지 않은 시작일 형식입니다' }` 반환

#### 테스트 케이스 18
- **이름**: should handle dates at Unix epoch
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '1970-01-01T00:00:00Z', 종료일 '2024-12-31'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 19
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-01-01', 종료일 '2999-12-31'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 20
- **이름**: should handle timezone differences correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-06-15T23:00:00+09:00', 종료일 '2024-06-15T15:00:00Z' (같은 시각)
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

---

### **Edge Cases - 특수 케이스**

#### 테스트 케이스 21
- **이름**: should handle millisecond precision
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-06-15T12:00:00.000Z', 종료일 '2024-06-15T12:00:00.001Z'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 22
- **이름**: should return invalid when dates are reversed by 1 millisecond
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-06-15T12:00:00.001Z', 종료일 '2024-06-15T12:00:00.000Z'
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }` 반환

#### 테스트 케이스 23
- **이름**: should handle Date objects with time components
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 Date(2024, 5, 15, 9, 30), 종료일 Date(2024, 5, 15, 17, 30)
- **When**: validateDateRange 함수 호출
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 24
- **이름**: should handle empty string input
- **타입**: edge
- **우선순위**: medium
- **Given**: 빈 문자열 ''을 시작일로 전달
- **When**: validateDateRange('', '2024-12-31') 호출
- **Then**: `{ isValid: false, error: '유효하지 않은 시작일 형식입니다' }` 반환

#### 테스트 케이스 25
- **이름**: should handle whitespace-only string input
- **타입**: edge
- **우선순위**: low
- **Given**: 공백 문자열 '   '을 종료일로 전달
- **When**: validateDateRange('2024-01-01', '   ') 호출
- **Then**: `{ isValid: false, error: '유효하지 않은 종료일 형식입니다' }` 반환

---

### **Integration Tests**

#### 테스트 케이스 26
- **이름**: should validate multiple date ranges in sequence
- **타입**: integration
- **우선순위**: medium
- **Given**: 여러 개의 날짜 쌍 배열
- **When**: 각 쌍에 대해 validateDateRange 함수를 순차적으로 호출
- **Then**: 각각 독립적으로 올바른 검증 결과 반환

#### 테스트 케이스 27
- **이름**: should maintain consistency across different input formats
- **타입**: integration
- **우선순위**: medium
- **Given**: 같은 날짜를 Date 객체와 ISO 문자열로 각각 전달
- **When**: 두 경우 모두 validateDateRange 함수 호출
- **Then**: 동일한 검증 결과 반환

#### 테스트 케이스 28
- **이름**: should handle rapid successive calls without side effects
- **타입**: integration
- **우선순위**: low
- **Given**: 동일한 입력으로 함수를 연속 호출
- **When**: validateDateRange를 100회 반복 호출
- **Then**: 모든 호출에서 동일한 결과 반환 (순수 함수 검증)

---

### **Performance Tests**

#### 테스트 케이스 29
- **이름**: should execute within acceptable time for valid inputs
- **타입**: unit
- **우선순위**: low
- **Given**: 유효한 날짜 범위
- **When**: validateDateRange 함수 호출 시 실행 시간 측정
- **Then**: 10ms 이내 실행 완료

#### 테스트 케이스 30
- **이름**: should handle large batch processing efficiently
- **타입**: integration
- **우선순위**: low
- **Given**: 10,000개의 날짜 쌍
- **When**: 각 쌍에 대해 validateDateRange 함수 호출
- **Then**: 전체 처리가 1초 이내 완료

---

## 테스트 구현 예시 (Vitest)

```typescript
// src/__tests__/unit/dateRangeValidation.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '@/utils/dateRangeValidation';

describe('Date Range Validation', () => {
  describe('기본 동작', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it('should return valid when start date equals end date', () => {
      // Arrange
      const startDate = '2024-06-15';
      const endDate = '2024-06-15';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return invalid when start date is after end date', () => {
      // Arrange
      const startDate = '2024-12-31';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });
  });

  describe('입력 형식 처리', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 strings as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00Z';
      const endDate = '2024-12-31T23:59:59Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('에러 처리', () => {
    it('should return error when start date is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2024-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('시작일');
    });

    it('should return error when start date format is invalid', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('형식');
    });
  });

  describe('경계값 테스트', () => {
    it('should return valid when dates differ by exactly 1 day', () => {
      // Arrange
      const startDate = '2024-06-15';
      const endDate = '2024-06-16';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid with warning when dates differ by more than 100 years', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toContain('100년');
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });
});
```

---

## 테스트 커버리지 목표

- **라인 커버리지**: 100%
- **분기 커버리지**: 100%
- **함수 커버리지**: 100%

## 주요 테스트 전략

1. **AAA 패턴 준수**: 모든 테스트는 Arrange-Act-Assert 구조로 작성
2. **독립성 보장**: 각 테스트는 다른 테스트에 영향을 주지 않음
3. **명확한 의도**: 테스트 이름만으로도 검증 내용을 파악 가능
4. **경계값 중점**: 정상 케이스뿐만 아니라 경계값 및 예외 상황 철저히 검증
5. **빠른 피드백**: 단위 테스트는 밀리초 단위로 실행 가능하도록 최적화

이 테스트 설계는 날짜 범위 검증 함수의 모든 요구사항과 엣지 케이스를 포괄적으로 다루며, 실무에서 발생 가능한 다양한 시나리오를 검증합니다.

---

위의 테스트 설계를 바탕으로 **완전한 Vitest 테스트 코드**를 작성해주세요.

**중요: 반드시 실행 가능한 TypeScript 코드만 제공하세요!**

출력 형식:
````typescript
// filepath: src/__tests__/unit/[기능명].spec.ts
import { describe, it, expect } from 'vitest';
import { functionName } from '../../utils/[파일명]';

describe('테스트 스위트', () => {
  describe('카테고리', () => {
    it('should ...', () => {
      // Arrange
      const input = ...;
      
      // Act
      const result = functionName(input);
      
      // Assert
      expect(result).toBe(...);
    });
  });
});
````

요구사항:
- Vitest 프레임워크
- TypeScript
- AAA 패턴
- 최소 10개 이상의 테스트
- 모든 엣지 케이스 포함

**주의: 설명이나 구조 안내가 아닌, 복사해서 바로 실행 가능한 코드만 작성하세요.**
