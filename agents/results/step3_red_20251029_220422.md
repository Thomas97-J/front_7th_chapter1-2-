```typescript
// filepath: src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('Normal Cases - Basic Operations', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid when start date equals end date', () => {
      // Arrange
      const startDate = '2024-06-15';
      const endDate = '2024-06-15';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return invalid when start date is after end date', () => {
      // Arrange
      const startDate = '2024-12-31';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });
  });

  describe('Input Format Cases', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 strings as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-12-31T23:59:59.999Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept mixed Date object and ISO string', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Cases - Null and Undefined', () => {
    it('should return error when startDate is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate as any, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 필수입니다');
    });

    it('should return error when endDate is undefined', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = undefined;
      
      // Act
      const result = validateDateRange(startDate, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일은 필수입니다');
    });

    it('should return error when both dates are null', () => {
      // Arrange
      const startDate = null;
      const endDate = null;
      
      // Act
      const result = validateDateRange(startDate as any, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 필수입니다');
    });
  });

  describe('Error Cases - Invalid Format', () => {
    it('should return error when startDate is invalid format', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('올바른 날짜 형식이 아닙니다');
    });

    it('should return error when endDate is invalid format', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = 'not-a-date';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('올바른 날짜 형식이 아닙니다');
    });

    it('should return error when date string is malformed', () => {
      // Arrange
      const startDate = '2024-13-45';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('올바른 날짜 형식이 아닙니다');
    });
  });

  describe('Edge Cases - Boundary Values', () => {
    it('should return valid when dates differ by exactly one day', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid when dates differ by one second', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00';
      const endDate = '2024-01-01T00:00:01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid with warning when dates differ by more than 100 years', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should return valid with warning when dates differ by exactly 100 years', () => {
      // Arrange
      const startDate = '1924-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should handle dates at year boundaries correctly', () => {
      // Arrange
      const startDate = '2023-12-31T23:59:59';
      const endDate = '2024-01-01T00:00:00';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return error for invalid leap year date', () => {
      // Arrange
      const startDate = '2023-02-29';
      const endDate = '2023-03-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('올바른 날짜 형식이 아닙니다');
    });
  });

  describe('Edge Cases - Timezone and Special Cases', () => {
    it('should handle timezone differences in ISO strings', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00+09:00';
      const endDate = '2024-01-01T00:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });

    it('should handle dates with milliseconds', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-01-01T00:00:00.001Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle very old dates', () => {
      // Arrange
      const startDate = '1000-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should handle far future dates', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '9999-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });
  });

  describe('Integration Cases - Real World Scenarios', () => {
    it('should validate date range in booking scenario', () => {
      // Arrange
      const checkInDate = '2024-06-15';
      const checkOutDate = '2024-06-20';
      
      // Act
      const result = validateDateRange(checkInDate, checkOutDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle sequential validation calls', () => {
      // Arrange
      const ranges = [
        { start: '2024-01-01', end: '2024-01-31' },
        { start: '2024-02-01', end: '2024-02-29' },
        { start: '2024-03-01', end: '2024-03-31' }
      ];
      
      // Act
      const results = ranges.map(range => 
        validateDateRange(range.start, range.end)
      );
      
      // Assert
      results.forEach(result => {
        expect(result.isValid).toBe(true);
      });
    });
  });
});
```
