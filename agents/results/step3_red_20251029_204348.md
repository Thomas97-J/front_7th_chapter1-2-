```typescript
// filepath: src/__tests__/unit/date-range-validator.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/date-range-validator';

describe('validateDateRange', () => {
  describe('Normal Cases', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = '2025-01-01';
      const endDate = '2025-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid when start date equals end date', () => {
      // Arrange
      const startDate = '2025-01-15';
      const endDate = '2025-01-15';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return invalid when start date is after end date', () => {
      // Arrange
      const startDate = '2025-01-31';
      const endDate = '2025-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });

    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2025-01-01');
      const endDate = new Date('2025-01-31');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 strings as input', () => {
      // Arrange
      const startDate = '2025-01-01T00:00:00Z';
      const endDate = '2025-01-31T23:59:59Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept mixed input types (Date and string)', () => {
      // Arrange
      const startDate = new Date('2025-01-01');
      const endDate = '2025-01-31T23:59:59Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Cases', () => {
    it('should return error when start date is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2025-01-31';

      // Act
      const result = validateDateRange(startDate as any, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 제공되지 않았습니다');
    });

    it('should return error when end date is null', () => {
      // Arrange
      const startDate = '2025-01-01';
      const endDate = null;

      // Act
      const result = validateDateRange(startDate, endDate as any);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일이 제공되지 않았습니다');
    });

    it('should return error when both dates are null', () => {
      // Arrange
      const startDate = null;
      const endDate = null;

      // Act
      const result = validateDateRange(startDate as any, endDate as any);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 제공되지 않았습니다');
    });

    it('should return error when start date is undefined', () => {
      // Arrange
      const startDate = undefined;
      const endDate = '2025-01-31';

      // Act
      const result = validateDateRange(startDate as any, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일이 제공되지 않았습니다');
    });

    it('should return error when end date is undefined', () => {
      // Arrange
      const startDate = '2025-01-01';
      const endDate = undefined;

      // Act
      const result = validateDateRange(startDate, endDate as any);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일이 제공되지 않았습니다');
    });

    it('should return error when start date has invalid format', () => {
      // Arrange
      const startDate = 'invalid-date-string';
      const endDate = '2025-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('유효하지 않은 시작일 형식입니다');
    });

    it('should return error when end date has invalid format', () => {
      // Arrange
      const startDate = '2025-01-01';
      const endDate = 'not-a-date';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('유효하지 않은 종료일 형식입니다');
    });

    it('should return error when start date is Invalid Date object', () => {
      // Arrange
      const startDate = new Date('invalid');
      const endDate = new Date('2025-01-31');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('유효하지 않은 시작일 형식입니다');
    });
  });

  describe('Edge Cases', () => {
    it('should return valid when dates differ by 1 day', () => {
      // Arrange
      const startDate = '2025-01-15';
      const endDate = '2025-01-16';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid with warning when dates differ by more than 100 years', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2025-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년을 초과합니다');
    });

    it('should return valid when range is exactly 100 years', () => {
      // Arrange
      const startDate = '1925-01-01';
      const endDate = '2025-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBeUndefined();
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle year boundary crossing', () => {
      // Arrange
      const startDate = '2024-12-31';
      const endDate = '2025-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle month boundary crossing', () => {
      // Arrange
      const startDate = '2025-01-31';
      const endDate = '2025-02-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle dates with different time zones in ISO format', () => {
      // Arrange
      const startDate = '2025-01-01T00:00:00+09:00';
      const endDate = '2025-01-01T00:00:00Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });

    it('should handle dates at midnight', () => {
      // Arrange
      const startDate = '2025-01-01T00:00:00';
      const endDate = '2025-01-01T00:00:00';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle dates at end of day', () => {
      // Arrange
      const startDate = '2025-01-01T23:59:59';
      const endDate = '2025-01-02T00:00:00';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle very old dates (year 1000)', () => {
      // Arrange
      const startDate = '1000-01-01';
      const endDate = '1000-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle far future dates (year 3000)', () => {
      // Arrange
      const startDate = '3000-01-01';
      const endDate = '3000-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle dates with milliseconds precision', () => {
      // Arrange
      const startDate = '2025-01-01T00:00:00.000Z';
      const endDate = '2025-01-01T00:00:00.001Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result.isValid).toBe(true);
    });
  });
});
```

```typescript
// filepath: src/utils/date-range-validator.ts

export type DateInput = Date | string;

export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

export function validateDateRange(startDate: DateInput, endDate: DateInput): ValidationResult {
  if (startDate === null || startDate === undefined) {
    return {
      isValid: false,
      error: '시작일이 제공되지 않았습니다',
    };
  }

  if (endDate === null || endDate === undefined) {
    return {
      isValid: false,
      error: '종료일이 제공되지 않았습니다',
    };
  }

  const startDateObj = typeof startDate === 'string' ? new Date(startDate) : startDate;
  const endDateObj = typeof endDate === 'string' ? new Date(endDate) : endDate;

  if (isNaN(startDateObj.getTime())) {
    return {
      isValid: false,
      error: '유효하지 않은 시작일 형식입니다',
    };
  }

  if (isNaN(endDateObj.getTime())) {
    return {
      isValid: false,
      error: '유효하지 않은 종료일 형식입니다',
    };
  }

  if (startDateObj > endDateObj) {
    return {
      isValid: false,
      error: '시작일은 종료일보다 이전이어야 합니다',
    };
  }

  const yearsDiff =
    (endDateObj.getTime() - startDateObj.getTime()) / (1000 * 60 * 60 * 24 * 365.25);

  if (yearsDiff > 100) {
    return {
      isValid: true,
      warning: '날짜 범위가 100년을 초과합니다',
    };
  }

  return {
    isValid: true,
  };
}
```
