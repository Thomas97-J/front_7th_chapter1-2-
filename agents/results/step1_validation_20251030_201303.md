# 개선된 명세

```markdown
# Recurring Event Generator Specification

## 개요

반복 일정의 기준 정보를 받아 지정된 반복 규칙에 따라 새로운 일정 목록을 생성하는 순수 함수입니다.
이 함수는 계산만 수행하며, 실제 일정 저장은 `useEventOperations.saveEvent`를 통해 별도로 처리됩니다.

## 위치

**파일:** `src/utils/recurringUtils.ts`

## 타입 정의

### 기존 타입 활용

```typescript
// src/types.ts에서 재사용
import { Event, EventForm, RepeatType, RepeatInfo } from '../types';
```

### 새로운 타입

```typescript
/**
 * 반복 일정 생성 옵션
 */
export interface RecurringEventOptions {
  /** 기준이 되는 원본 일정 */
  baseEvent: Event | EventForm;
  /** 생성할 최대 일정 개수 (기본값: 100, 최대: 365) */
  maxOccurrences?: number;
}

/**
 * 반복 일정 생성 결과
 */
export interface RecurringEventResult {
  /** 생성 성공 여부 */
  success: boolean;
  /** 생성된 일정 목록 (EventForm 배열) */
  events: EventForm[];
  /** 에러 메시지 (실패 시) */
  error?: string;
  /** 경고 메시지 (성공했지만 주의사항이 있을 때) */
  warning?: string;
}
```

## 함수 시그니처

```typescript
/**
 * 반복 일정 규칙에 따라 새로운 일정 목록을 생성합니다.
 * 
 * @param options - 반복 일정 생성 옵션
 * @returns 생성된 일정 목록과 결과 상태
 * 
 * @example
 * ```typescript
 * const result = generateRecurringEvents({
 *   baseEvent: {
 *     title: '주간 회의',
 *     date: '2024-01-31',
 *     startTime: '10:00',
 *     endTime: '11:00',
 *     description: '',
 *     location: '',
 *     category: '업무',
 *     repeat: { type: 'weekly', interval: 1, endDate: '2024-03-31' },
 *     notificationTime: 10
 *   },
 *   maxOccurrences: 50
 * });
 * 
 * if (result.success) {
 *   // result.events를 순회하며 saveEvent 호출
 *   for (const event of result.events) {
 *     await saveEvent(event);
 *   }
 * }
 * ```
 */
export function generateRecurringEvents(
  options: RecurringEventOptions
): RecurringEventResult {
  // 구현은 나중에
}

/**
 * 다음 반복 일정 날짜를 계산합니다.
 * 
 * @param currentDate - 현재 일정 날짜 (YYYY-MM-DD)
 * @param repeatType - 반복 유형
 * @param interval - 반복 간격 (기본값: 1)
 * @returns 다음 일정 날짜 (YYYY-MM-DD) 또는 null (생성 불가한 경우)
 */
export function getNextRecurringDate(
  currentDate: string,
  repeatType: RepeatType,
  interval: number = 1
): string | null {
  // 구현은 나중에
}

/**
 * 특정 날짜가 반복 규칙에 따라 생성 가능한지 검증합니다.
 * 
 * @param date - 검증할 날짜 (YYYY-MM-DD)
 * @param baseDate - 기준 날짜 (YYYY-MM-DD)
 * @param repeatType - 반복 유형
 * @returns 생성 가능 여부
 */
export function isValidRecurringDate(
  date: string,
  baseDate: string,
  repeatType: RepeatType
): boolean {
  // 구현은 나중에
}
```

## 상세 요구사항

### 입력 검증

1. `baseEvent`가 null 또는 undefined인 경우 에러 반환
2. `baseEvent.date` 형식이 유효하지 않은 경우 에러 반환
3. `baseEvent.repeat.type`이 'none'인 경우 빈 배열 반환 (에러 아님)
4. `baseEvent.repeat.interval`이 1 미만인 경우 에러 반환
5. `maxOccurrences`가 1 미만 또는 365 초과인 경우 에러 반환

### 비즈니스 로직

#### 공통 규칙

1. **원본 일정 제외**: 반환되는 배열에는 원본 일정(baseEvent.date)은 포함되지 않고, 다음 발생 일정부터 포함됩니다.
2. **속성 복사**: 생성되는 모든 일정은 `date`를 제외한 나머지 속성(title, startTime, endTime, description, location, category, notificationTime)을 baseEvent에서 복사합니다.
3. **repeat 속성**: 생성된 일정의 `repeat.type`은 'none'으로 설정됩니다 (무한 재귀 방지).
4. **날짜 형식**: 모든 날짜는 `YYYY-MM-DD` 형식 (ISO 8601)을 사용하며, `formatDate` 유틸리티를 활용합니다.

#### 1. 매일 반복 (daily)

**규칙:**
- 기준 날짜에서 `interval`일 후의 날짜들을 생성합니다.
- 예: interval=2이면 격일로 생성

**예시:**
```typescript
// baseEvent.date = '2024-01-31', interval = 1
// 생성: ['2024-02-01', '2024-02-02', '2024-02-03', ...]
```

#### 2. 매주 반복 (weekly)

**규칙:**
- 기준 날짜의 요일을 유지하며, `interval`주 간격으로 생성합니다.
- 예: 수요일 시작이면 항상 수요일에만 생성

**예시:**
```typescript
// baseEvent.date = '2024-01-31' (수요일), interval = 1
// 생성: ['2024-02-07', '2024-02-14', '2024-02-21', ...] (모두 수요일)
```

#### 3. 매월 반복 (monthly)

**규칙:**
- 기준 날짜의 **일(day)**과 정확히 동일한 날짜에만 생성합니다.
- 해당 월에 그 날짜가 존재하지 않으면 **건너뜁니다** (생성하지 않음).
- 예: 31일 시작이면 31일이 있는 달에만 생성 (2월은 건너뜀)

**예시:**
```typescript
// baseEvent.date = '2024-01-31', interval = 1
// 생성: ['2024-03-31', '2024-05-31', '2024-07-31', ...] (2월, 4월, 6월 등은 제외)
```

**Edge Case - 29/30일:**
```typescript
// baseEvent.date = '2024-01-30', interval = 1
// 생성: ['2024-03-30', '2024-04-30', '2024-05-30', ...] (2월 제외)

// baseEvent.date = '2024-01-29', interval = 1
// 평년 2월: 건너뜀
// 윤년 2월: '2024-02-29' 생성
```

#### 4. 매년 반복 (yearly)

**규칙:**
- 기준 날짜의 **월-일(MM-DD)**과 정확히 동일한 날짜에만 생성합니다.
- 해당 연도에 그 날짜가 존재하지 않으면 **건너뜁니다**.
- 윤년의 2월 29일은 다음 윤년까지 건너뜁니다.

**예시:**
```typescript
// baseEvent.date = '2024-02-29' (윤년), interval = 1
// 생성: ['2028-02-29', '2032-02-29', '2036-02-29', ...] (2025~2027은 제외)
```

#### 5. 종료 조건

생성은 다음 조건 중 **먼저 만족하는 조건**에서 중단됩니다:

1. `baseEvent.repeat.endDate`가 설정된 경우, 해당 날짜를 초과하는 일정은 생성하지 않습니다.
2. `maxOccurrences` 개수에 도달한 경우
3. 계산 중 유효하지 않은 날짜가 발생한 경우 (드물지만 안전장치)

### 에러 처리

```typescript
// 1. 필수 입력 누락
{ success: false, events: [], error: '기준 일정이 필요합니다' }

// 2. 유효하지 않은 날짜 형식
{ success: false, events: [], error: '유효하지 않은 날짜 형식입니다' }

// 3. interval이 1 미만
{ success: false, events: [], error: '반복 간격은 1 이상이어야 합니다' }

// 4. maxOccurrences 범위 초과
{ success: false, events: [], error: '최대 생성 개수는 1~365 범위여야 합니다' }

// 5. repeat.type이 'none'인 경우 (에러 아님)
{ success: true, events: [], warning: '반복 설정이 없습니다' }
```

### 엣지 케이스

1. **윤년 2월 29일 (매월):**
   - 평년: 건너뜀
   - 윤년: 생성

2. **윤년 2월 29일 (매년):**
   - 다음 윤년까지 건너뜀 (4년 또는 8년 후)

3. **31일 (매월):**
   - 1, 3, 5, 7, 8, 10, 12월에만 생성
   - 2, 4, 6, 9, 11월은 건너뜀

4. **endDate가 baseEvent.date보다 이전:**
   - 빈 배열 반환 (경고 메시지 포함)

5. **interval이 매우 큰 경우:**
   - 정상 동작하되, maxOccurrences 제한에 의해 조기 종료 가능

## 테스트 시나리오

### 정상 케이스

**1. 매일 반복 - 기본 (interval=1)**

```typescript
describe('generateRecurringEvents - daily', () => {
  it('should generate daily events with interval 1', () => {
    // Arrange
    const baseEvent: EventForm = {
      title: '매일 운동',
      date: '2024-01-31',
      startTime: '07:00',
      endTime: '08:00',
      description: '',
      location: '헬스장',
      category: '개인',
      repeat: { type: 'daily', interval: 1, endDate: '2024-02-03' },
      notificationTime: 10
    };

    // Act
    const result = generateRecurringEvents({ baseEvent, maxOccurrences: 100 });

    // Assert
    expect(result.success).toBe(true);
    expect(result.events).toHaveLength(3);
    expect(result.events[0].date).toBe('2024-02-01');
    expect(result.events[1].date).toBe('2024-02-02');
    expect(result.events[2].date).toBe('2024-02-03');
    expect(result.events[0].title).toBe('매일 운동');
    expect(result.events[0].repeat.type).toBe('none');
  });
});
```

**2. 매주 반복 - 요일 유지**

```typescript
it('should generate weekly events on the same day of week', () => {
  // Arrange - 2024-01-31은 수요일
  const baseEvent: EventForm = {
    title: '주간 회의',
    date: '2024-01-31',
    startTime: '10:00',
    endTime: '11:00',
    description: '',
    location: '',
    category: '업무',
    repeat: { type: 'weekly', interval: 1, endDate: '2024-02-21' },
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events).toHaveLength(3);
  expect(result.events[0].date).toBe('2024-02-07'); // 수요일
  expect(result.events[1].date).toBe('2024-02-14'); // 수요일
  expect(result.events[2].date).toBe('2024-02-21'); // 수요일
});
```

**3. 매월 반복 - 31일 (2월 건너뜀)**

```typescript
it('should skip months that do not have the base day (31st)', () => {
  // Arrange
  const baseEvent: EventForm = {
    title: '월말 정산',
    date: '2024-01-31',
    startTime: '18:00',
    endTime: '19:00',
    description: '',
    location: '',
    category: '업무',
    repeat: { type: 'monthly', interval: 1, endDate: '2024-07-31' },
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events.map(e => e.date)).toEqual([
    '2024-03-31', // 3월 (31일 있음)
    '2024-05-31', // 5월 (31일 있음)
    '2024-07-31'  // 7월 (31일 있음)
    // 2월, 4월, 6월은 31일이 없으므로 제외
  ]);
});
```

**4. 매년 반복 - 윤년 2월 29일**

```typescript
it('should generate yearly events only on leap years for Feb 29', () => {
  // Arrange - 2024는 윤년
  const baseEvent: EventForm = {
    title: '윤년 기념일',
    date: '2024-02-29',
    startTime: '12:00',
    endTime: '13:00',
    description: '',
    location: '',
    category: '개인',
    repeat: { type: 'yearly', interval: 1 },
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent, maxOccurrences: 3 });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events).toHaveLength(3);
  expect(result.events[0].date).toBe('2028-02-29'); // 다음 윤년
  expect(result.events[1].date).toBe('2032-02-29'); // 그 다음 윤년
  expect(result.events[2].date).toBe('2036-02-29');
  // 2025, 2026, 2027은 평년이므로 제외
});
```

### 예외 케이스

**1. 입력 검증 - baseEvent 누락**

```typescript
describe('generateRecurringEvents - validation', () => {
  it('should return error when baseEvent is null', () => {
    // Act
    const result = generateRecurringEvents({ baseEvent: null as any });

    // Assert
    expect(result.success).toBe(false);
    expect(result.error).toBe('기준 일정이 필요합니다');
    expect(result.events).toEqual([]);
  });
});
```

**2. 입력 검증 - 유효하지 않은 날짜**

```typescript
it('should return error when date format is invalid', () => {
  // Arrange
  const baseEvent: EventForm = {
    title: 'Test',
    date: 'invalid-date',
    startTime: '10:00',
    endTime: '11:00',
    description: '',
    location: '',
    category: '업무',
    repeat: { type: 'daily', interval: 1 },
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent });

  // Assert
  expect(result.success).toBe(false);
  expect(result.error).toBe('유효하지 않은 날짜 형식입니다');
});
```

**3. repeat.type이 'none'**

```typescript
it('should return empty array with warning when repeat type is none', () => {
  // Arrange
  const baseEvent: EventForm = {
    title: 'Test',
    date: '2024-01-31',
    startTime: '10:00',
    endTime: '11:00',
    description: '',
    location: '',
    category: '업무',
    repeat: { type: 'none', interval: 1 },
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events).toEqual([]);
  expect(result.warning).toBe('반복 설정이 없습니다');
});
```

### 엣지 케이스

**1. interval > 1 (격주)**

```typescript
describe('generateRecurringEvents - edge cases', () => {
  it('should handle interval greater than 1 for weekly', () => {
    // Arrange
    const baseEvent: EventForm = {
      title: '격주 회의',
      date: '2024-01-31', // 수요일
      startTime: '10:00',
      endTime: '11:00',
      description: '',
      location: '',
      category: '업무',
      repeat: { type: 'weekly', interval: 2, endDate: '2024-03-31' },
      notificationTime: 10
    };

    // Act
    const result = generateRecurringEvents({ baseEvent });

    // Assert
    expect(result.success).toBe(true);
    expect(result.events[0].date).toBe('2024-02-14'); // 2주 후
    expect(result.events[1].date).toBe('2024-02-28'); // 4주 후
    expect(result.events[2].date).toBe('2024-03-13'); // 6주 후
    expect(result.events[3].date).toBe('2024-03-27'); // 8주 후
  });
});
```

**2. maxOccurrences 제한**

```typescript
it('should stop at maxOccurrences limit', () => {
  // Arrange
  const baseEvent: EventForm = {
    title: '매일 알림',
    date: '2024-01-01',
    startTime: '09:00',
    endTime: '09:30',
    description: '',
    location: '',
    category: '개인',
    repeat: { type: 'daily', interval: 1, endDate: '2025-12-31' }, // 2년치
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent, maxOccurrences: 50 });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events).toHaveLength(50); // endDate 이전이지만 maxOccurrences에서 중단
});
```

**3. endDate가 baseEvent.date보다 이전**

```typescript
it('should return empty array when endDate is before baseDate', () => {
  // Arrange
  const baseEvent: EventForm = {
    title: 'Test',
    date: '2024-12-31',
    startTime: '10:00',
    endTime: '11:00',
    description: '',
    location: '',
    category: '업무',
    repeat: { type: 'daily', interval: 1, endDate: '2024-01-01' }, // 과거
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events).toEqual([]);
  expect(result.warning).toBe('종료일이 시작일보다 이전입니다');
});
```

**4. 매월 반복 - 윤년 2월 29일**

```typescript
it('should generate Feb 29 only in leap years for monthly repeat', () => {
  // Arrange - 2024는 윤년
  const baseEvent: EventForm = {
    title: '월말 회의',
    date: '2024-01-29',
    startTime: '15:00',
    endTime: '16:00',
    description: '',
    location: '',
    category: '업무',
    repeat: { type: 'monthly', interval: 1, endDate: '2024-04-30' },
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events.map(e => e.date)).toEqual([
    '2024-02-29', // 윤년이므로 29일 생성
    '2024-03-29',
    '2024-04-29'
  ]);
});
```

**5. 연도 경계 넘기**

```typescript
it('should handle year boundaries correctly', () => {
  // Arrange
  const baseEvent: EventForm = {
    title: '주간 보고',
    date: '2024-12-30', // 월요일
    startTime: '14:00',
    endTime: '15:00',
    description: '',
    location: '',
    category: '업무',
    repeat: { type: 'weekly', interval: 1, endDate: '2025-01-27' },
    notificationTime: 10
  };

  // Act
  const result = generateRecurringEvents({ baseEvent });

  // Assert
  expect(result.success).toBe(true);
  expect(result.events.map(e => e.date)).toEqual([
    '2025-01-06',
    '2025-01-13',
    '2025-01-20',
    '2025-01-27'
  ]);
});
```

## 통합 가이드

### 기존 코드와의 관계

**사용할 기존 유틸:**
- `formatDate(date: Date, day?: number): string` - 날짜를 YYYY-MM-DD 형식으로 변환 (src/utils/dateUtils.ts:104)
- `getDaysInMonth(year: number, month: number): number` - 특정 월의 일수 계산 (src/utils/dateUtils.ts:6)

**연관된 컴포넌트:**
- `App.tsx` - 일정 저장 로직과 통합
- `useEventOperations` - `saveEvent` 함수를 통한 실제 저장
- `useEventForm` - 반복 설정 UI에서 입력받은 값 전달

### 사용 예시

```typescript
import { generateRecurringEvents } from './utils/recurringUtils';
import { useEventOperations } from './hooks/useEventOperations';

function ScheduleManager() {
  const { saveEvent } = useEventOperations(false);

  const handleCreateRecurringEvents = async (baseEvent: EventForm) => {
    // 1. 반복 일정 생성 (순수 계산)
    const result = generateRecurringEvents({
      baseEvent,
      maxOccurrences: 100
    });

    // 2. 에러 처리
    if (!result.success) {
      console.error(result.error);
      return;
    }

    // 3. 경고 표시
    if (result.warning) {
      console.warn(result.warning);
    }

    // 4. 생성된 일정들을 개별적으로 저장
    for (const event of result.events) {
      await saveEvent(event);
    }

    console.log(`${result.events.length}개의 반복 일정이 생성되었습니다.`);
  };

  // ...
}
```

## 성능 고려사항

1. **최대 생성 개수 제한:**
   - 기본값: 100개
   - 최대값: 365개 (1년치)
   - 이유: 무한 반복 방지 및 메모리 절약

2. **날짜 계산 최적화:**
   - `Date` 객체 생성을 최소화
   - `getDaysInMonth` 유틸리티 재사용

3. **조기 종료:**
   - endDate 또는 maxOccurrences에 도달하면 즉시 중단
   - 유효하지 않은 날짜 패턴이 감지되면 중단

## 구현 우선순위

1. **Phase 1 (MVP):**
   - `generateRecurringEvents` - daily, weekly만 지원
   - 기본 입력 검증
   - 간단한 테스트

2. **Phase 2:**
   - monthly, yearly 추가
   - 엣지 케이스 처리 (윤년, 31일)
   - 완전한 테스트 커버리지

3. **Phase 3 (Optional):**
   - `getNextRecurringDate` - 단일 날짜 계산 유틸리티
   - `isValidRecurringDate` - 날짜 검증 유틸리티
   - 성능 최적화

## 테스트 파일 위치

**파일명:** `src/__tests__/unit/medium.recurringUtils.spec.ts`

**난이도:** Medium (복잡한 날짜 계산 로직 포함)
```

---

**주요 개선 사항 요약:**

1. **프로젝트 통합성**: 기존 타입(`Event`, `RepeatInfo`) 재사용, `formatDate`/`getDaysInMonth` 유틸리티 활용
2. **명확성**: 함수 시그니처, 입출력 타입, JSDoc 주석 명확히 정의
3. **완전성**: interval, endDate, maxOccurrences 처리, 에러 처리, 엣지 케이스 추가
4. **테스트 가능성**: Vitest + Arrange-Act-Assert 패턴, 구체적인 테스트 케이스 작성
5. **일관성**: Function declaration 스타일, 프로젝트 네이밍 컨벤션 준수
6. **성능**: maxOccurrences 제한, 조기 종료 조건, 날짜 계산 최적화
