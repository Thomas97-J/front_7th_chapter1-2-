## 테스트 스위트: 반복 일정 생성 로직 (Schedule Recurring Rule)

### 🎯 테스트 전략
- **테스트 프레임워크**: Vitest
- **격리 수준**: 순수 함수 단위 테스트 (외부 의존성 없음)
- **패턴**: AAA (Arrange-Act-Assert)

---

## 📦 1. 매일 반복 (Daily Recurrence)

### 테스트 케이스 1.1
- **이름**: `should generate next day when repeat type is daily`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매일`
- **When**: 다음 반복 일정을 생성할 때
- **Then**: `2024-02-01`이 반환되어야 함
- **Kent Beck 원칙**: Start Small - 가장 기본적인 매일 반복 동작 검증

---

### 테스트 케이스 1.2
- **이름**: `should generate consecutive daily schedules correctly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매일`
- **When**: 3회 연속 반복 일정을 생성할 때
- **Then**: `['2024-02-01', '2024-02-02', '2024-02-03']`이 반환되어야 함
- **Kent Beck 원칙**: Grow Step by Step - 반복 생성 로직의 정확성 검증

---

### 테스트 케이스 1.3
- **이름**: `should handle month boundary correctly in daily recurrence`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매일`
- **When**: 월 경계를 넘어 연속 생성할 때
- **Then**: `2024-02-01`로 올바르게 월이 증가해야 함
- **Kent Beck 원칙**: Edge Cases - 월 경계 처리 검증

---

### 테스트 케이스 1.4
- **이름**: `should handle year boundary correctly in daily recurrence`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-12-31`이고 반복 유형이 `매일`
- **When**: 다음 반복 일정을 생성할 때
- **Then**: `2025-01-01`로 올바르게 연도가 증가해야 함
- **Kent Beck 원칙**: Edge Cases - 연도 경계 처리 검증

---

## 📅 2. 매주 반복 (Weekly Recurrence)

### 테스트 케이스 2.1
- **이름**: `should generate same weekday when repeat type is weekly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31 (수요일)`이고 반복 유형이 `매주`
- **When**: 다음 반복 일정을 생성할 때
- **Then**: `2024-02-07 (수요일)`이 반환되어야 함
- **Kent Beck 원칙**: Single Responsibility - 요일 유지 검증

---

### 테스트 케이스 2.2
- **이름**: `should generate consecutive weekly schedules with same weekday`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31 (수요일)`이고 반복 유형이 `매주`
- **When**: 3회 연속 반복 일정을 생성할 때
- **Then**: `['2024-02-07', '2024-02-14', '2024-02-21']`이 반환되고 모두 수요일이어야 함
- **Kent Beck 원칙**: Eliminate Duplication - 일관된 요일 유지 검증

---

### 테스트 케이스 2.3
- **이름**: `should handle month boundary in weekly recurrence`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-31 (수요일)`이고 반복 유형이 `매주`
- **When**: 월을 넘어가는 반복 일정을 생성할 때
- **Then**: 정확히 7일 간격으로 생성되며 요일이 유지되어야 함
- **Kent Beck 원칙**: Predictable Tests - 월 경계에서도 일관된 동작

---

### 테스트 케이스 2.4
- **이름**: `should handle year boundary in weekly recurrence`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-12-25 (수요일)`이고 반복 유형이 `매주`
- **When**: 연도를 넘어가는 반복 일정을 생성할 때
- **Then**: `2025-01-01 (수요일)`로 올바르게 생성되어야 함
- **Kent Beck 원칙**: Edge Cases - 연도 경계 처리

---

## 📆 3. 매월 반복 (Monthly Recurrence) - 핵심 로직

### 테스트 케이스 3.1
- **이름**: `should generate same date of month when repeat type is monthly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매월`
- **When**: 다음 반복 일정을 생성할 때
- **Then**: 2월에는 31일이 없으므로 건너뛰고 `2024-03-31`이 반환되어야 함
- **Kent Beck 원칙**: Single Responsibility - 특정 날짜 유지 원칙 검증
- **중요**: 매월 마지막 날이 아닌 "31일"에만 생성

---

### 테스트 케이스 3.2
- **이름**: `should skip months without the target day in monthly recurrence`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매월`
- **When**: 연속 반복 일정을 생성할 때
- **Then**: `['2024-03-31', '2024-05-31', '2024-07-31']` - 2월, 4월, 6월은 건너뜀
- **Kent Beck 원칙**: Readable Tests - 명확한 건너뛰기 로직 검증

---

### 테스트 케이스 3.3
- **이름**: `should handle regular months correctly in monthly recurrence from day 31`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매월`
- **When**: 1년간 반복 일정을 생성할 때
- **Then**: `['2024-03-31', '2024-05-31', '2024-07-31', '2024-08-31', '2024-10-31', '2024-12-31']` (7개월만 생성)
- **Kent Beck 원칙**: Comprehensive Validation - 전체 연간 패턴 검증

---

### 테스트 케이스 3.4
- **이름**: `should generate monthly schedules from day 15 without skipping`
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-15`이고 반복 유형이 `매월`
- **When**: 3회 연속 반복 일정을 생성할 때
- **Then**: `['2024-02-15', '2024-03-15', '2024-04-15']` - 모든 월에 15일이 있으므로 건너뛰지 않음
- **Kent Beck 원칙**: Eliminate Duplication - 일반적인 날짜의 정상 동작 확인

---

### 테스트 케이스 3.5
- **이름**: `should handle 30th day monthly recurrence correctly`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-30`이고 반복 유형이 `매월`
- **When**: 3회 연속 반복 일정을 생성할 때
- **Then**: `['2024-03-30', '2024-04-30', '2024-05-30']` - 2월(28일)은 건너뜀
- **Kent Beck 원칙**: Edge Cases - 30일 경계 케이스

---

### 테스트 케이스 3.6
- **이름**: `should handle February 29 in leap year for monthly recurrence`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-29`이고 반복 유형이 `매월`
- **When**: 3회 연속 반복 일정을 생성할 때
- **Then**: `['2024-02-29', '2024-03-29', '2024-04-29']` - 윤년이므로 2/29 포함
- **Kent Beck 원칙**: Edge Cases - 윤년 처리

---

## 🗓️ 4. 매년 반복 (Yearly Recurrence) - 윤년 로직

### 테스트 케이스 4.1
- **이름**: `should generate same date next year when repeat type is yearly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-02-29 (윤년)`이고 반복 유형이 `매년`
- **When**: 다음 반복 일정을 생성할 때
- **Then**: 2025~2027년은 윤년이 아니므로 건너뛰고 `2028-02-29`가 반환되어야 함
- **Kent Beck 원칙**: Single Responsibility - 특정 날짜 유지 원칙 검증
- **중요**: 2월 29일에만 생성되며, 평년은 건너뜀

---

### 테스트 케이스 4.2
- **이름**: `should skip non-leap years when starting from February 29`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-02-29`이고 반복 유형이 `매년`
- **When**: 3회 연속 반복 일정을 생성할 때
- **Then**: `['2028-02-29', '2032-02-29', '2036-02-29']` - 모두 윤년
- **Kent Beck 원칙**: Predictable Tests - 윤년 주기 검증 (4년 간격)

---

### 테스트 케이스 4.3
- **이름**: `should generate yearly schedules without skipping for regular dates`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매년`
- **When**: 3회 연속 반복 일정을 생성할 때
- **Then**: `['2025-01-31', '2026-01-31', '2027-01-31']` - 매년 연속 생성
- **Kent Beck 원칙**: Readable Tests - 일반적인 날짜의 정상 동작 확인

---

### 테스트 케이스 4.4
- **이름**: `should handle century leap year correctly`
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 `2096-02-29 (윤년)`이고 반복 유형이 `매년`
- **When**: 다음 반복 일정을 생성할 때
- **Then**: `2100-02-29`는 건너뛰고 (100의 배수지만 400의 배수 아님) `2104-02-29`가 반환되어야 함
- **Kent Beck 원칙**: Edge Cases - 세기 윤년 규칙 검증 (400년 규칙)

---

### 테스트 케이스 4.5
- **이름**: `should handle year 2000 as leap year correctly`
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 `1996-02-29`이고 반복 유형이 `매년`
- **When**: 다음 반복 일정을 생성할 때
- **Then**: `2000-02-29`가 반환되어야 함 (2000은 400의 배수이므로 윤년)
- **Kent Beck 원칙**: Edge Cases - 400년 규칙 예외 검증

---

## 🔀 5. 일정 겹침 처리

### 테스트 케이스 5.1
- **이름**: `should allow duplicate schedules on same date`
- **타입**: integration
- **우선순위**: high
- **Given**: 이미 `2024-02-01`에 일정이 존재
- **When**: `2024-01-31` 시작 매일 반복 일정을 생성할 때
- **Then**: `2024-02-01`에 중복 생성이 허용되어야 함
- **Kent Beck 원칙**: Single Responsibility - 겹침 체크 안 함을 명시적으로 검증

---

### 테스트 케이스 5.2
- **이름**: `should not check for existing schedules during recurrence generation`
- **타입**: unit
- **우선순위**: medium
- **Given**: 반복 일정 생성 함수가 호출될 때
- **When**: 일정 목록 조회 함수가 존재하더라도
- **Then**: 일정 조회 함수가 호출되지 않아야 함 (Mock 검증)
- **Kent Beck 원칙**: Predictable Tests - 의존성 격리 검증
- **Mocking 필요**: 일정 조회 함수 Mock으로 호출 여부 확인

---

## 🛠️ 6. 입력 유효성 및 예외 처리

### 테스트 케이스 6.1
- **이름**: `should throw error when start date is invalid`
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일이 `invalid-date`
- **When**: 반복 일정을 생성할 때
- **Then**: 에러가 발생해야 함
- **Kent Beck 원칙**: Start Small - 기본 입력 검증

---

### 테스트 케이스 6.2
- **이름**: `should throw error when repeat type is invalid`
- **타입**: edge
- **우선순위**: high
- **Given**: 반복 유형이 `invalid-type`
- **When**: 반복 일정을 생성할 때
- **Then**: 에러가 발생해야 함
- **Kent Beck 원칙**: Single Responsibility - 타입 검증

---

### 테스트 케이스 6.3
- **이름**: `should return empty array when count is zero`
- **타입**: edge
- **우선순위**: medium
- **Given**: 반복 횟수가 `0`
- **When**: 반복 일정을 생성할 때
- **Then**: 빈 배열 `[]`이 반환되어야 함
- **Kent Beck 원칙**: Edge Cases - 경계값 처리

---

### 테스트 케이스 6.4
- **이름**: `should return single date when count is one`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-31`, 반복 유형이 `매일`, 횟수가 `1`
- **When**: 반복 일정을 생성할 때
- **Then**: `['2024-02-01']` 하나만 반환되어야 함
- **Kent Beck 원칙**: Edge Cases - 최소값 처리

---

## 🧪 7. 날짜 형식 검증

### 테스트 케이스 7.1
- **이름**: `should return dates in ISO 8601 format`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`이고 반복 유형이 `매일`
- **When**: 반복 일정을 생성할 때
- **Then**: 모든 날짜가 `YYYY-MM-DD` 형식이어야 함
- **Kent Beck 원칙**: Name Clearly - 명확한 형식 검증

---

### 테스트 케이스 7.2
- **이름**: `should pad single digit months and days with zero`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-09`이고 반복 유형이 `매일`
- **When**: 반복 일정을 생성할 때
- **Then**: `2024-01-10` 형태로 0 패딩이 적용되어야 함
- **Kent Beck 원칙**: Eliminate Duplication - 일관된 형식

---

## 📊 테스트 우선순위 요약

### High Priority (필수)
- 매일/매주/매월/매년 기본 동작 (8개)
- 31일 매월 반복 건너뛰기 (3개)
- 윤년 2/29 매년 반복 건너뛰기 (2개)
- 일정 겹침 허용 (1개)
- 입력 유효성 검증 (2개)
- ISO 8601 형식 (1개)

### Medium Priority (중요)
- 월/연도 경계 처리 (4개)
- 30일, 29일 특수 케이스 (2개)
- 빈 배열/단일 결과 (2개)

### Low Priority (선택)
- 세기 윤년 규칙 (2개)

---

## 🧩 테스트 구현 가이드

### Mock/Stub 전략
- **일정 조회 함수**: vi.fn()으로 Mock 생성, 호출 여부만 확인
- **날짜 라이브러리**: 실제 Date 객체 사용 (외부 의존성 아님)

### 테스트 데이터 패턴
```typescript
// Arrange: 테스트 데이터 준비
const startDate = '2024-01-31'
const repeatType = 'daily'
const count = 3

// Act: 함수 실행
const result = generateRecurringSchedules(startDate, repeatType, count)

// Assert: 결과 검증
expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03'])
```

### 윤년 판별 로직
```typescript
// 400의 배수: 윤년
// 100의 배수 (but not 400): 평년
// 4의 배수 (but not 100): 윤년
// 그 외: 평년
```

---

## ✅ 테스트 설계 완료

총 **28개 테스트 케이스** 설계 완료:
- Unit Tests: 18개
- Integration Tests: 1개
- Edge Cases: 9개

모든 테스트는 Kent Beck의 TDD 원칙을 따르며, AAA 패턴으로 작성되어 있습니다.
