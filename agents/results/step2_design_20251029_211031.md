검증된 명세를 바탕으로 포괄적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (Date Range Validator)

### Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate와 endDate가 모두 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-12-31', endDate는 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후입니다' }` 반환

### Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 `new Date('2024-01-01')`, endDate는 `new Date('2024-12-31')`
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01T00:00:00Z', endDate는 '2024-12-31T23:59:59Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 6
- **이름**: should accept mixed Date object and ISO string
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate는 `new Date('2024-01-01')`, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

### Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 null, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 8
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 9
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 undefined, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 10
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일이 유효하지 않습니다' }` 반환

#### 테스트 케이스 11
- **이름**: should return error when start date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 'invalid-date', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 12
- **이름**: should return error when end date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 'not-a-date'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 13
- **이름**: should return error when both dates are invalid
- **타입**: unit
- **우선순위**: medium
- **Given**: startDate는 null, endDate는 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 유효하지 않습니다' }` 반환 (첫 번째 에러 우선)

### Edge Cases - 경계값

#### 테스트 케이스 14
- **이름**: should return valid when dates differ by exactly 1 day
- **타입**: edge
- **우선순위**: high
- **Given**: startDate는 '2024-01-01', endDate는 '2024-01-02'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates differ by over 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '1900-01-01', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 16
- **이름**: should return valid when dates are exactly 100 years apart
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '1924-01-01', endDate는 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환 (정확히 100년은 경고 없음)

#### 테스트 케이스 17
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2024-02-29', endDate는 '2024-03-01' (윤년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 18
- **이름**: should return error for invalid leap year date
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2023-02-29', endDate는 '2023-03-01' (평년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 19
- **이름**: should handle dates at year boundaries
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2023-12-31T23:59:59', endDate는 '2024-01-01T00:00:00'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 20
- **이름**: should handle very old dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '1900-01-01', endDate는 '1900-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 21
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 '2100-01-01', endDate는 '2100-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 22
- **이름**: should handle same date with different time zones
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '2024-01-01T00:00:00+09:00', endDate는 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후입니다' }` 반환 (또는 UTC 기준으로 비교)

### Edge Cases - 특수 입력

#### 테스트 케이스 23
- **이름**: should handle empty string input
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 '', endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

#### 테스트 케이스 24
- **이름**: should handle numeric timestamp input
- **타입**: edge
- **우선순위**: low
- **Given**: startDate는 1704067200000 (timestamp), endDate는 1735689599000
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환 (명세에 명시되지 않은 형식)

#### 테스트 케이스 25
- **이름**: should handle Invalid Date object
- **타입**: edge
- **우선순위**: medium
- **Given**: startDate는 `new Date('invalid')`, endDate는 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }` 반환

### Integration Tests

#### 테스트 케이스 26
- **이름**: should integrate with date picker component
- **타입**: integration
- **우선순위**: high
- **Given**: 사용자가 날짜 선택 컴포넌트에서 시작일과 종료일을 선택
- **When**: validateDateRange가 선택된 값으로 호출될 때
- **Then**: 컴포넌트에 검증 결과가 표시됨

#### 테스트 케이스 27
- **이름**: should integrate with form validation
- **타입**: integration
- **우선순위**: high
- **Given**: 폼에 날짜 범위 입력 필드가 있고 검증 로직이 연결됨
- **When**: 사용자가 잘못된 날짜 범위를 입력하고 제출할 때
- **Then**: 폼 제출이 차단되고 에러 메시지가 표시됨

#### 테스트 케이스 28
- **이름**: should handle sequential validation calls
- **타입**: integration
- **우선순위**: medium
- **Given**: 여러 날짜 범위를 순차적으로 검증해야 하는 상황
- **When**: validateDateRange가 여러 번 연속으로 호출될 때
- **Then**: 각 호출이 독립적으로 올바른 결과를 반환

---

## 테스트 구현 가이드

### 테스트 파일 구조
```
src/__tests__/
  ├── unit/
  │   ├── validateDateRange.test.ts
  │   └── dateParser.test.ts
  ├── integration/
  │   └── dateRangeForm.test.tsx
  └── edge-cases/
      └── dateRangeBoundaries.test.ts
```

### 우선순위별 실행 순서
1. **High 우선순위** (18개): 핵심 기능과 주요 에러 처리
2. **Medium 우선순위** (8개): 입력 형식 변형과 경계값
3. **Low 우선순위** (2개): 특수 케이스와 확장 기능

### 테스트 커버리지 목표
- 라인 커버리지: 100%
- 브랜치 커버리지: 100%
- 함수 커버리지: 100%

이 테스트 케이스 설계를 바탕으로 실제 테스트 코드를 작성하시겠습니까?
