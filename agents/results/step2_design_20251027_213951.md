프로젝트 구조를 파악했습니다. Vitest를 사용하고 있으며, `src/__tests__/unit/` 디렉토리에 테스트를 작성하고 있네요. 이제 날짜 범위 검증 함수에 대한 포괄적인 테스트 케이스를 설계하겠습니다.

---

# 테스트 스위트: 날짜 범위 검증 함수 (Date Range Validation)

## 테스트 케이스 설계

### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 유효한 시작일(2024-01-01)과 종료일(2024-01-10)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: edge
- **우선순위**: high
- **Given**: 동일한 시작일과 종료일(2024-01-01)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 종료일보다 늦은 경우(시작: 2024-01-10, 종료: 2024-01-01)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "시작일은 종료일보다 이전이어야 합니다" }` 반환

---

### 테스트 케이스 4
- **이름**: should return valid when accepting Date objects
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 전달된 시작일과 종료일
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 5
- **이름**: should return valid when accepting ISO 8601 string format
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 형식의 문자열("2024-01-01T00:00:00Z")
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 6
- **이름**: should return error when start date is null
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일이 null, 종료일은 유효한 날짜
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "시작일이 유효하지 않습니다" }` 반환

---

### 테스트 케이스 7
- **이름**: should return error when end date is null
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일은 유효한 날짜, 종료일이 null
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "종료일이 유효하지 않습니다" }` 반환

---

### 테스트 케이스 8
- **이름**: should return error when start date is undefined
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 undefined, 종료일은 유효한 날짜
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "시작일이 유효하지 않습니다" }` 반환

---

### 테스트 케이스 9
- **이름**: should return error when end date is undefined
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일은 유효한 날짜, 종료일이 undefined
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "종료일이 유효하지 않습니다" }` 반환

---

### 테스트 케이스 10
- **이름**: should return error when start date has invalid format
- **타입**: edge
- **우선순위**: high
- **Given**: 잘못된 날짜 형식의 시작일("invalid-date")
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "시작일 형식이 올바르지 않습니다" }` 반환

---

### 테스트 케이스 11
- **이름**: should return error when end date has invalid format
- **타입**: edge
- **우선순위**: high
- **Given**: 잘못된 날짜 형식의 종료일("not-a-date")
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "종료일 형식이 올바르지 않습니다" }` 반환

---

### 테스트 케이스 12
- **이름**: should return valid when dates have 1 day difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 1일 차이 나는 시작일(2024-01-01)과 종료일(2024-01-02)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 13
- **이름**: should return valid with warning when dates have more than 100 years difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 100년 이상 차이 나는 날짜(시작: 1900-01-01, 종료: 2024-01-01)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true, warning: "100년 이상의 기간입니다" }` 반환

---

### 테스트 케이스 14
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 윤년의 2월 29일을 포함한 날짜 범위(2024-02-29)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 15
- **이름**: should return error for non-leap year February 29th
- **타입**: edge
- **우선순위**: low
- **Given**: 윤년이 아닌 해의 2월 29일(2023-02-29)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "시작일 형식이 올바르지 않습니다" }` 반환

---

### 테스트 케이스 16
- **이름**: should handle dates across year boundaries
- **타입**: unit
- **우선순위**: medium
- **Given**: 연도를 넘어가는 날짜 범위(시작: 2023-12-31, 종료: 2024-01-01)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 17
- **이름**: should handle dates with time component in ISO format
- **타입**: unit
- **우선순위**: medium
- **Given**: 시간 정보를 포함한 ISO 8601 문자열
- **When**: validateDateRange 함수를 호출
- **Then**: 날짜 부분만 비교하여 유효성 검증

---

### 테스트 케이스 18
- **이름**: should return error when both dates are null
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일과 종료일 모두 null
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "시작일과 종료일이 유효하지 않습니다" }` 반환

---

### 테스트 케이스 19
- **이름**: should handle mixed input types (Date and string)
- **타입**: integration
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 ISO 문자열
- **When**: validateDateRange 함수를 호출
- **Then**: 두 형식을 모두 처리하여 `{ isValid: true }` 반환

---

### 테스트 케이스 20
- **이름**: should return error when date string is empty
- **타입**: edge
- **우선순위**: medium
- **Given**: 빈 문자열("")로 전달된 날짜
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: false, error: "날짜가 비어있습니다" }` 반환

---

### 테스트 케이스 21
- **이름**: should handle dates at the edge of Unix timestamp range
- **타입**: edge
- **우선순위**: low
- **Given**: Unix timestamp 범위 경계의 날짜(1970-01-01, 2038-01-19)
- **When**: validateDateRange 함수를 호출
- **Then**: `{ isValid: true }` 반환

---

### 테스트 케이스 22
- **이름**: should handle dates with timezone information
- **타입**: unit
- **우선순위**: low
- **Given**: 타임존 정보를 포함한 ISO 8601 문자열(UTC, KST 등)
- **When**: validateDateRange 함수를 호출
- **Then**: UTC 기준으로 변환하여 비교, `{ isValid: true/false }` 반환

---

## 테스트 구현 예시 (TypeScript + Vitest)

```typescript
// src/__tests__/unit/easy.dateRangeValidation.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/dateRangeValidation';

describe('validateDateRange >', () => {
  describe('정상 케이스', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-10');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should return valid when start date equals end date', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-01');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should return valid when accepting ISO 8601 string format', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00Z';
      const endDate = '2024-01-10T00:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });

  describe('에러 처리', () => {
    it('should return invalid when start date is after end date', () => {
      // Arrange
      const startDate = new Date('2024-01-10');
      const endDate = new Date('2024-01-01');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일은 종료일보다 이전이어야 합니다',
      });
    });

    it('should return error when start date is null', () => {
      // Arrange
      const startDate = null;
      const endDate = new Date('2024-01-10');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일이 유효하지 않습니다',
      });
    });

    it('should return error when start date has invalid format', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-01-10';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일 형식이 올바르지 않습니다',
      });
    });
  });

  describe('엣지 케이스', () => {
    it('should return valid when dates have 1 day difference', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-02');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should return valid with warning when dates have more than 100 years difference', () => {
      // Arrange
      const startDate = new Date('1900-01-01');
      const endDate = new Date('2024-01-01');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({
        isValid: true,
        warning: '100년 이상의 기간입니다',
      });
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = new Date('2024-02-29');
      const endDate = new Date('2024-03-01');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should handle dates across year boundaries', () => {
      // Arrange
      const startDate = new Date('2023-12-31');
      const endDate = new Date('2024-01-01');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });

  describe('통합 테스트', () => {
    it('should handle mixed input types (Date and string)', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-01-10';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });
});
```

---

## 테스트 커버리지 목표

- **라인 커버리지**: 100%
- **브랜치 커버리지**: 100%
- **함수 커버리지**: 100%
- **Statement 커버리지**: 100%

---

## 추가 고려사항

### 성능 테스트 (선택사항)
- 대량의 날짜 검증 요청에 대한 성능 테스트
- 메모리 누수 검증

### 접근성 테스트 (선택사항)
- React 컴포넌트와 통합 시 에러 메시지가 screen reader에 접근 가능한지 확인

### 국제화 테스트 (선택사항)
- 다양한 로케일에서 날짜 형식 처리
- 다국어 에러 메시지 지원

---

이 테스트 케이스 설계는 AAA 패턴을 따르며, 명확한 의도와 독립성을 갖추고 있습니다. 각 테스트는 하나의 책임만 가지며, 경계값 테스트를 포함하여 견고한 함수 구현을 보장합니다.
