**Step 1: List improvements (brief)**

- Extract duplicate error messages to constants (DRY)
- Combine duplicate date parsing/validation logic
- Extract magic number (100, 365.25) to named constants
- Simplify parseDate function (remove unnecessary try-catch)
- Create helper functions for error/warning results
- Consolidate date validation checks
- Add comprehensive JSDoc comments
- Improve constant naming for clarity

**Step 2: Complete refactored code**

```typescript
// filepath: src/utils/validateDateRange.ts

/**
 * Validation result interface
 */
export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

/**
 * Error message constants
 */
const ERROR_MESSAGES = {
  BOTH_REQUIRED: '시작일과 종료일은 필수입니다',
  START_REQUIRED: '시작일은 필수입니다',
  END_REQUIRED: '종료일은 필수입니다',
  START_INVALID_FORMAT: '시작일 형식이 올바르지 않습니다',
  END_INVALID_FORMAT: '종료일 형식이 올바르지 않습니다',
  START_AFTER_END: '시작일은 종료일보다 이전이어야 합니다',
} as const;

/**
 * Warning thresholds
 */
const WARNING_THRESHOLD = {
  MAX_YEARS: 100,
} as const;

/**
 * Time calculation constants
 */
const TIME_CONSTANTS = {
  MILLISECONDS_PER_YEAR: 1000 * 60 * 60 * 24 * 365.25,
} as const;

/**
 * Validate date range
 * @param startDate - Start date (Date or ISO string)
 * @param endDate - End date (Date or ISO string)
 * @returns Validation result with error or warning if applicable
 */
export function validateDateRange(
  startDate: Date | string | null | undefined,
  endDate: Date | string | null | undefined
): ValidationResult {
  // Check for null/undefined inputs
  const missingInputError = validateInputsPresent(startDate, endDate);
  if (missingInputError) {
    return missingInputError;
  }

  // Parse and validate dates
  const parsedStart = parseDate(startDate);
  if (!parsedStart) {
    return createError(ERROR_MESSAGES.START_INVALID_FORMAT);
  }

  const parsedEnd = parseDate(endDate);
  if (!parsedEnd) {
    return createError(ERROR_MESSAGES.END_INVALID_FORMAT);
  }

  // Compare dates
  if (parsedStart.getTime() > parsedEnd.getTime()) {
    return createError(ERROR_MESSAGES.START_AFTER_END);
  }

  // Check for 100-year warning
  const yearsDiff = calculateYearsDifference(parsedStart, parsedEnd);
  if (yearsDiff > WARNING_THRESHOLD.MAX_YEARS) {
    return createWarning(`날짜 범위가 ${WARNING_THRESHOLD.MAX_YEARS}년을 초과합니다`);
  }

  return { isValid: true };
}

/**
 * Validate that both inputs are present
 * @returns Error result if validation fails, null otherwise
 */
function validateInputsPresent(
  startDate: Date | string | null | undefined,
  endDate: Date | string | null | undefined
): ValidationResult | null {
  if (!startDate && !endDate) {
    return createError(ERROR_MESSAGES.BOTH_REQUIRED);
  }

  if (!startDate) {
    return createError(ERROR_MESSAGES.START_REQUIRED);
  }

  if (!endDate) {
    return createError(ERROR_MESSAGES.END_REQUIRED);
  }

  return null;
}

/**
 * Create error result
 */
function createError(message: string): ValidationResult {
  return { isValid: false, error: message };
}

/**
 * Create warning result
 */
function createWarning(message: string): ValidationResult {
  return { isValid: true, warning: message };
}

/**
 * Parse date from string or Date object
 * @returns Valid Date object or null if invalid
 */
function parseDate(date: Date | string | null | undefined): Date | null {
  if (!date) {
    return null;
  }

  if (date instanceof Date) {
    return isValidDate(date) ? date : null;
  }

  if (typeof date === 'string') {
    const parsed = new Date(date);
    return isValidDate(parsed) ? parsed : null;
  }

  return null;
}

/**
 * Check if date is valid
 */
function isValidDate(date: Date): boolean {
  return date instanceof Date && !isNaN(date.getTime());
}

/**
 * Calculate years difference between two dates
 */
function calculateYearsDifference(start: Date, end: Date): number {
  return (end.getTime() - start.getTime()) / TIME_CONSTANTS.MILLISECONDS_PER_YEAR;
}
```
