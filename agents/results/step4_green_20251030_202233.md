```typescript
// filepath: src/utils/scheduleRecurringRule.ts

/**
 * 반복 유형
 */
export type RepeatType = 'daily' | 'weekly' | 'monthly' | 'yearly';

/**
 * 반복 일정 생성 결과 인터페이스
 */
export interface RecurringDateResult {
  dates: string[];
}

/**
 * 반복 일정 생성 함수
 * 
 * @param startDate - 시작 날짜 (YYYY-MM-DD 형식)
 * @param repeatType - 반복 유형 ('daily' | 'weekly' | 'monthly' | 'yearly')
 * @param count - 생성할 반복 일정 개수
 * @returns 생성된 날짜 배열을 포함한 결과 객체
 */
export function generateRecurringDates(
  startDate: string,
  repeatType: RepeatType,
  count: number
): RecurringDateResult {
  const dates: string[] = [];
  
  if (!startDate || !repeatType || count <= 0) {
    return { dates };
  }

  const baseDate = new Date(startDate);
  
  if (isNaN(baseDate.getTime())) {
    return { dates };
  }

  const startYear = baseDate.getFullYear();
  const startMonth = baseDate.getMonth();
  const startDay = baseDate.getDate();
  const startDayOfWeek = baseDate.getDay();

  switch (repeatType) {
    case 'daily':
      generateDailyDates(baseDate, count, dates);
      break;
      
    case 'weekly':
      generateWeeklyDates(baseDate, count, dates);
      break;
      
    case 'monthly':
      generateMonthlyDates(startYear, startMonth, startDay, count, dates);
      break;
      
    case 'yearly':
      generateYearlyDates(startYear, startMonth, startDay, count, dates);
      break;
  }

  return { dates };
}

/**
 * 매일 반복 일정 생성
 */
function generateDailyDates(
  baseDate: Date,
  count: number,
  dates: string[]
): void {
  for (let i = 1; i <= count; i++) {
    const nextDate = new Date(baseDate);
    nextDate.setDate(baseDate.getDate() + i);
    dates.push(formatDate(nextDate));
  }
}

/**
 * 매주 반복 일정 생성
 */
function generateWeeklyDates(
  baseDate: Date,
  count: number,
  dates: string[]
): void {
  for (let i = 1; i <= count; i++) {
    const nextDate = new Date(baseDate);
    nextDate.setDate(baseDate.getDate() + (i * 7));
    dates.push(formatDate(nextDate));
  }
}

/**
 * 매월 반복 일정 생성
 * 시작일의 일(day)이 해당 월에 존재하는 경우에만 생성
 */
function generateMonthlyDates(
  startYear: number,
  startMonth: number,
  startDay: number,
  count: number,
  dates: string[]
): void {
  let currentYear = startYear;
  let currentMonth = startMonth;
  let generated = 0;
  let attempts = 0;
  const maxAttempts = count * 12; // 최대 12배까지 시도

  while (generated < count && attempts < maxAttempts) {
    attempts++;
    currentMonth++;
    
    if (currentMonth > 11) {
      currentMonth = 0;
      currentYear++;
    }

    // 해당 월에 startDay가 존재하는지 확인
    const daysInMonth = getDaysInMonth(currentYear, currentMonth);
    
    if (startDay <= daysInMonth) {
      const nextDate = new Date(currentYear, currentMonth, startDay);
      dates.push(formatDate(nextDate));
      generated++;
    }
  }
}

/**
 * 매년 반복 일정 생성
 * 시작일의 월/일이 해당 연도에 존재하는 경우에만 생성
 */
function generateYearlyDates(
  startYear: number,
  startMonth: number,
  startDay: number,
  count: number,
  dates: string[]
): void {
  let currentYear = startYear;
  let generated = 0;
  let attempts = 0;
  const maxAttempts = count * 10; // 최대 10배까지 시도

  while (generated < count && attempts < maxAttempts) {
    attempts++;
    currentYear++;

    // 해당 연도에 해당 월/일이 존재하는지 확인
    const daysInMonth = getDaysInMonth(currentYear, startMonth);
    
    if (startDay <= daysInMonth) {
      const nextDate = new Date(currentYear, startMonth, startDay);
      dates.push(formatDate(nextDate));
      generated++;
    }
  }
}

/**
 * 특정 연도/월의 일수 반환
 */
function getDaysInMonth(year: number, month: number): number {
  return new Date(year, month + 1, 0).getDate();
}

/**
 * 윤년 확인
 */
function isLeapYear(year: number): boolean {
  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

/**
 * 날짜를 YYYY-MM-DD 형식으로 포맷팅
 */
function formatDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}
```
