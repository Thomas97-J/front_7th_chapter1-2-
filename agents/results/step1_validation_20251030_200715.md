Perfect! Now I have enough context to validate the specification. Let me create a comprehensive validation report.

---

# ✅ 검증 결과

## 1. 프로젝트 통합성
**평가:** 개선 필요

**발견 사항:**

### 기존 타입 시스템
- ✅ `RepeatType` 타입이 이미 존재: `'daily' | 'weekly' | 'monthly' | 'yearly'`
- ✅ `RepeatInfo` 인터페이스가 이미 존재 (interval, endDate 포함)
- ✅ `Event`와 `EventForm` 인터페이스 존재
- 반복 일정 생성 로직은 **현재 구현되지 않음** (App.tsx:439 주석 참조)

### 중복 가능성
- ✅ 날짜 관련 유틸리티 함수들 존재 (`dateUtils.ts`)
  - `formatDate()`: YYYY-MM-DD 형식 생성
  - `getDaysInMonth()`: 월별 일수 계산
  - `fillZero()`: 0 패딩
- ⚠️ 윤년 처리 로직은 `getDaysInMonth`에 이미 존재

### 권장 파일 위치
- **주 파일:** `src/utils/recurringSchedule.ts` (네이밍 컨벤션 일치)
- **테스트 파일:** `src/__tests__/unit/schedule-recurring-rule.spec.ts`

### 디렉토리 구조 호환성
- ✅ 기존 유틸 파일들: camelCase 네이밍 (`dateUtils.ts`, `eventUtils.ts`)
- ✅ 테스트 파일: `__tests__/unit/` 경로에 `*.spec.ts` 형식

**개선 사항:**

1. **명세에서 제안한 파일명 수정:**
   - ❌ `schedule_recurring_rule.spec.ts` (snake_case)
   - ✅ `scheduleRecurringRule.spec.ts` 또는 `recurringSchedule.spec.ts` (camelCase)

2. **기존 함수 재사용 필요:**
   - `formatDate()` - 날짜 포맷팅
   - `getDaysInMonth()` - 월별 일수 확인

---

## 2. 명확성
**평가:** 개선 필요

**발견 사항:**

1. **함수 시그니처 부재**
   - 명세에 함수명, 매개변수, 반환 타입이 정의되지 않음
   - 테스트 시나리오만 존재하고 구현 인터페이스가 없음

2. **입력/출력 불명확**
   - 함수가 단일 일정을 받아 다음 날짜를 반환하는가?
   - 아니면 전체 반복 일정 배열을 생성하는가?
   - `repeatEndDate`를 어떻게 활용하는가?

3. **모호한 요구사항**
   - "일정 겹침을 고려하지 않음" → 이는 검증 로직을 skip하는 의미인가?
   - 반복 횟수는 어떻게 제한하는가? (`endDate` 또는 `count`?)

**개선 사항:**

1. **명확한 함수 시그니처 필요:**
```typescript
/**
 * 반복 일정의 다음 발생 날짜를 계산합니다.
 * @param baseDate - 기준 날짜 (YYYY-MM-DD 형식)
 * @param repeatType - 반복 유형
 * @returns 다음 일정 날짜 또는 null (조건을 만족하지 않는 경우)
 */
export function getNextRecurrenceDate(
  baseDate: string,
  repeatType: RepeatType
): string | null
```

2. **또는 전체 생성 함수:**
```typescript
/**
 * 반복 일정의 모든 발생 날짜를 생성합니다.
 * @param event - 기준 이벤트
 * @param maxOccurrences - 최대 생성 횟수
 * @returns 생성된 날짜 배열
 */
export function generateRecurringDates(
  event: Event,
  maxOccurrences: number
): string[]
```

---

## 3. 완전성
**평가:** 개선 필요

**누락된 사항:**

1. **에러 처리 정의 누락**
   - 잘못된 날짜 형식 입력 시 처리 방법 없음
   - `repeatInterval`이 0 또는 음수일 경우 처리 없음

2. **엣지 케이스 추가 필요**
   - **매월 반복 시 30일 문제:**
     - 시작일이 1월 30일 → 2월은 skip (30일 없음) → 3월 30일
   - **매년 반복 시 비윤년 2월 29일 문제:**
     - 명세는 윤년 2월 29일만 다루지만, 1월 31일 시작의 매년 반복은?
   - **반복 간격(interval) 처리:**
     - 명세는 interval=1만 가정, interval=2 이상은 어떻게?

3. **repeatEndDate 처리 누락**
   - `RepeatInfo`에는 `endDate`가 있지만 명세에서 다루지 않음

4. **무한 반복 방지 로직 부재**
   - endDate 없이 반복 시 언제 중단하는가?

**추가할 내용:**

### 추가 시나리오

#### 5️⃣ interval 처리
```typescript
Given: 시작일이 2024-01-01, interval=2, 반복 유형이 daily
When: 반복 일정 생성 시
Then: 2024-01-03, 2024-01-05, 2024-01-07... (2일 간격)
```

#### 6️⃣ endDate 제한
```typescript
Given: 시작일이 2024-01-01, endDate가 2024-01-10, 반복 유형이 daily
When: 반복 일정 생성 시
Then: 2024-01-02부터 2024-01-10까지만 생성
```

#### 7️⃣ 30일 매월 반복
```typescript
Given: 시작일이 2024-01-30
When: 반복 유형이 monthly
Then: 2024-02-30은 없으므로 skip → 2024-03-30
```

---

## 4. 테스트 가능성
**평가:** 개선 필요

**테스트 전략:**

### 기존 테스트 패턴 분석
프로젝트는 다음 패턴을 따릅니다:

```typescript
// 1. describe로 함수별 그룹화
describe('functionName', () => {
  // 2. 각 케이스마다 구체적인 한글 설명
  it('구체적인 동작을 한글로 설명한다', () => {
    // 3. 명시적 타입 지정
    const input: Type = { ... };
    
    // 4. 실제 함수 호출
    const result = functionName(input);
    
    // 5. 명확한 assertion
    expect(result).toBe(expected);
  });
});
```

### 명세의 테스트 가능성 문제

1. **반환값 형식 불명확**
   - 테이블에는 날짜만 있지만, 실제로는 `Event` 객체를 생성해야 하는가?
   
2. **"생성되지 않는다" 검증 방법 불명확**
   - 매월 반복 시 2월에 31일이 없으면 → 어떤 값을 반환? `null`? 빈 배열?

3. **테스트 데이터 구조 불명확**
   - 기존 테스트는 완전한 `Event` 객체를 사용
   - 명세는 날짜만 다룸

**개선 방안:**

```typescript
describe('generateNextRecurrenceDate', () => {
  describe('매일 반복', () => {
    it('시작일 2024-01-31 다음은 2024-02-01이어야 한다', () => {
      const result = generateNextRecurrenceDate('2024-01-31', 'daily', 1);
      expect(result).toBe('2024-02-01');
    });
  });

  describe('매월 반복 - 31일 예외 처리', () => {
    it('1월 31일 기준으로 2월은 skip되고 3월 31일이 반환되어야 한다', () => {
      const result = generateNextRecurrenceDate('2024-01-31', 'monthly', 1);
      expect(result).toBe('2024-03-31');
    });
  });
});
```

---

## 5. 일관성
**평가:** 개선 필요

**충돌 사항:**

1. **명세와 프로젝트 코딩 스타일 불일치**
   - 명세: 테이블 기반 시나리오
   - 프로젝트: `describe`/`it` 기반 상세 테스트

2. **함수 선언 스타일**
   - 프로젝트: 20개 함수 모두 `function` 선언 사용
   - 명세: 스타일 미정의

3. **반복 일정 처리 방식 불명확**
   - App.tsx에서는 `RepeatInfo` 객체로 관리
   - 명세는 개별 속성만 다룸

4. **일정 겹침 철학 충돌**
   - 기존 코드: `findOverlappingEvents`로 겹침 검증 후 경고 다이얼로그 (App.tsx:137-144)
   - 명세: "일정 겹침을 고려하지 않음"
   - ⚠️ 이는 기존 UX 패턴과 상충됨

**개선 사항:**

1. **일정 겹침 처리 명확화:**
   - 반복 일정 **생성 로직** 자체는 겹침을 고려하지 않음
   - 하지만 **생성된 일정을 저장**할 때는 기존 겹침 검증 로직 사용

2. **기존 코드와의 통합 방식:**
```typescript
// useEventOperations.ts에서 사용할 방식
const recurringDates = generateRecurringDates(eventData, 10);
recurringDates.forEach(date => {
  const newEvent = { ...eventData, date };
  // 기존 findOverlappingEvents로 검증
  const overlapping = findOverlappingEvents(newEvent, events);
  if (overlapping.length > 0) {
    // 경고 표시 또는 skip
  }
});
```

---

## 6. 성능 고려사항
**평가:** 개선 필요

**성능 이슈:**

1. **무한 루프 가능성**
   - endDate 없이 반복 시 종료 조건 필요
   - 매월 31일 반복 시 12개월 반복에 실제로는 7개월만 생성 → 언제 중단?

2. **대량 일정 생성**
   - 매일 반복 + endDate=1년 후 → 365개 일정 생성
   - 성능 및 UX 고려 필요 (progress indicator, batch 처리)

3. **날짜 계산 복잡도**
   - 윤년 계산이 매번 필요 (이미 `getDaysInMonth`에 존재)

**최적화 방안:**

1. **최대 생성 횟수 제한:**
```typescript
const MAX_RECURRING_EVENTS = 100; // 상수 정의
```

2. **기존 함수 재사용:**
```typescript
// dateUtils.ts의 getDaysInMonth 활용
function isValidDayInMonth(year: number, month: number, day: number): boolean {
  return day <= getDaysInMonth(year, month);
}
```

3. **지연 생성 (Lazy Generation):**
```typescript
// 전체를 미리 생성하지 않고, iterator 패턴 사용
function* recurringDateGenerator(event: Event) {
  // yield next date
}
```

---

# 📝 개선된 명세

## 반복 일정 생성 로직

### 개요
사용자가 설정한 반복 규칙에 따라 다음 일정 날짜를 계산하는 유틸리티 함수입니다. 
매일, 매주, 매월, 매년 반복 유형을 지원하며, 윤년 및 월별 일수 차이를 정확하게 처리합니다.

**프로젝트 연관성:**
- `RepeatInfo` 타입 활용 (src/types.ts:3-7)
- `useEventOperations` 훅에서 호출 (반복 일정 저장 시)
- 기존 `dateUtils.ts` 함수 재사용

---

### 위치
**파일:** `src/utils/recurringSchedule.ts`  
**테스트:** `src/__tests__/unit/recurringSchedule.spec.ts`

---

### 타입 정의

#### 기존 타입 활용
```typescript
// src/types.ts에서 import
import { RepeatType, RepeatInfo } from '../types';
```

#### 새로운 타입
```typescript
/**
 * 반복 일정 생성 결과
 */
export interface RecurringDateResult {
  /** 다음 일정 날짜 (YYYY-MM-DD) 또는 null (조건을 만족하지 않는 경우) */
  nextDate: string | null;
  /** 조건을 만족하지 않는 경우 이유 */
  reason?: 'NO_SUCH_DAY' | 'END_DATE_REACHED' | 'INVALID_PARAMS';
}

/**
 * 반복 일정 생성 옵션
 */
export interface RecurringOptions {
  /** 기준 날짜 (YYYY-MM-DD) */
  baseDate: string;
  /** 반복 정보 */
  repeatInfo: RepeatInfo;
  /** 최대 탐색 횟수 (무한 루프 방지, 기본값: 100) */
  maxAttempts?: number;
}
```

---

### 함수 시그니처

```typescript
/**
 * 반복 규칙에 따라 다음 발생 날짜를 계산합니다.
 * 
 * - 매일: baseDate + interval일
 * - 매주: baseDate + interval주 (같은 요일)
 * - 매월: baseDate + interval개월 (같은 일자, 없으면 skip)
 * - 매년: baseDate + interval년 (같은 월/일, 없으면 skip)
 * 
 * @param options - 반복 일정 생성 옵션
 * @returns 다음 일정 날짜 정보
 * 
 * @example
 * ```typescript
 * // 매일 반복
 * getNextRecurrenceDate({
 *   baseDate: '2024-01-31',
 *   repeatInfo: { type: 'daily', interval: 1 }
 * });
 * // => { nextDate: '2024-02-01' }
 * 
 * // 매월 31일 반복 (2월 skip)
 * getNextRecurrenceDate({
 *   baseDate: '2024-01-31',
 *   repeatInfo: { type: 'monthly', interval: 1 }
 * });
 * // => { nextDate: '2024-03-31' }
 * 
 * // 윤년만 반복
 * getNextRecurrenceDate({
 *   baseDate: '2024-02-29',
 *   repeatInfo: { type: 'yearly', interval: 1 }
 * });
 * // => { nextDate: '2028-02-29' }
 * ```
 */
export function getNextRecurrenceDate(
  options: RecurringOptions
): RecurringDateResult {
  // 구현은 나중에
}

/**
 * 반복 일정의 모든 발생 날짜를 생성합니다.
 * 
 * @param options - 반복 일정 생성 옵션
 * @param maxOccurrences - 최대 생성 개수 (기본값: 50)
 * @returns 생성된 날짜 배열 (YYYY-MM-DD 형식)
 * 
 * @example
 * ```typescript
 * generateRecurringDates({
 *   baseDate: '2024-01-01',
 *   repeatInfo: { 
 *     type: 'weekly', 
 *     interval: 1,
 *     endDate: '2024-01-31'
 *   }
 * }, 10);
 * // => ['2024-01-08', '2024-01-15', '2024-01-22', '2024-01-29']
 * ```
 */
export function generateRecurringDates(
  options: RecurringOptions,
  maxOccurrences: number = 50
): string[] {
  // 구현은 나중에
}
```

---

### 상세 요구사항

#### 입력 검증
1. `baseDate`가 유효한 날짜 형식(`YYYY-MM-DD`)인지 검증
2. `repeatInfo.type`이 `'none'`이면 빈 배열 반환
3. `repeatInfo.interval`이 1 이상인지 검증 (0 이하는 에러)
4. `repeatInfo.endDate`가 있으면 `baseDate`보다 이후인지 검증

#### 비즈니스 로직

##### 1. 매일 반복 (`daily`)
```typescript
nextDate = baseDate + (interval * days)
```
- 단순히 interval일 추가
- 예: 2024-01-31 + 1일 = 2024-02-01

##### 2. 매주 반복 (`weekly`)
```typescript
nextDate = baseDate + (interval * 7 days)
```
- 같은 요일 유지
- 예: 2024-01-31 (수) + 1주 = 2024-02-07 (수)

##### 3. 매월 반복 (`monthly`)
```typescript
nextDate = baseDate + (interval * months)
// 단, nextDate의 일자가 해당 월에 존재하지 않으면 다음 달 시도
```
- **중요:** 같은 **일자**에만 생성
- 예: 1월 31일 → 2월은 31일 없음 (skip) → 3월 31일
- 최대 12번 시도 후 null 반환 (1년 안에 해당 일자가 없는 경우)

##### 4. 매년 반복 (`yearly`)
```typescript
nextDate = baseDate + (interval * years)
// 단, nextDate의 월/일이 존재하지 않으면 다음 해 시도
```
- **중요:** 같은 **월/일**에만 생성
- 예: 2024-02-29 → 2025~2027 skip (윤년 아님) → 2028-02-29
- 최대 50번 시도 후 null 반환

#### 에러 처리
1. **잘못된 날짜 형식:**
```typescript
return { nextDate: null, reason: 'INVALID_PARAMS' };
```

2. **endDate 도달:**
```typescript
if (repeatInfo.endDate && calculatedDate > repeatInfo.endDate) {
  return { nextDate: null, reason: 'END_DATE_REACHED' };
}
```

3. **해당 일자 없음 (maxAttempts 초과):**
```typescript
return { nextDate: null, reason: 'NO_SUCH_DAY' };
```

#### 엣지 케이스
1. **윤년 2월 29일 처리**
   - `yearly` 반복 시 4년마다만 생성
   - 100년 단위 평년 처리 (2100년은 윤년 아님)

2. **월별 일수 차이**
   - 31일: 1, 3, 5, 7, 8, 10, 12월
   - 30일: 4, 6, 9, 11월
   - 28/29일: 2월

3. **interval > 1 처리**
   - 2주마다, 3개월마다 등

4. **무한 루프 방지**
   - `maxAttempts` 파라미터로 제한
   - 기본값: 100회

---

### 테스트 시나리오

#### 정상 케이스

##### 1. 매일 반복
```typescript
describe('getNextRecurrenceDate - 매일 반복', () => {
  it('2024-01-31 다음은 2024-02-01이어야 한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-01-31',
      repeatInfo: { type: 'daily', interval: 1 }
    });
    expect(result.nextDate).toBe('2024-02-01');
  });

  it('interval=2일 때 이틀씩 건너뛴다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-01-01',
      repeatInfo: { type: 'daily', interval: 2 }
    });
    expect(result.nextDate).toBe('2024-01-03');
  });
});
```

##### 2. 매주 반복
```typescript
describe('getNextRecurrenceDate - 매주 반복', () => {
  it('2024-01-31 (수요일) 다음은 2024-02-07 (수요일)이어야 한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-01-31',
      repeatInfo: { type: 'weekly', interval: 1 }
    });
    expect(result.nextDate).toBe('2024-02-07');
  });
});
```

##### 3. 매월 반복 (31일 예외)
```typescript
describe('getNextRecurrenceDate - 매월 반복', () => {
  it('1월 31일 기준으로 2월은 skip되고 3월 31일이 반환되어야 한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-01-31',
      repeatInfo: { type: 'monthly', interval: 1 }
    });
    expect(result.nextDate).toBe('2024-03-31');
  });

  it('3월 31일 다음은 5월 31일이어야 한다 (4월은 30일까지)', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-03-31',
      repeatInfo: { type: 'monthly', interval: 1 }
    });
    expect(result.nextDate).toBe('2024-05-31');
  });
});
```

##### 4. 매년 반복 (윤년 처리)
```typescript
describe('getNextRecurrenceDate - 매년 반복', () => {
  it('윤년 2024-02-29 다음은 2028-02-29이어야 한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-02-29',
      repeatInfo: { type: 'yearly', interval: 1 }
    });
    expect(result.nextDate).toBe('2028-02-29');
  });

  it('2028-02-29 다음은 2032-02-29이어야 한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2028-02-29',
      repeatInfo: { type: 'yearly', interval: 1 }
    });
    expect(result.nextDate).toBe('2032-02-29');
  });
});
```

#### 예외 케이스

##### 1. 입력 검증
```typescript
describe('getNextRecurrenceDate - 입력 검증', () => {
  it('잘못된 날짜 형식은 INVALID_PARAMS를 반환한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: 'invalid-date',
      repeatInfo: { type: 'daily', interval: 1 }
    });
    expect(result.nextDate).toBeNull();
    expect(result.reason).toBe('INVALID_PARAMS');
  });

  it('interval이 0 이하면 INVALID_PARAMS를 반환한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-01-01',
      repeatInfo: { type: 'daily', interval: 0 }
    });
    expect(result.nextDate).toBeNull();
    expect(result.reason).toBe('INVALID_PARAMS');
  });
});
```

##### 2. endDate 제한
```typescript
describe('getNextRecurrenceDate - endDate 제한', () => {
  it('endDate를 초과하면 END_DATE_REACHED를 반환한다', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-01-31',
      repeatInfo: { 
        type: 'daily', 
        interval: 1,
        endDate: '2024-02-01'
      }
    });
    // 다음 날짜는 2024-02-01이지만 endDate와 같으므로 허용
    expect(result.nextDate).toBe('2024-02-01');

    // 그 다음은 endDate 초과
    const result2 = getNextRecurrenceDate({
      baseDate: '2024-02-01',
      repeatInfo: { 
        type: 'daily', 
        interval: 1,
        endDate: '2024-02-01'
      }
    });
    expect(result2.nextDate).toBeNull();
    expect(result2.reason).toBe('END_DATE_REACHED');
  });
});
```

#### 엣지 케이스

##### 1. 극단적인 날짜
```typescript
describe('getNextRecurrenceDate - 엣지 케이스', () => {
  it('1월 30일 매월 반복은 2월 skip, 3월 30일 생성', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-01-30',
      repeatInfo: { type: 'monthly', interval: 1 }
    });
    expect(result.nextDate).toBe('2024-03-30');
  });

  it('연말에서 연초로 넘어가는 경우', () => {
    const result = getNextRecurrenceDate({
      baseDate: '2024-12-31',
      repeatInfo: { type: 'daily', interval: 1 }
    });
    expect(result.nextDate).toBe('2025-01-01');
  });
});
```

##### 2. 배열 생성 함수
```typescript
describe('generateRecurringDates', () => {
  it('매일 반복 시 지정된 개수만큼 날짜를 생성한다', () => {
    const dates = generateRecurringDates({
      baseDate: '2024-01-01',
      repeatInfo: { type: 'daily', interval: 1 }
    }, 3);
    expect(dates).toEqual([
      '2024-01-02',
      '2024-01-03',
      '2024-01-04'
    ]);
  });

  it('endDate에 도달하면 생성을 중단한다', () => {
    const dates = generateRecurringDates({
      baseDate: '2024-01-01',
      repeatInfo: { 
        type: 'daily', 
        interval: 1,
        endDate: '2024-01-05'
      }
    }, 10); // 최대 10개 요청
    expect(dates).toEqual([
      '2024-01-02',
      '2024-01-03',
      '2024-01-04',
      '2024-01-05'
    ]); // 실제로는 4개만 생성
  });

  it('매월 31일 반복은 해당 월만 포함한다', () => {
    const dates = generateRecurringDates({
      baseDate: '2024-01-31',
      repeatInfo: { type: 'monthly', interval: 1 }
    }, 5);
    expect(dates).toEqual([
      '2024-03-31', // 2월 skip
      '2024-05-31', // 4월 skip
      '2024-07-31',
      '2024-08-31',
      '2024-10-31'  // 9월 skip
    ]);
  });
});
```

---

### 통합 가이드

#### 기존 코드와의 관계

**사용할 기존 유틸:**
- `dateUtils.ts`의 `getDaysInMonth(year, month)` - 월별 일수 확인
- `dateUtils.ts`의 `formatDate(date, day)` - 날짜 포맷팅
- `dateUtils.ts`의 `fillZero(value)` - 0 패딩

**연관된 컴포넌트:**
- `App.tsx`의 반복 일정 폼 (line 440-476)
- `useEventOperations.ts`의 `saveEvent` 함수에서 호출

#### 사용 예시

```typescript
// useEventOperations.ts에서 사용
import { generateRecurringDates } from '../utils/recurringSchedule';
import { findOverlappingEvents } from '../utils/eventOverlap';

const saveEvent = async (eventData: Event | EventForm) => {
  if (eventData.repeat.type !== 'none') {
    // 반복 일정 생성
    const recurringDates = generateRecurringDates({
      baseDate: eventData.date,
      repeatInfo: eventData.repeat
    }, 50); // 최대 50개

    // 각 날짜에 대해 이벤트 생성
    const newEvents = recurringDates.map(date => ({
      ...eventData,
      id: crypto.randomUUID(),
      date
    }));

    // 기존 겹침 검증 로직 활용 (선택사항)
    for (const newEvent of newEvents) {
      const overlapping = findOverlappingEvents(newEvent, events);
      if (overlapping.length > 0) {
        // 사용자에게 확인 요청 또는 skip
        console.warn(`Date ${newEvent.date} has overlapping events`);
      }
    }

    // DB 저장
    await Promise.all(newEvents.map(e => fetch('/api/events', {
      method: 'POST',
      body: JSON.stringify(e)
    })));
  } else {
    // 단일 일정 저장 (기존 로직)
    await fetch('/api/events', {
      method: 'POST',
      body: JSON.stringify(eventData)
    });
  }
};
```

---

### 성능 고려사항

1. **최대 생성 개수 제한:**
```typescript
const MAX_RECURRING_EVENTS = 50; // 상수 정의
```

2. **무한 루프 방지:**
```typescript
// maxAttempts로 탐색 횟수 제한
// 매월 31일 반복 시 12번 시도 후 포기
```

3. **기존 함수 재사용으로 중복 계산 방지:**
```typescript
import { getDaysInMonth } from './dateUtils';

function isValidDayInMonth(year: number, month: number, day: number): boolean {
  return day <= getDaysInMonth(year, month);
}
```

---

### 마이그레이션 가이드

#### 기존 코드 수정 필요 없음
- 이 기능은 새로운 유틸리티이므로 기존 코드 수정 불필요
- `useEventOperations.ts`의 `saveEvent` 함수에서 선택적으로 호출

#### 점진적 도입 방안
1. **Phase 1:** 유틸리티 함수 구현 및 단위 테스트
2. **Phase 2:** `useEventOperations`에 통합 (feature flag 사용)
3. **Phase 3:** UI에서 반복 일정 생성 버튼 활성화

---

### 추가 권장사항

1. **반복 일정 표시 개선:**
   - 반복 아이콘 추가
   - 반복 그룹 표시 (같은 반복 규칙의 일정들)

2. **반복 일정 수정 정책:**
   - "이 일정만 수정" vs "모든 반복 일정 수정"
   - 이는 별도 명세 필요

3. **성능 모니터링:**
   - 50개 이상 일정 생성 시 경고
   - Progress indicator 표시

---

## 📊 검증 요약

| 항목 | 평가 | 주요 이슈 |
|------|------|-----------|
| 프로젝트 통합성 | ⚠️ 개선 필요 | 파일명 컨벤션, 기존 함수 재사용 필요 |
| 명확성 | ⚠️ 개선 필요 | 함수 시그니처 부재, 입출력 불명확 |
| 완전성 | ⚠️ 개선 필요 | 에러 처리, interval 처리, endDate 로직 누락 |
| 테스트 가능성 | ⚠️ 개선 필요 | 반환값 형식, "생성 안됨" 검증 방법 불명확 |
| 일관성 | ⚠️ 개선 필요 | 겹침 철학 충돌, 테스트 스타일 불일치 |
| 성능 | ⚠️ 개선 필요 | 무한 루프 방지, 최대 생성 개수 제한 필요 |

**전체 평가: 개선 필요**

위의 개선된 명세를 따르면 프로젝트와 완전히 통합 가능한 구현이 가능합니다.
