Based on my comprehensive analysis of the project context, I can now provide a detailed validation report:

---

## ✅ 검증 결과

### 1. 프로젝트 통합성
**평가:** 개선 필요

**발견 사항:**
- **기존 타입:** `RepeatType`, `RepeatInfo`, `Event`, `EventForm` (src/types.ts)에 이미 정의되어 있음
- **기존 유틸리티:** `dateUtils.ts`에 날짜 관련 함수들이 이미 존재 (`getDaysInMonth`, `formatDate`, `isDateInRange` 등)
- **중복 가능성:** 없음 - 반복 일정 생성 로직은 현재 프로젝트에 존재하지 않음
- **테스트 위치:** 프로젝트는 `src/__tests__/unit/*.spec.ts` 패턴 사용 (예: `easy.dateUtils.spec.ts`)
- **네이밍 컨벤션:** 함수 선언(function declaration) 스타일 선호 (20/20)

**개선 사항:**
1. **파일 위치:** `src/utils/recurringEvents.ts` (또는 `repeatUtils.ts`)
2. **테스트 파일:** `src/__tests__/unit/medium.recurringEvents.spec.ts` (복잡도 고려)
3. **명세에 함수명 제안 누락:** "반복 일정 생성 로직"이라고만 명시되어 있어 구체적인 함수명 제안 필요
4. **기존 타입 재사용 명시 필요:** `RepeatType`, `Event` 타입을 어떻게 활용할지 설명 필요

---

### 2. 명확성
**평가:** 개선 필요

**발견 사항:**
1. **모호한 점:**
   - "반복 일정 생성 로직"의 정확한 범위가 불명확 (단일 함수? 여러 함수?)
   - 입력 파라미터가 명시되지 않음 (기준 일정 데이터, 생성 개수 등)
   - 출력 형태가 불명확 (Event 배열? 단일 날짜? 생성기?)
   - "반복 종료 조건"이 명시되지 않음 (횟수? 종료일?)

2. **구체성 부족:**
   - "일정 겹침은 고려하지 않음"은 명확하나, 실제 구현에서 이를 어떻게 처리할지 불명확
   - 매월 31일 규칙이 "31일에만 생성"이라고 했지만, 실제 사용 시나리오 불명확

**개선 사항:**
1. 기능 범위를 명확히 정의 (예: "기준 일정으로부터 N개의 반복 일정 날짜 계산")
2. 입력 개념 명시 (기준 날짜, 반복 타입, 생성 개수 또는 종료 조건)
3. 출력 개념 명시 (날짜 배열, 이벤트 배열 등)
4. 에러 시나리오 추가 (잘못된 반복 타입, 음수 횟수 등)

---

### 3. 완전성
**평가:** 개선 필요

**누락된 사항:**
1. **입력 검증:**
   - 잘못된 `RepeatType` 값 처리
   - 반복 횟수/종료일 검증
   - 기준 날짜 유효성 검증

2. **엣지 케이스:**
   - 반복 간격(`interval`) 처리 언급 없음 (RepeatInfo에는 interval 필드 존재)
   - 반복 종료일(`endDate`) 처리 언급 없음 (RepeatInfo에는 endDate 필드 존재)
   - DST(일광절약시간) 고려 여부
   - 매주 반복 시 월 경계 처리

3. **에러 처리:**
   - 무한 루프 방지 로직
   - 메모리 제한 (너무 많은 일정 생성 방지)
   - 100년 후 윤년 계산 등 극단적 케이스

4. **반환 값:**
   - 성공/실패 여부를 어떻게 표현할지
   - 부분 성공 시나리오 (일부만 생성 가능한 경우)

**추가할 내용:**
1. `RepeatInfo.interval`과 `endDate` 필드 활용 방안
2. 최대 생성 개수 제한 (성능 고려)
3. 타임존 처리 방침
4. 기존 `Event` 타입과의 통합 방안 (id 생성 여부 등)

---

### 4. 테스트 가능성
**평가:** 통과 (개념적으로)

**테스트 전략:**
- 명세에 제시된 테이블 기반 테스트는 명확하고 검증 가능함
- 프로젝트의 기존 테스트 패턴과 일치 (Arrange-Act-Assert, describe 중첩)
- 각 반복 타입별 독립적 테스트 가능

**강점:**
- 구체적인 예상 날짜 제공
- 엣지 케이스(윤년) 포함

**개선 필요:**
- 테스트 파일명 제안: `src/__tests__/unit/medium.recurringEvents.spec.ts`
- 에러 케이스 테스트 시나리오 추가 필요
- 경계값 테스트 추가 (0회 반복, 1회 반복 등)

---

### 5. 일관성
**평가:** 개선 필요

**충돌 사항:**
1. **타입 시스템:**
   - `RepeatInfo.interval` 필드를 명세에서 활용하지 않음
   - `RepeatInfo.endDate` 필드를 명세에서 활용하지 않음
   - 명세는 "횟수" 기반이지만, 기존 타입은 "종료일" 기반

2. **네이밍:**
   - 명세의 "매일/매주/매월/매년"은 `RepeatType`의 'daily/weekly/monthly/yearly'와 일치
   - 함수명 제안 없음 (프로젝트는 camelCase 선호)

3. **프로젝트 패턴:**
   - 기존 유틸리티는 순수 함수 스타일
   - 에러는 throw보다 결과 객체 반환 선호 (`validateDateRange` 참고)

**개선 방안:**
1. `RepeatInfo` 타입의 모든 필드 활용 방안 명시
2. 함수명 제안: `generateRecurringDates` 또는 `calculateRecurringDates`
3. 반환 타입 일관성: `{ dates: string[], skipped?: string[] }` 형태 제안

---

### 6. 성능 고려사항
**평가:** 개선 필요

**성능 이슈:**
1. **잠재적 문제:**
   - 매일 반복으로 10년치 일정 생성 시 3650+ 날짜 계산
   - 무한 루프 가능성 (종료 조건 없을 때)
   - 메모리 사용량 (대량 날짜 배열)

2. **명세 누락:**
   - 최대 생성 개수 제한 없음
   - 시간 복잡도/공간 복잡도 언급 없음
   - 성능 요구사항 없음

**권장 사항:**
1. 최대 반복 횟수 제한 (예: 1000회)
2. 또는 최대 계산 범위 제한 (예: 5년)
3. 지연 평가 고려 (생성기 패턴 vs 배열 반환)
4. 성능 제약사항 명시: "최대 1000개 날짜 생성" 등

---

## 📝 개선된 명세 (요구사항 수준)

# 반복 일정 날짜 계산

## 개요
캘린더 일정의 반복 규칙에 따라 미래의 반복 날짜들을 계산하는 기능입니다. 사용자가 설정한 반복 타입(매일/매주/매월/매년)과 기준 일정을 바탕으로, 실제로 일정이 발생할 날짜 목록을 생성합니다.

**핵심 특징:**
- 일정 겹침 검증 없이 순수하게 날짜만 계산
- 월별/연도별 특수 규칙 적용 (31일, 윤년 등)
- 기존 `RepeatInfo` 타입 시스템 활용

## 위치
**권장 파일 경로:** `src/utils/recurringEvents.ts`

**선정 이유:**
- 날짜 계산 유틸리티이므로 `utils` 폴더에 위치
- `dateUtils.ts`의 헬퍼 함수들 재사용 가능
- 단순 계산 로직이므로 hook보다 util이 적합

**테스트 파일:** `src/__tests__/unit/medium.recurringEvents.spec.ts`
- 복잡도가 중간 수준 (여러 분기, 날짜 계산)
- 기존 테스트 네이밍 컨벤션 준수 (`medium.*`)

## 기능 설명
- **핵심 기능:** 기준 일정의 반복 설정에 따라 미래 발생 날짜 계산
- **주요 동작:** 
  1. 기준 날짜와 반복 타입을 받음
  2. 종료 조건(종료일 또는 최대 개수)까지 반복 날짜 생성
  3. 각 반복 타입별 특수 규칙 적용 (월말, 윤년 등)
  4. 생성된 날짜 목록 반환
  
- **제약 조건:** 
  - 일정 겹침 여부 확인 안 함
  - 최대 1000개 날짜까지만 생성 (무한 루프/메모리 방지)
  - 과거 날짜는 생성하지 않음 (기준일 이후만)

## 입력 (개념적)
### 파라미터 1: 기준 일정 정보
- **타입 힌트:** Event 또는 EventForm 객체
- **필수/선택:** 필수
- **예시:** 
```typescript
{
  date: '2024-01-31',
  repeat: {
    type: 'monthly',
    interval: 1,
    endDate: '2024-12-31'
  }
}
```
- **제약:** 
  - `date` 필드는 유효한 ISO 형식 날짜
  - `repeat.type`은 'none' 이외의 값
  - `repeat.interval`은 1 이상의 정수

### 파라미터 2: 생성 개수 제한 (선택)
- **타입 힌트:** number
- **필수/선택:** 선택 (기본값: `RepeatInfo.endDate` 기준 또는 최대 1000개)
- **예시:** `10` (10개 날짜만 생성)
- **제약:** 1 이상, 1000 이하

## 출력 (개념적)
### 성공 시
- **반환 타입:** 날짜 문자열 배열
- **포함 정보:** ISO 형식 날짜 목록 (`YYYY-MM-DD`)
  
**예시:**
```typescript
// 성공: 2024-01-31 기준 월 반복 3회
['2024-03-31', '2024-05-31', '2024-07-31']

// 매월 31일이지만 2월/4월/6월은 건너뜀
```

### 실패 시
- **반환 타입:** 빈 배열 또는 에러 정보를 포함한 객체
- **포함 정보:** 에러 메시지, 실패 원인
  
**예시:**
```typescript
// 잘못된 반복 타입
{ success: false, error: "유효하지 않은 반복 타입입니다", dates: [] }

// 종료일이 시작일보다 이전
{ success: false, error: "종료일은 시작일 이후여야 합니다", dates: [] }
```

### 부분 성공
- **특수 케이스:** 일부 날짜만 생성 가능한 경우
- **예시:**
```typescript
// 매월 31일이지만 종료일 내에 31일이 없는 달만 있는 경우
{ success: true, dates: [], warnings: ["생성된 날짜가 없습니다"] }
```

## 관련 타입 (기존 재사용)
- **Event** (src/types.ts) - 기준 일정 구조
- **EventForm** (src/types.ts) - 폼 데이터에서도 사용 가능
- **RepeatType** (src/types.ts) - 'daily' | 'weekly' | 'monthly' | 'yearly'
- **RepeatInfo** (src/types.ts) - 반복 설정 정보 (type, interval, endDate)

**새 타입 필요 여부:** 예
- 결과 객체 타입 필요 (성공/실패, 날짜 배열, 경고)
- Step 2에서 구체화 예정

## 상세 요구사항

### 1. 입력 검증 규칙

#### 1.1 기준 일정 검증
1. **date 필드 필수 확인:**
   - null/undefined → 에러: "기준 날짜는 필수입니다"
   - 빈 문자열 → 에러: "기준 날짜는 필수입니다"

2. **date 형식 검증:**
   - 유효하지 않은 날짜 → 에러: "유효하지 않은 날짜 형식입니다"
   - '2024-02-30' 같은 존재하지 않는 날짜 → 에러: "존재하지 않는 날짜입니다"

3. **repeat 설정 검증:**
   - repeat 객체 없음 → 에러: "반복 설정이 필요합니다"
   - repeat.type이 'none' → 빈 배열 반환 (에러 아님)
   - repeat.type이 유효하지 않은 값 → 에러: "유효하지 않은 반복 타입입니다"

#### 1.2 interval 검증
1. **interval 값 확인:**
   - 0 이하 → 에러: "반복 간격은 1 이상이어야 합니다"
   - 정수가 아님 → 에러: "반복 간격은 정수여야 합니다"
   - 생략 시 기본값 1 사용

#### 1.3 종료 조건 검증
1. **endDate 검증:**
   - 형식 오류 → 에러: "유효하지 않은 종료일 형식입니다"
   - 시작일보다 이전 → 에러: "종료일은 시작일 이후여야 합니다"
   - 생략 시 최대 개수 제한 적용

2. **생성 개수 제한:**
   - 음수 → 에러: "생성 개수는 0 이상이어야 합니다"
   - 1000 초과 → 경고: "최대 1000개까지만 생성됩니다"

### 2. 반복 유형별 비즈니스 로직

#### 2.1 매일 반복 (daily)
1. **기본 동작:**
   - 기준일 + (interval × N)일 계산
   - 예: interval=1이면 매일, interval=2면 이틀마다

2. **종료 조건:**
   - endDate 도달 또는 초과 시 중단
   - 최대 개수 도달 시 중단

3. **특이사항:**
   - 월/연도 경계 자동 처리
   - 윤년/평년 고려 (Date 객체 사용으로 자동 처리)

#### 2.2 매주 반복 (weekly)
1. **기본 동작:**
   - 기준일의 요일 유지
   - 기준일 + (7 × interval × N)일 계산
   - 예: 수요일 기준이면 항상 수요일

2. **특이사항:**
   - 월 경계 무관하게 정확히 7일 간격
   - 연말/연초 경계도 동일

#### 2.3 매월 반복 (monthly)
1. **기본 동작:**
   - 기준일의 "일(day)" 숫자 유지
   - 예: 31일 기준이면 매월 31일 시도

2. **핵심 규칙 - "해당 일자가 없으면 건너뜀":**
   - 2월 31일 → 생성 안 함 (2월 마지막 날로 대체하지 않음!)
   - 4월 31일 → 생성 안 함
   - 6월 31일 → 생성 안 함
   
3. **윤년 처리:**
   - 2월 29일 기준 → 윤년에만 생성
   - 2월 30일 기준 → 영구히 생성 안 됨

4. **interval 적용:**
   - interval=1: 매월
   - interval=2: 격월
   - 건너뛴 달도 interval 계산에 포함
   - 예: 1월 31일 기준, interval=1
     - 2월 검사 → 31일 없음, 건너뜀
     - 3월 검사 → 31일 있음, 생성
     - 4월 검사 → 31일 없음, 건너뜀

#### 2.4 매년 반복 (yearly)
1. **기본 동작:**
   - 기준일의 "월-일" 유지
   - 예: 2월 29일 기준이면 매년 2월 29일 시도

2. **핵심 규칙:**
   - 2월 29일 기준 → 윤년에만 생성
   - 2월 30일 기준 → 영구히 생성 안 됨
   - 다른 날짜는 매년 생성

3. **윤년 판별:**
   - 4로 나누어떨어지고
   - 100으로 나누어떨어지지 않거나
   - 400으로 나누어떨어지는 해

4. **interval 적용:**
   - interval=1: 매년
   - interval=2: 격년
   - 건너뛴 해도 interval 계산에 포함

### 3. 에러 처리 시나리오

| 상황 | 에러 메시지 | 심각도 | 반환값 |
|------|------------|--------|--------|
| 기준 날짜 없음 | "기준 날짜는 필수입니다" | Error | { success: false, error: "...", dates: [] } |
| 잘못된 날짜 형식 | "유효하지 않은 날짜 형식입니다" | Error | { success: false, error: "...", dates: [] } |
| repeat 설정 없음 | "반복 설정이 필요합니다" | Error | { success: false, error: "...", dates: [] } |
| 잘못된 repeat type | "유효하지 않은 반복 타입입니다" | Error | { success: false, error: "...", dates: [] } |
| interval 0 이하 | "반복 간격은 1 이상이어야 합니다" | Error | { success: false, error: "...", dates: [] } |
| 종료일이 시작일 이전 | "종료일은 시작일 이후여야 합니다" | Error | { success: false, error: "...", dates: [] } |
| 1000개 초과 시도 | "최대 1000개까지만 생성됩니다" | Warning | { success: true, dates: [...처음 1000개], warning: "..." } |
| repeat type이 'none' | - | Info | { success: true, dates: [] } |
| 생성 가능 날짜 없음 | "조건을 만족하는 날짜가 없습니다" | Warning | { success: true, dates: [], warning: "..." } |

### 4. 엣지 케이스

#### 4.1 극단 값
1. **먼 미래:**
   - 종료일이 100년 이후 → 경고: "종료일이 100년 이후입니다"
   - 계산은 정상 진행 (최대 1000개 제한 내에서)

2. **과거 날짜:**
   - 기준일이 과거 → 정상 처리 (미래 날짜 생성)
   - 종료일도 과거 → 빈 배열 반환

3. **interval 극단값:**
   - interval = 1000 (매일 반복) → 약 3년치, 정상 처리
   - interval = 12 (매월 반복) → 매년과 유사

#### 4.2 경계 조건
1. **연말/연초:**
   - 12월 31일 기준 매일 → 1월 1일 생성
   - 요일 계산 정확성 유지

2. **윤년 경계:**
   - 2024-02-29 기준 매년 → 2028-02-29 (다음 윤년)
   - 2024-02-29 기준 매월 → 2024-03 건너뛰고 이후는 매월 29일

3. **동일 날짜:**
   - 시작일 = 종료일 → 빈 배열 (시작일 제외)
   - 또는 시작일 포함 여부를 옵션으로

#### 4.3 특수 케이스
1. **존재하지 않는 날짜 시도:**
   - 매월 31일 × 6개월 요청 → 31일 있는 달만 생성 (3-4개)
   - 경고: "일부 날짜는 건너뛰었습니다"

2. **interval로 인한 건너뛰기:**
   - 매월 31일, interval=2 (격월)
   - 1월 → 3월 → 5월 → 7월 (2/4/6월 자동 건너뜀)

3. **최대 개수 도달:**
   - 매일 반복, 종료일 10년 후 → 1000개 생성 후 중단
   - 경고 메시지 포함

## 테스트 시나리오 (개념적)

### 정상 케이스

#### 1. 매일 반복 - 기본 동작
- **입력:** 
  - 기준일: 2024-01-31
  - 반복: daily, interval=1
  - 생성 개수: 3개
- **예상 출력:** ['2024-02-01', '2024-02-02', '2024-02-03']
- **검증 포인트:** 연속된 날짜 생성, 월 경계 처리

#### 2. 매주 반복 - 요일 유지
- **입력:**
  - 기준일: 2024-01-31 (수요일)
  - 반복: weekly, interval=1
  - 생성 개수: 3개
- **예상 출력:** ['2024-02-07', '2024-02-14', '2024-02-21'] (모두 수요일)
- **검증 포인트:** 같은 요일 유지, 7일 간격

#### 3. 매월 반복 - 31일 규칙
- **입력:**
  - 기준일: 2024-01-31
  - 반복: monthly, interval=1
  - 종료일: 2024-06-30
- **예상 출력:** ['2024-03-31', '2024-05-31'] (2월, 4월 건너뜀)
- **검증 포인트:** 31일 없는 달 건너뛰기

#### 4. 매년 반복 - 윤년 처리
- **입력:**
  - 기준일: 2024-02-29
  - 반복: yearly, interval=1
  - 생성 개수: 3개
- **예상 출력:** ['2028-02-29', '2032-02-29', '2036-02-29']
- **검증 포인트:** 윤년만 선택, 4년 주기 (정확히는 윤년 규칙)

### 예외 케이스

#### 1. 필수 값 누락
- **입력:** date 필드 없음
- **예상 출력:** { success: false, error: "기준 날짜는 필수입니다", dates: [] }

#### 2. 잘못된 반복 타입
- **입력:** repeat.type = 'hourly' (존재하지 않는 타입)
- **예상 출력:** { success: false, error: "유효하지 않은 반복 타입입니다", dates: [] }

#### 3. 종료일이 시작일보다 이전
- **입력:** 
  - 기준일: 2024-12-31
  - 종료일: 2024-01-01
- **예상 출력:** { success: false, error: "종료일은 시작일 이후여야 합니다", dates: [] }

#### 4. interval이 0
- **입력:** interval = 0
- **예상 출력:** { success: false, error: "반복 간격은 1 이상이어야 합니다", dates: [] }

### 엣지 케이스

#### 1. 최대 개수 제한
- **입력:**
  - 매일 반복
  - 종료일: 10년 후
  - 개수 제한 없음
- **예상 출력:** 
  - dates: 1000개 날짜
  - warning: "최대 1000개까지만 생성됩니다"
- **검증 포인트:** 무한 루프 방지

#### 2. 생성 가능 날짜 없음
- **입력:**
  - 기준일: 2024-02-30 (존재하지 않음)
  - 매월 반복
- **예상 출력:** { success: false, error: "존재하지 않는 날짜입니다", dates: [] }

#### 3. interval로 인한 모든 날짜 건너뛰기
- **입력:**
  - 기준일: 2024-01-31
  - 매월 반복, interval=1
  - 종료일: 2024-02-29 (2월만 포함)
- **예상 출력:** 
  - dates: []
  - warning: "조건을 만족하는 날짜가 없습니다"

#### 4. 연말/연초 경계
- **입력:**
  - 기준일: 2024-12-30
  - 매일 반복
  - 생성 개수: 5개
- **예상 출력:** ['2024-12-31', '2025-01-01', '2025-01-02', '2025-01-03', '2025-01-04']
- **검증 포인트:** 연도 전환 정확성

#### 5. 윤년/평년 경계 (매월 29일)
- **입력:**
  - 기준일: 2024-01-29
  - 매월 반복
  - 생성 개수: 3개
- **예상 출력:** ['2024-02-29', '2024-03-29', '2024-04-29']
- **검증 포인트:** 윤년 2월도 29일 생성

#### 6. RepeatType이 'none'
- **입력:** repeat.type = 'none'
- **예상 출력:** { success: true, dates: [] }
- **검증 포인트:** 에러 아님, 정상 처리

## 통합 가이드

### 기존 코드와의 관계

#### 재사용할 유틸리티
1. **formatDate(currentDate, day)** (src/utils/dateUtils.ts:104)
   - 계산된 Date 객체를 'YYYY-MM-DD' 문자열로 변환
   
2. **getDaysInMonth(year, month)** (src/utils/dateUtils.ts:6)
   - 매월 반복 시 해당 월의 날짜 존재 여부 확인용
   
3. **fillZero(value, size)** (src/utils/dateUtils.ts:100)
   - 날짜 포맷팅 시 사용 (formatDate에서 내부적으로 사용)

#### 연관된 컴포넌트
1. **App.tsx** - 일정 생성 폼
   - 반복 설정 UI (76-83번째 줄)
   - 일정 저장 시 이 유틸리티 호출 예상

2. **useEventOperations.ts** - 일정 CRUD 훅
   - saveEvent 함수에서 반복 일정 생성 로직 통합 예상
   - 단일 Event 저장이 아닌, 여러 Event 배열 생성 필요

#### 영향받는 타입
1. **Event** (src/types.ts:21)
   - id, date 필드 사용
   - 반복 일정마다 새 id 필요

2. **RepeatInfo** (src/types.ts:3)
   - type, interval, endDate 모두 활용

### 예상 사용처 (개념적)

#### 사용 예시 1: 일정 생성 시
```typescript
// useEventOperations.ts의 saveEvent 확장
import { generateRecurringDates } from './utils/recurringEvents';

const saveEvent = async (eventData: EventForm) => {
  // 반복 일정인 경우
  if (eventData.repeat.type !== 'none') {
    const result = generateRecurringDates(eventData, 100);
    
    if (!result.success) {
      // 에러 처리
      enqueueSnackbar(result.error, { variant: 'error' });
      return;
    }
    
    if (result.warning) {
      // 경고 표시
      enqueueSnackbar(result.warning, { variant: 'warning' });
    }
    
    // 각 날짜마다 Event 생성
    const events = result.dates.map(date => ({
      ...eventData,
      date,
      id: generateUniqueId() // ID 생성 필요
    }));
    
    // 여러 이벤트 한 번에 저장
    await saveMultipleEvents(events);
  } else {
    // 단일 일정
    await saveSingleEvent(eventData);
  }
};
```

#### 사용 예시 2: 미리보기
```typescript
// 일정 생성 폼에서 미리보기
const handleRepeatPreview = () => {
  const previewResult = generateRecurringDates(formData, 5); // 처음 5개만
  
  if (previewResult.success) {
    setPreviewDates(previewResult.dates);
    // UI에 "다음 5회 일정: 2024-02-01, 2024-02-02, ..." 표시
  }
};
```

## 성능 고려사항

### 시간 복잡도
- **매일/매주:** O(n) - n은 생성 개수
  - 단순 날짜 증가 연산
  
- **매월/매년:** O(n × k) - k는 건너뛴 달/해 확인 횟수
  - 최악의 경우: 매월 31일 기준 시 절반 이상 건너뜀
  - k는 작은 상수 (2-3 정도)

### 공간 복잡도
- **O(n)** - 생성된 날짜 배열 크기
- 최대 1000개 제한으로 메모리 사용 예측 가능
- 문자열 배열이므로 약 20KB (날짜당 20바이트 × 1000)

### 최적화 전략
1. **조기 종료:**
   - 종료일 도달 시 즉시 중단
   - 최대 개수 도달 시 즉시 중단

2. **건너뛰기 최적화:**
   - 매월 31일 반복 시 2/4/6/9/11월 자동 건너뜀
   - 날짜 유효성 검사 최소화

3. **캐싱 불필요:**
   - 계산이 빠르고 입력이 매번 다름
   - 메모이제이션 오버헤드가 더 클 수 있음

### 성능 제약
- **최대 생성 개수:** 1000개
- **예상 실행 시간:** 
  - 100개 생성: <1ms
  - 1000개 생성: <10ms
- **메모리 사용:** 최대 ~20KB

### 대용량 데이터 시나리오
- **10년치 매일 반복:** 3650개 → 1000개로 제한, 경고 표시
- **100년치 매년 반복:** 100개 → 정상 처리
- **실용적 제약:** 일반 사용자는 50개 이하 생성이 대부분

## 마이그레이션 가이드

### 영향받는 파일
1. **useEventOperations.ts** (src/hooks/)
   - saveEvent 함수 확장 필요
   - 단일 Event 저장 → 배열 처리 로직 추가

2. **App.tsx** (src/)
   - 반복 일정 저장 시 사용자 피드백 추가
   - 미리보기 기능 추가 가능

### 변경 사항

#### Before (현재 구조)
```typescript
// useEventOperations.ts
const saveEvent = async (eventData: Event | EventForm) => {
  const response = await fetch('/api/events', {
    method: 'POST',
    body: JSON.stringify(eventData),
  });
  // 단일 이벤트 저장
};
```

#### After (반복 일정 지원)
```typescript
// useEventOperations.ts
import { generateRecurringDates } from '../utils/recurringEvents';

const saveEvent = async (eventData: Event | EventForm) => {
  if (eventData.repeat.type !== 'none') {
    // 반복 일정 생성
    const result = generateRecurringDates(eventData);
    
    if (!result.success) {
      enqueueSnackbar(result.error, { variant: 'error' });
      return;
    }
    
    // 여러 이벤트 생성 (각각 고유 ID)
    const events = result.dates.map(date => ({
      ...eventData,
      date,
      id: crypto.randomUUID(),
    }));
    
    // 배치 저장
    await Promise.all(events.map(event => 
      fetch('/api/events', {
        method: 'POST',
        body: JSON.stringify(event),
      })
    ));
    
    enqueueSnackbar(`${events.length}개 일정이 생성되었습니다`, { variant: 'success' });
  } else {
    // 기존 단일 일정 저장 로직
    await fetch('/api/events', {
      method: 'POST',
      body: JSON.stringify(eventData),
    });
  }
};
```

### 호환성
- **하위 호환:** 가능
  - 기존 단일 일정 생성은 그대로 동작
  - repeat.type이 'none'이면 기존 로직 사용

- **점진적 마이그레이션:** 가능
  1. 유틸리티 함수 먼저 구현 및 테스트
  2. useEventOperations에 조건부 통합
  3. UI에 미리보기 기능 추가 (선택)

### 추가 구현 필요 사항
1. **서버 API 확장:**
   - 배치 이벤트 생성 API 필요 (또는 여러 번 호출)
   - `/api/events/batch` 엔드포인트 고려

2. **ID 생성 전략:**
   - `crypto.randomUUID()` 사용
   - 또는 서버에서 생성

3. **사용자 확인:**
   - 100개 이상 생성 시 확인 다이얼로그
   - "정말 365개 일정을 생성하시겠습니까?"

### 롤백 계획
- 유틸리티 함수는 독립적이므로 쉽게 제거 가능
- useEventOperations의 조건문만 제거하면 기존 동작으로 복구

---

## 🔍 주요 개선 사항 요약

### 1. 명확성 향상
- ✅ 함수 목적 명확화: "날짜 계산" 기능임을 강조
- ✅ 입출력 개념 구체화: 파라미터와 반환 타입 힌트 제공
- ✅ 에러 시나리오 상세화: 9가지 에러 케이스 명시

### 2. 완전성 보강
- ✅ RepeatInfo의 모든 필드 활용: interval, endDate 처리 추가
- ✅ 성능 제약 명시: 최대 1000개 제한
- ✅ 부분 성공 케이스 추가: 경고 메시지 포함

### 3. 프로젝트 통합성
- ✅ 파일 위치 명확화: src/utils/recurringEvents.ts
- ✅ 기존 유틸리티 재사용: formatDate, getDaysInMonth 등
- ✅ 기존 타입 재사용: Event, RepeatInfo
- ✅ 테스트 네이밍 일치: medium.recurringEvents.spec.ts

### 4. 구현 가이드 추가
- ✅ 사용 예시 2개 제공
- ✅ 마이그레이션 계획 포함
- ✅ Before/After 코드 비교

### 5. 엣지 케이스 강화
- ✅ 6가지 추가 엣지 케이스
- ✅ 경계 조건 상세화
- ✅ 성능 극단값 시나리오

---

## ✍️ 다음 단계 (Step 2 - 테스트 설계)

Step 2에서 다음을 구체화할 예정:
1. **정확한 함수 시그니처**
2. **인터페이스 정의** (결과 타입, 옵션 타입 등)
3. **구체적인 테스트 코드** (describe/it 구조)
4. **헬퍼 함수 설계** (윤년 판별, 날짜 유효성 등)
