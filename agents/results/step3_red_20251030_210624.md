```typescript
// filepath: src/__tests__/unit/scheduleRecurringRule.spec.ts

import { describe, it, expect } from 'vitest';
import { generateRecurringDates } from '../../utils/scheduleRecurringRule';

describe('Schedule Recurring Rule', () => {
  describe('매일 반복', () => {
    it('should generate daily recurring dates starting from 2024-01-31', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
    });

    it('should handle daily recurring across month boundary', () => {
      // Arrange
      const startDate = '2024-01-30';
      const repeatType = 'daily';
      const count = 5;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([
        '2024-01-31',
        '2024-02-01',
        '2024-02-02',
        '2024-02-03',
        '2024-02-04',
      ]);
    });

    it('should generate continuous daily dates', () => {
      // Arrange
      const startDate = '2024-02-28';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-29', '2024-03-01', '2024-03-02']);
    });
  });

  describe('매주 반복', () => {
    it('should generate weekly recurring dates on same day of week (Wednesday)', () => {
      // Arrange
      const startDate = '2024-01-31'; // Wednesday
      const repeatType = 'weekly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-07', '2024-02-14', '2024-02-21']);
    });

    it('should maintain same weekday across month boundaries', () => {
      // Arrange
      const startDate = '2024-01-29'; // Monday
      const repeatType = 'weekly';
      const count = 4;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([
        '2024-02-05',
        '2024-02-12',
        '2024-02-19',
        '2024-02-26',
      ]);
    });

    it('should generate weekly dates for any weekday', () => {
      // Arrange
      const startDate = '2024-02-03'; // Saturday
      const repeatType = 'weekly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-10', '2024-02-17', '2024-02-24']);
    });
  });

  describe('매월 반복', () => {
    it('should only generate on 31st day of month, skipping months without 31 days', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-31', '2024-05-31', '2024-07-31']);
    });

    it('should skip February when starting from 31st', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'monthly';
      const count = 5;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([
        '2024-03-31',
        '2024-05-31',
        '2024-07-31',
        '2024-08-31',
        '2024-10-31',
      ]);
      expect(result).not.toContain('2024-02-29');
    });

    it('should generate monthly on 15th consistently', () => {
      // Arrange
      const startDate = '2024-01-15';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-15', '2024-03-15', '2024-04-15']);
    });

    it('should handle monthly recurring for 30th day', () => {
      // Arrange
      const startDate = '2024-01-30';
      const repeatType = 'monthly';
      const count = 4;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([
        '2024-03-30',
        '2024-04-30',
        '2024-05-30',
        '2024-06-30',
      ]);
      expect(result).not.toContain('2024-02-30');
    });

    it('should skip months without the specified day for 29th', () => {
      // Arrange
      const startDate = '2024-01-29';
      const repeatType = 'monthly';
      const count = 5;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([
        '2024-02-29',
        '2024-03-29',
        '2024-04-29',
        '2024-05-29',
        '2024-06-29',
      ]);
    });

    it('should handle monthly recurring across leap year boundary', () => {
      // Arrange
      const startDate = '2024-02-29';
      const repeatType = 'monthly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-03-29', '2024-04-29', '2024-05-29']);
    });
  });

  describe('매년 반복', () => {
    it('should only generate on Feb 29th in leap years', () => {
      // Arrange
      const startDate = '2024-02-29';
      const repeatType = 'yearly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2028-02-29', '2032-02-29', '2036-02-29']);
    });

    it('should skip non-leap years for Feb 29th start date', () => {
      // Arrange
      const startDate = '2024-02-29';
      const repeatType = 'yearly';
      const count = 5;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([
        '2028-02-29',
        '2032-02-29',
        '2036-02-29',
        '2040-02-29',
        '2044-02-29',
      ]);
      expect(result).not.toContain('2025-02-29');
      expect(result).not.toContain('2026-02-29');
      expect(result).not.toContain('2027-02-29');
    });

    it('should generate yearly for regular dates consistently', () => {
      // Arrange
      const startDate = '2024-03-15';
      const repeatType = 'yearly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2025-03-15', '2026-03-15', '2027-03-15']);
    });

    it('should handle century leap year rule (2100 is not a leap year)', () => {
      // Arrange
      const startDate = '2096-02-29';
      const repeatType = 'yearly';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2104-02-29', '2108-02-29', '2112-02-29']);
      expect(result).not.toContain('2100-02-29');
    });
  });

  describe('경계 케이스 및 에러 처리', () => {
    it('should handle count of 0', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 0;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual([]);
    });

    it('should handle count of 1', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'weekly';
      const count = 1;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toEqual(['2024-02-07']);
    });

    it('should throw error for invalid date format', () => {
      // Arrange
      const startDate = 'invalid-date';
      const repeatType = 'daily';
      const count = 3;

      // Act & Assert
      expect(() => generateRecurringDates(startDate, repeatType, count)).toThrow();
    });

    it('should throw error for invalid repeat type', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'invalid' as any;
      const count = 3;

      // Act & Assert
      expect(() => generateRecurringDates(startDate, repeatType, count)).toThrow();
    });

    it('should throw error for negative count', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = -1;

      // Act & Assert
      expect(() => generateRecurringDates(startDate, repeatType, count)).toThrow();
    });

    it('should handle large count values efficiently', () => {
      // Arrange
      const startDate = '2024-01-01';
      const repeatType = 'daily';
      const count = 100;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      expect(result).toHaveLength(100);
      expect(result[0]).toBe('2024-01-02');
      expect(result[99]).toBe('2024-04-10');
    });

    it('should return dates in ISO 8601 format (YYYY-MM-DD)', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 3;

      // Act
      const result = generateRecurringDates(startDate, repeatType, count);

      // Assert
      result.forEach((date) => {
        expect(date).toMatch(/^\d{4}-\d{2}-\d{2}$/);
      });
    });
  });

  describe('일정 겹침 무시 (통합 테스트)', () => {
    it('should allow duplicate dates without checking for conflicts', () => {
      // Arrange
      const startDate = '2024-01-31';
      const repeatType = 'daily';
      const count = 3;

      // Act - 동일한 시작일로 여러 번 호출
      const result1 = generateRecurringDates(startDate, repeatType, count);
      const result2 = generateRecurringDates(startDate, repeatType, count);

      // Assert - 두 결과가 동일하며, 겹침 검사 없이 생성됨
      expect(result1).toEqual(result2);
      expect(result1).toEqual(['2024-02-01', '2024-02-02', '2024-02-03']);
    });
  });
});
```
