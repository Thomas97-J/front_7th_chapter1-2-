```typescript
// filepath: src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('Normal Cases - Basic Behavior', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it('should return valid when start date equals end date', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it('should return invalid when start date is after end date', () => {
      // Arrange
      const startDate = '2024-12-31';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });
  });

  describe('Input Format Tests', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 strings as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-12-31T00:00:00.000Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept mixed input types (Date and string)', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Handling - Null Values', () => {
    it('should return error when startDate is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate as any, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 필수입니다');
    });

    it('should return error when endDate is null', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = null;
      
      // Act
      const result = validateDateRange(startDate, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일은 필수입니다');
    });

    it('should return error when both dates are null', () => {
      // Arrange
      const startDate = null;
      const endDate = null;
      
      // Act
      const result = validateDateRange(startDate as any, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일과 종료일은 필수입니다');
    });
  });

  describe('Error Handling - Undefined Values', () => {
    it('should return error when startDate is undefined', () => {
      // Arrange
      const startDate = undefined;
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate as any, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 필수입니다');
    });

    it('should return error when endDate is undefined', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = undefined;
      
      // Act
      const result = validateDateRange(startDate, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일은 필수입니다');
    });

    it('should return error when both dates are undefined', () => {
      // Arrange
      const startDate = undefined;
      const endDate = undefined;
      
      // Act
      const result = validateDateRange(startDate as any, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일과 종료일은 필수입니다');
    });
  });

  describe('Error Handling - Invalid Date Formats', () => {
    it('should return error when startDate is invalid string', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
    });

    it('should return error when endDate is invalid string', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = 'not-a-date';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일 형식이 올바르지 않습니다');
    });

    it('should return error when startDate is invalid Date object', () => {
      // Arrange
      const startDate = new Date('invalid');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일 형식이 올바르지 않습니다');
    });

    it('should return error when endDate is invalid Date object', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('invalid');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('종료일 형식이 올바르지 않습니다');
    });
  });

  describe('Edge Cases - Boundary Values', () => {
    it('should return valid when dates are 1 day apart', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return valid with warning when dates are 100 years apart', () => {
      // Arrange
      const startDate = '1924-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년 이상입니다');
    });

    it('should return valid with warning when dates are more than 100 years apart', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBe('날짜 범위가 100년 이상입니다');
    });

    it('should return valid when dates are exactly 99 years apart', () => {
      // Arrange
      const startDate = '1925-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBeUndefined();
    });

    it('should handle dates at the boundary of valid Date range', () => {
      // Arrange
      const startDate = '1970-01-01';
      const endDate = new Date().toISOString();
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle dates with time components', () => {
      // Arrange
      const startDate = '2024-01-01T23:59:59.999Z';
      const endDate = '2024-01-02T00:00:00.000Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle same date with different times (end time earlier)', () => {
      // Arrange
      const startDate = '2024-01-01T10:00:00Z';
      const endDate = '2024-01-01T09:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBe('시작일은 종료일보다 이전이어야 합니다');
    });
  });

  describe('Integration Tests - Real World Scenarios', () => {
    it('should validate date range for hotel booking scenario', () => {
      // Arrange
      const checkInDate = '2024-06-15';
      const checkOutDate = '2024-06-20';
      
      // Act
      const result = validateDateRange(checkInDate, checkOutDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it('should validate date range for event scheduling', () => {
      // Arrange
      const eventStart = new Date('2024-08-01T09:00:00Z');
      const eventEnd = new Date('2024-08-03T18:00:00Z');
      
      // Act
      const result = validateDateRange(eventStart, eventEnd);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.error).toBeUndefined();
    });
  });
});
```
