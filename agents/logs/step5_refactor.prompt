# SYSTEM INSTRUCTION

You are a CODE REFACTORING AI. You MUST output complete, refactored TypeScript code immediately.

## 🚨 ABSOLUTE RULES

**FORBIDDEN RESPONSES:**
- ❌ "개선된 전체 코드가 추가되었습니다"
- ❌ "리팩토링이 완료되었습니다"
- ❌ "다음과 같이 개선했습니다:" without showing code
- ❌ Any explanation without actual code
- ❌ "I refactored..." without showing code

**MANDATORY:**
- ✅ START with: ```typescript
- ✅ SHOW complete refactored code
- ✅ Include // filepath: comment
- ✅ Write ALL functions (no ...)
- ✅ Code must be copy-paste ready

---

## Example of FORBIDDEN Response (❌):

"리팩토링이 완료되었습니다.

**개선 사항:**
1. 중복 제거
2. 함수 분리
3. 타입 개선

**2단계: 개선된 전체 코드**

개선된 코드는 다음과 같습니다..."

**This is WRONG! You MUST show the actual refactored code!**

---

## Example of CORRECT Response (✅):

**개선 포인트:**
- 중복 제거 (DRY)
- 상수 추출
- 헬퍼 함수 분리

**개선된 전체 코드:**

```typescript
// filepath: src/utils/[YOUR-ACTUAL-FILENAME].ts

// Import statements (if needed)
import { SomeType } from './types';

/**
 * Type definitions
 */
export interface YourResultType {
  // Define your interface
}

/**
 * Constants (extract magic numbers/strings)
 */
const YOUR_CONSTANTS = {
  KEY_1: 'value1',
  KEY_2: 100
} as const;

/**
 * Main exported function with JSDoc
 * 
 * @param param1 - Description
 * @param param2 - Description
 * @returns Description
 */
export function yourMainFunction(
  param1: Type1,
  param2: Type2
): ReturnType {
  // Implement using helper functions
  // Apply refactoring principles:
  // - DRY (Don't Repeat Yourself)
  // - Single Responsibility
  // - Clear naming
  
  const result = helperFunction1(param1);
  
  if (!result) {
    return createError('Error message');
  }
  
  return processResult(result, param2);
}

/**
 * Helper function 1
 */
function helperFunction1(param: Type): ResultType | null {
  // Complete implementation
}

/**
 * Helper function 2
 */
function helperFunction2(param: Type): ResultType {
  // Complete implementation
}

/**
 * Error factory
 */
function createError(message: string): ErrorType {
  return { success: false, error: message };
}
```

**REMEMBER:**
- Replace `[YOUR-ACTUAL-FILENAME]` with actual file path from spec
- Replace `yourMainFunction` with actual function name
- Replace `YourResultType` with actual types
- Write COMPLETE implementation (no `...` placeholders)

---


## 원본 명세

# 📅 Schedule Recurring Rule Spec

_반복 일정 생성 로직 테스트 명세_

---

## 🧾 목적

반복 일정 생성 로직이 올바르게 동작하는지 검증한다.  
각 반복 유형(매일, 매주, 매월, 매년)에 대해 정확한 날짜 계산과 예외 처리를 수행해야 한다.

---

## ⚙️ 사전 조건

- 기준 일정: **2024-01-31 (수요일)**
- 반복 옵션: `매일`, `매주`, `매월`, `매년`
- 날짜 형식: `YYYY-MM-DD` (ISO 8601)
- **일정 겹침은 고려하지 않음**

---

## 🧩 테스트 시나리오

### 1️⃣ 매일 반복

**Given:** 시작일이 `2024-01-31`  
**When:** 반복 유형이 `매일`일 때  
**Then:**

- 다음 일정은 `2024-02-01`에 생성되어야 한다.
- 이후 일정은 하루씩 증가한다.

| 반복 횟수 | 예상 날짜  |
| :-------: | :--------: |
|   1회차   | 2024-02-01 |
|   2회차   | 2024-02-02 |
|   3회차   | 2024-02-03 |

---

### 2️⃣ 매주 반복

**Given:** 시작일이 `2024-01-31 (수요일)`  
**When:** 반복 유형이 `매주`일 때  
**Then:**

- 매주 같은 요일(수요일)에 생성된다.
- 다음 일정은 `2024-02-07`이다.

| 반복 횟수 | 예상 날짜  |
| :-------: | :--------: |
|   1회차   | 2024-02-07 |
|   2회차   | 2024-02-14 |
|   3회차   | 2024-02-21 |

---

### 3️⃣ 매월 반복

**Given:** 시작일이 `2024-01-31`  
**When:** 반복 유형이 `매월`일 때  
**Then:**

- “매월 마지막일”이 아닌, “**31일에만**” 생성되어야 한다.
- 2월에는 31일이 없으므로 일정이 생성되지 않는다.
- 다음 생성일은 `2024-03-31`이다.

| 반복 횟수 | 예상 날짜  |
| :-------: | :--------: |
|   1회차   | 2024-03-31 |
|   2회차   | 2024-05-31 |

---

### 4️⃣ 매년 반복

**Given:** 시작일이 `2024-02-29 (윤년)`  
**When:** 반복 유형이 `매년`일 때  
**Then:**

- **2월 29일에만 생성되어야 한다.**
- 다음 일정은 다음 윤년인 `2028-02-29`이다.

| 반복 횟수 | 예상 날짜  |
| :-------: | :--------: |
|   1회차   | 2028-02-29 |
|   2회차   | 2032-02-29 |

---

### 5️⃣ 반복 일정 겹침 무시

**Given:** 이미 다른 일정이 존재하는 날짜에도  
**When:** 반복 생성 로직이 실행될 때  
**Then:**

- 일정 겹침 여부를 확인하지 않는다.
- 동일한 날짜에 중복 생성이 허용된다.

---

## ✅ 기대 결과

- 모든 반복 유형에 대해 예외 날짜 및 규칙이 정확히 적용된다.
- 일정 겹침과 무관하게 반복 일정이 생성된다.
- 매월/매년 예외 조건(31일, 윤년 29일) 처리 로직이 정확히 동작한다.

---

## 📁 파일명

## 현재 GREEN 단계 구현 코드

```typescript
// filepath: src/utils/scheduleRecurringRule.ts

import { Event, RepeatType } from '../types';

/**
 * 반복 일정 생성 결과 인터페이스
 */
export interface RecurringEventResult {
  date: string;
  event: Event;
}

/**
 * 반복 일정 생성 옵션
 */
export interface RecurringRuleOptions {
  interval?: number;
  count?: number;
}

/**
 * 주어진 일정에 대해 반복 규칙에 따라 다음 일정 날짜들을 생성합니다.
 * 
 * @param baseEvent - 기준이 되는 일정
 * @param repeatType - 반복 유형 ('daily' | 'weekly' | 'monthly' | 'yearly')
 * @param count - 생성할 반복 일정 개수 (기본값: 10)
 * @returns 생성된 반복 일정 날짜 배열
 */
export function generateRecurringDates(
  baseEvent: Event,
  repeatType: RepeatType,
  count: number = 10
): string[] {
  if (!baseEvent || !baseEvent.date) {
    return [];
  }

  const dates: string[] = [];
  const baseDate = new Date(baseEvent.date);

  if (isNaN(baseDate.getTime())) {
    return [];
  }

  const baseDay = baseDate.getDate();
  const baseMonth = baseDate.getMonth();
  const baseYear = baseDate.getFullYear();
  const baseDayOfWeek = baseDate.getDay();

  let currentDate = new Date(baseDate);
  let attempts = 0;
  const maxAttempts = count * 1000; // 무한루프 방지

  while (dates.length < count && attempts < maxAttempts) {
    attempts++;

    switch (repeatType) {
      case 'daily':
        currentDate.setDate(currentDate.getDate() + 1);
        dates.push(formatDate(currentDate));
        break;

      case 'weekly':
        currentDate.setDate(currentDate.getDate() + 7);
        dates.push(formatDate(currentDate));
        break;

      case 'monthly':
        // 매월 같은 일(day)에만 생성
        currentDate.setMonth(currentDate.getMonth() + 1);
        
        // 해당 월에 기준일이 존재하는지 확인
        if (currentDate.getDate() === baseDay) {
          dates.push(formatDate(currentDate));
        } else {
          // 날짜가 넘어간 경우 (예: 31일이 없는 달)
          // 다음 달로 이미 넘어갔으므로, 날짜를 기준일로 맞춰서 다시 시도
          currentDate.setDate(0); // 이전 달 마지막 날
          const lastDayOfPrevMonth = currentDate.getDate();
          
          if (baseDay > lastDayOfPrevMonth) {
            // 기준일이 해당 월에 존재하지 않음 - 건너뜀
            currentDate.setMonth(currentDate.getMonth() + 1);
            currentDate.setDate(baseDay);
          } else {
            currentDate.setDate(baseDay);
            dates.push(formatDate(currentDate));
          }
        }
        break;

      case 'yearly':
        // 매년 같은 월-일에만 생성
        currentDate.setFullYear(currentDate.getFullYear() + 1);
        
        // 윤년 2월 29일 처리
        if (baseMonth === 1 && baseDay === 29) {
          // 윤년인지 확인
          if (isLeapYear(currentDate.getFullYear())) {
            currentDate.setMonth(baseMonth);
            currentDate.setDate(baseDay);
            dates.push(formatDate(currentDate));
          } else {
            // 윤년이 아니면 건너뜀
            currentDate.setMonth(baseMonth);
            currentDate.setDate(1); // 날짜 리셋
          }
        } else {
          // 일반적인 경우
          if (currentDate.getDate() === baseDay && currentDate.getMonth() === baseMonth) {
            dates.push(formatDate(currentDate));
          } else {
            // 날짜가 맞지 않으면 (월말 처리)
            currentDate.setMonth(baseMonth);
            currentDate.setDate(baseDay);
            
            // 해당 월에 그 날짜가 존재하는지 확인
            if (currentDate.getDate() === baseDay) {
              dates.push(formatDate(currentDate));
            }
          }
        }
        break;

      default:
        return dates;
    }
  }

  return dates;
}

/**
 * 윤년 여부를 확인합니다.
 * 
 * @param year - 확인할 연도
 * @returns 윤년이면 true, 아니면 false
 */
function isLeapYear(year: number): boolean {
  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

/**
 * Date 객체를 YYYY-MM-DD 형식 문자열로 변환합니다.
 * 
 * @param date - 변환할 Date 객체
 * @returns YYYY-MM-DD 형식의 날짜 문자열
 */
function formatDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * 반복 일정을 생성하고 Event 객체 배열로 반환합니다.
 * 
 * @param baseEvent - 기준 일정
 * @param count - 생성할 반복 일정 개수
 * @returns 생성된 반복 일정 배열
 */
export function createRecurringEvents(
  baseEvent: Event,
  count: number = 10
): Event[] {
  if (!baseEvent || !baseEvent.repeat.type || baseEvent.repeat.type === 'none') {
    return [];
  }

  const dates = generateRecurringDates(baseEvent, baseEvent.repeat.type, count);
  
  return dates.map((date, index) => ({
    ...baseEvent,
    id: `${baseEvent.id}_recurring_${index + 1}`,
    date,
    repeat: {
      ...baseEvent.repeat
    }
  }));
}
```

---

## YOUR TASK: Refactor the Code Above

### Refactoring Checklist:
- [ ] Remove duplication (DRY principle)
- [ ] Extract magic numbers/strings to constants
- [ ] Split large functions (Single Responsibility Principle)
- [ ] Improve naming (clear, descriptive names)
- [ ] Add/improve TypeScript types
- [ ] Add JSDoc comments to public APIs
- [ ] Reduce complexity (cyclomatic complexity)
- [ ] Improve error messages

### Critical Requirements:
1. **Keep the same functionality** - All existing tests MUST pass
2. **Use EXACT file path** from current implementation
3. **Keep same exports** (function names, interface names)
4. **Write COMPLETE code** - No `...` or `// existing code` placeholders
5. **Ready to run** - Copy & paste should work immediately

**BEGIN NOW. Output format:**

## ✅ REQUIRED

You MUST respond with:
- Actual refactored TypeScript code
- Starting with ```typescript
- Complete implementation
- All functions fully written
- Ready to use immediately

**BEGIN NOW. WRITE THE COMPLETE REFACTORED CODE:**

