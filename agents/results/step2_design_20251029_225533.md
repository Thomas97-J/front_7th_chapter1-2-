프로젝트 구조를 파악했습니다. 이제 날짜 범위 검증 함수에 대한 포괄적인 테스트 케이스를 설계하겠습니다.

---

# 테스트 스위트: validateDateRange (날짜 범위 검증)

## Unit Tests

### 테스트 케이스 1
- **이름**: should return valid when startDate is before endDate
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 '2024-01-01', 종료일이 '2024-01-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 2
- **이름**: should return valid when startDate equals endDate
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-01-15'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 3
- **이름**: should return invalid with error when startDate is after endDate
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 '2024-02-01', 종료일이 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다.' }`를 반환한다

### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 Date 객체로 전달되는 경우
- **When**: validateDateRange(new Date('2024-01-01'), new Date('2024-01-31'))를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 ISO 8601 문자열로 전달되는 경우
- **When**: validateDateRange('2024-01-01T00:00:00.000Z', '2024-01-31T23:59:59.999Z')를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 6
- **이름**: should return invalid when startDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null인 경우
- **When**: validateDateRange(null, '2024-01-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다.' }`를 반환한다

### 테스트 케이스 7
- **이름**: should return invalid when endDate is null
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 null인 경우
- **When**: validateDateRange('2024-01-01', null)를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다.' }`를 반환한다

### 테스트 케이스 8
- **이름**: should return invalid when startDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined인 경우
- **When**: validateDateRange(undefined, '2024-01-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다.' }`를 반환한다

### 테스트 케이스 9
- **이름**: should return invalid when endDate is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 undefined인 경우
- **When**: validateDateRange('2024-01-01', undefined)를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다.' }`를 반환한다

### 테스트 케이스 10
- **이름**: should return invalid when startDate format is invalid
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 잘못된 형식 'invalid-date'인 경우
- **When**: validateDateRange('invalid-date', '2024-01-31')를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다.' }`를 반환한다

### 테스트 케이스 11
- **이름**: should return invalid when endDate format is invalid
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 잘못된 형식 'not-a-date'인 경우
- **When**: validateDateRange('2024-01-01', 'not-a-date')를 호출할 때
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다.' }`를 반환한다

### 테스트 케이스 12
- **이름**: should return invalid when startDate is Invalid Date object
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 new Date('invalid')로 생성된 Invalid Date인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다.' }`를 반환한다

## Edge Cases

### 테스트 케이스 13
- **이름**: should return valid when dates are 1 day apart
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일이 '2024-01-01', 종료일이 '2024-01-02'인 경우 (1일 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 14
- **이름**: should return valid when dates are 1 second apart
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-01-01T00:00:00', 종료일이 '2024-01-01T00:00:01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 15
- **이름**: should return valid with warning when dates are more than 100 years apart
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '1900-01-01', 종료일이 '2024-01-01'인 경우 (100년 이상 차이)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '기간이 100년을 초과합니다.' }`를 반환한다

### 테스트 케이스 16
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-02-29' (윤년), 종료일이 '2024-03-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 17
- **이름**: should handle year boundary correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2023-12-31', 종료일이 '2024-01-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 18
- **이름**: should handle month boundary correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-01-31', 종료일이 '2024-02-01'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 19
- **이름**: should handle timezone differences correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-01-01T23:00:00+09:00', 종료일이 '2024-01-02T01:00:00+09:00'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 20
- **이름**: should handle dates at the edge of time (year 1970)
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '1970-01-01', 종료일이 '1970-01-02'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 21
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2024-01-01', 종료일이 '2099-12-31'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '기간이 100년을 초과합니다.' }`를 반환한다

### 테스트 케이스 22
- **이름**: should handle midnight edge case
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 '2024-01-01T00:00:00.000Z', 종료일이 '2024-01-01T23:59:59.999Z'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 23
- **이름**: should handle millisecond precision
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 '2024-01-01T12:00:00.001Z', 종료일이 '2024-01-01T12:00:00.002Z'인 경우
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

## Integration Tests

### 테스트 케이스 24
- **이름**: should work with form input dates
- **타입**: integration
- **우선순위**: medium
- **Given**: HTML input[type="date"]에서 받은 'YYYY-MM-DD' 형식의 문자열인 경우
- **When**: validateDateRange('2024-01-15', '2024-01-20')를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 25
- **이름**: should work with datetime-local input
- **타입**: integration
- **우선순위**: medium
- **Given**: HTML input[type="datetime-local"]에서 받은 형식의 문자열인 경우
- **When**: validateDateRange('2024-01-15T10:00', '2024-01-15T14:00')를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

### 테스트 케이스 26
- **이름**: should work with API response dates
- **타입**: integration
- **우선순위**: high
- **Given**: API에서 받은 ISO 8601 형식의 날짜 문자열인 경우
- **When**: validateDateRange('2024-01-01T00:00:00.000Z', '2024-12-31T23:59:59.999Z')를 호출할 때
- **Then**: `{ isValid: true }`를 반환한다

---

## 테스트 구현 예시

```typescript
import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('validateDateRange >', () => {
  describe('기본 동작 >', () => {
    it('should return valid when startDate is before endDate', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should return valid when startDate equals endDate', () => {
      // Arrange
      const startDate = '2024-01-15';
      const endDate = '2024-01-15';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should return invalid with error when startDate is after endDate', () => {
      // Arrange
      const startDate = '2024-02-01';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일은 종료일보다 이전이어야 합니다.',
      });
    });
  });

  describe('입력 타입 검증 >', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-31');

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should accept ISO 8601 strings as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-01-31T23:59:59.999Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });

  describe('에러 처리 >', () => {
    it('should return invalid when startDate is null', () => {
      // Arrange & Act
      const result = validateDateRange(null, '2024-01-31');

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일은 필수입니다.',
      });
    });

    it('should return invalid when endDate is null', () => {
      // Arrange & Act
      const result = validateDateRange('2024-01-01', null);

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '종료일은 필수입니다.',
      });
    });

    it('should return invalid when startDate is undefined', () => {
      // Arrange & Act
      const result = validateDateRange(undefined, '2024-01-31');

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일은 필수입니다.',
      });
    });

    it('should return invalid when endDate is undefined', () => {
      // Arrange & Act
      const result = validateDateRange('2024-01-01', undefined);

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '종료일은 필수입니다.',
      });
    });

    it('should return invalid when startDate format is invalid', () => {
      // Arrange & Act
      const result = validateDateRange('invalid-date', '2024-01-31');

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일 형식이 올바르지 않습니다.',
      });
    });

    it('should return invalid when endDate format is invalid', () => {
      // Arrange & Act
      const result = validateDateRange('2024-01-01', 'not-a-date');

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '종료일 형식이 올바르지 않습니다.',
      });
    });

    it('should return invalid when startDate is Invalid Date object', () => {
      // Arrange
      const invalidDate = new Date('invalid');

      // Act
      const result = validateDateRange(invalidDate, '2024-01-31');

      // Assert
      expect(result).toEqual({
        isValid: false,
        error: '시작일 형식이 올바르지 않습니다.',
      });
    });
  });

  describe('엣지 케이스 >', () => {
    it('should return valid when dates are 1 day apart', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should return valid when dates are 1 second apart', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00';
      const endDate = '2024-01-01T00:00:01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should return valid with warning when dates are more than 100 years apart', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({
        isValid: true,
        warning: '기간이 100년을 초과합니다.',
      });
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should handle year boundary correctly', () => {
      // Arrange
      const startDate = '2023-12-31';
      const endDate = '2024-01-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should handle month boundary correctly', () => {
      // Arrange
      const startDate = '2024-01-31';
      const endDate = '2024-02-01';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should handle timezone differences correctly', () => {
      // Arrange
      const startDate = '2024-01-01T23:00:00+09:00';
      const endDate = '2024-01-02T01:00:00+09:00';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should handle dates at the edge of time (year 1970)', () => {
      // Arrange
      const startDate = '1970-01-01';
      const endDate = '1970-01-02';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should handle far future dates', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2099-12-31';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({
        isValid: true,
        warning: '기간이 100년을 초과합니다.',
      });
    });

    it('should handle midnight edge case', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-01-01T23:59:59.999Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should handle millisecond precision', () => {
      // Arrange
      const startDate = '2024-01-01T12:00:00.001Z';
      const endDate = '2024-01-01T12:00:00.002Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });

  describe('통합 테스트 >', () => {
    it('should work with form input dates', () => {
      // Arrange - HTML input[type="date"] format
      const startDate = '2024-01-15';
      const endDate = '2024-01-20';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should work with datetime-local input', () => {
      // Arrange - HTML input[type="datetime-local"] format
      const startDate = '2024-01-15T10:00';
      const endDate = '2024-01-15T14:00';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });

    it('should work with API response dates', () => {
      // Arrange - ISO 8601 from API
      const startDate = '2024-01-01T00:00:00.000Z';
      const endDate = '2024-12-31T23:59:59.999Z';

      // Act
      const result = validateDateRange(startDate, endDate);

      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });
});
```

---

## 테스트 커버리지 목표

- **Line Coverage**: 100%
- **Branch Coverage**: 100%
- **Function Coverage**: 100%

## 실행 방법

```bash
# 모든 테스트 실행
pnpm test validateDateRange

# UI 모드로 실행
pnpm test:ui

# 커버리지 포함 실행
pnpm test:coverage
```

이 테스트 설계는 총 26개의 테스트 케이스를 포함하며, 기본 동작부터 엣지 케이스, 통합 테스트까지 포괄적으로 다룹니다. AAA 패턴을 따르고 있으며, 각 테스트는 독립적이고 명확한 의도를 가지고 있습니다.
