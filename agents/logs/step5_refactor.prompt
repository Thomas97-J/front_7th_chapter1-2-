# SYSTEM: 당신은 TDD REFACTOR 단계 전문가입니다. 항상 즉시 개선된 구현 코드를 작성합니다.


**즉시 개선된 코드를 작성하세요. 권한 요청 없이 바로 작성합니다.**

당신의 역할:
- ✅ 즉시 개선된 구현 코드 작성
- ❌ 권한 요청 금지
- ❌ 확인 질문 금지
- ❌ 설명만 제공 금지

## 원본 명세

# 예제 기능 명세: 날짜 범위 검증 함수

## 기능 설명
두 날짜 사이의 기간이 유효한지 검증하는 함수를 구현합니다.

## 요구사항

### 1. 기본 동작
- 시작일과 종료일을 입력받습니다
- 시작일이 종료일보다 이전이면 유효합니다
- 시작일과 종료일이 같으면 유효합니다

### 2. 입력
- `startDate`: Date 객체 또는 ISO 8601 문자열
- `endDate`: Date 객체 또는 ISO 8601 문자열

### 3. 출력
- 유효한 경우: `{ isValid: true }`
- 무효한 경우: `{ isValid: false, error: string }`

### 4. 에러 처리
- null 또는 undefined 입력시 에러
- 잘못된 날짜 형식 입력시 에러
- 시작일이 종료일보다 이후인 경우 에러

### 5. 엣지 케이스
- 같은 날짜: 유효
- 1일 차이: 유효
- 100년 이상 차이: 유효 (경고 메시지)

## GREEN 단계 구현 코드

```typescript
// filepath: src/utils/validateDateRange.ts

export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

export function validateDateRange(
  startDate: Date | string | null | undefined,
  endDate: Date | string | null | undefined
): ValidationResult {
  // 1. Null/undefined checks
  if (!startDate && !endDate) {
    return {
      isValid: false,
      error: '시작일과 종료일은 필수입니다'
    };
  }
  
  if (!startDate) {
    return {
      isValid: false,
      error: '시작일은 필수입니다'
    };
  }
  
  if (!endDate) {
    return {
      isValid: false,
      error: '종료일은 필수입니다'
    };
  }
  
  // 2. Parse dates
  const parsedStartDate = parseDate(startDate);
  const parsedEndDate = parseDate(endDate);
  
  // 3. Validate parsed dates
  if (!parsedStartDate) {
    return {
      isValid: false,
      error: '유효하지 않은 시작일 형식입니다'
    };
  }
  
  if (!parsedEndDate) {
    return {
      isValid: false,
      error: '유효하지 않은 종료일 형식입니다'
    };
  }
  
  if (!isValidDate(parsedStartDate)) {
    return {
      isValid: false,
      error: '유효하지 않은 시작일 형식입니다'
    };
  }
  
  if (!isValidDate(parsedEndDate)) {
    return {
      isValid: false,
      error: '유효하지 않은 종료일 형식입니다'
    };
  }
  
  // 4. Compare dates
  if (parsedStartDate.getTime() > parsedEndDate.getTime()) {
    return {
      isValid: false,
      error: '시작일은 종료일보다 이전이어야 합니다'
    };
  }
  
  // 5. Check for 100-year difference (warning)
  const yearsDiff = (parsedEndDate.getTime() - parsedStartDate.getTime()) / (1000 * 60 * 60 * 24 * 365.25);
  
  if (yearsDiff > 100) {
    return {
      isValid: true,
      warning: '날짜 범위가 100년을 초과합니다'
    };
  }
  
  return { isValid: true };
}

// Helper functions
function parseDate(date: Date | string): Date | null {
  try {
    if (date instanceof Date) {
      return date;
    }
    
    if (typeof date === 'string') {
      const parsed = new Date(date);
      return parsed;
    }
    
    return null;
  } catch {
    return null;
  }
}

function isValidDate(date: Date): boolean {
  return date instanceof Date && !isNaN(date.getTime());
}
```

---

## 🎯 작업: 코드 리팩토링

### 리팩토링 체크리스트:
- [ ] 중복 제거 (DRY 원칙)
- [ ] 명명 개선 (의도를 명확히)
- [ ] 함수 분리 (단일 책임)
- [ ] 매직 넘버/스트링 → 상수로 추출
- [ ] 복잡도 감소
- [ ] TypeScript 타입 개선
- [ ] JSDoc 주석 추가

### 출력 형식:

**1단계: 개선 포인트 (간단히)**
```markdown
- 개선사항 1
- 개선사항 2
- 개선사항 3
```

**2단계: 개선된 전체 코드**
```typescript
// filepath: src/utils/[실제파일명].ts

// 전체 리팩토링된 코드를 작성하세요
// 절대로 "..."로 생략하지 마세요!

export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

// 상수 정의
const ERROR_MESSAGES = {
  // ...
} as const;

export function mainFunction(...): ReturnType {
  // 전체 구현
}

// 헬퍼 함수들
function helperFunction1(...) {
  // 전체 구현
}
```

## ⚠️ 중요 규칙:

1. ✅ **filepath 주석 필수** (첫 줄)
2. ✅ **전체 코드 작성** (생략 금지)
3. ✅ **복사 후 바로 실행 가능**해야 함
4. ✅ **모든 테스트 통과** 보장
5. ❌ **"...existing code..." 절대 금지**

**지금 바로 리팩토링된 전체 코드를 작성하세요!**
