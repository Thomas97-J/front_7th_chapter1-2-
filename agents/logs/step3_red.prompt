# SYSTEM: 당신은 테스트 코드 생성 전문 AI입니다. 항상 즉시 테스트 코드를 작성합니다.

## 🚨 CRITICAL INSTRUCTION

**YOU MUST WRITE CODE IMMEDIATELY. NO PERMISSION REQUESTS. NO EXPLANATIONS.**

당신의 역할:
- ✅ 즉시 테스트 코드 작성
- ❌ 구현 코드 작성 금지
- ❌ 권한 요청 금지
- ❌ 확인 질문 금지
- ❌ 설명만 제공 금지

## 원본 명세

# 예제 기능 명세: 날짜 범위 검증 함수

## 기능 설명
두 날짜 사이의 기간이 유효한지 검증하는 함수를 구현합니다.

## 요구사항

### 1. 기본 동작
- 시작일과 종료일을 입력받습니다
- 시작일이 종료일보다 이전이면 유효합니다
- 시작일과 종료일이 같으면 유효합니다

### 2. 입력
- `startDate`: Date 객체 또는 ISO 8601 문자열
- `endDate`: Date 객체 또는 ISO 8601 문자열

### 3. 출력
- 유효한 경우: `{ isValid: true }`
- 무효한 경우: `{ isValid: false, error: string }`

### 4. 에러 처리
- null 또는 undefined 입력시 에러
- 잘못된 날짜 형식 입력시 에러
- 시작일이 종료일보다 이후인 경우 에러

### 5. 엣지 케이스
- 같은 날짜: 유효
- 1일 차이: 유효
- 100년 이상 차이: 유효 (경고 메시지)

## 테스트 설계

명세를 분석하여 체계적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-12-31'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일이 종료일보다 이후일 수 없습니다' }` 반환

### Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 된 시작일과 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 처리되고 `{ isValid: true }` 반환

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 형식 문자열 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 파싱되고 `{ isValid: true }` 반환

#### 테스트 케이스 6
- **이름**: should accept mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 ISO 8601 문자열
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 올바르게 처리되고 `{ isValid: true }` 반환

### Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 8
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }` 반환

#### 테스트 케이스 9
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }` 반환

#### 테스트 케이스 10
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }` 반환

#### 테스트 케이스 11
- **이름**: should return error when start date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 'invalid-date'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 시작일 형식입니다' }` 반환

#### 테스트 케이스 12
- **이름**: should return error when end date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 종료일이 'not-a-date'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '유효하지 않은 종료일 형식입니다' }` 반환

#### 테스트 케이스 13
- **이름**: should return error when date string is malformed
- **타입**: unit
- **우선순위**: medium
- **Given**: 날짜 문자열 '2024-13-45' (존재하지 않는 월/일)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: ... }` 반환

### Edge Cases - 경계값 테스트

#### 테스트 케이스 14
- **이름**: should return valid when dates differ by exactly 1 day
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-01-02'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates differ by more than 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '1900-01-01'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }` 반환

#### 테스트 케이스 16
- **이름**: should handle dates at midnight correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-01-01T00:00:00Z'과 종료일 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 17
- **이름**: should handle dates at end of day correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-01-01T23:59:59Z'과 종료일 '2024-01-02T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 18
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2024-02-29'과 종료일 '2024-03-01' (2024는 윤년)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 19
- **이름**: should handle year boundary correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2023-12-31'과 종료일 '2024-01-01'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 20
- **이름**: should handle very old dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '1900-01-01'과 종료일 '1900-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

#### 테스트 케이스 21
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일 '2100-01-01'과 종료일 '2100-12-31'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }` 반환

### Edge Cases - 타임존 처리

#### 테스트 케이스 22
- **이름**: should handle different timezone formats
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-01-01T00:00:00+09:00'과 종료일 '2024-01-01T00:00:00Z'
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 타임존을 고려하여 올바르게 비교

#### 테스트 케이스 23
- **이름**: should normalize dates to UTC for comparison
- **타입**: edge
- **우선순위**: low
- **Given**: 서로 다른 타임존의 날짜들
- **When**: validateDateRange 함수를 호출할 때
- **Then**: UTC 기준으로 정확히 비교

---

## 테스트 구현 가이드

### 테스트 파일 구조
```
src/__tests__/utils/validateDateRange.test.ts
```

### 주요 테스트 패턴

**AAA 패턴 예시:**
```typescript
test('should return valid when start date is before end date', () => {
  // Arrange
  const startDate = '2024-01-01';
  const endDate = '2024-12-31';
  
  // Act
  const result = validateDateRange(startDate, endDate);
  
  // Assert
  expect(result).toEqual({ isValid: true });
});
```

### 테스트 실행 우선순위
1. **High Priority** (13개): 핵심 기능과 에러 처리
2. **Medium Priority** (5개): 입력 형식 변환과 주요 엣지 케이스
3. **Low Priority** (5개): 상세한 경계값과 타임존 처리

이 설계는 총 23개의 테스트 케이스로 구성되어 있으며, 명세의 모든 요구사항을 커버합니다.

---

## TASK: Write Vitest Test Code

### Requirements:
- Vitest framework
- TypeScript
- AAA pattern
- 15+ test cases
- All edge cases
- Ready to run

### Output Format:

**START YOUR RESPONSE WITH CODE BLOCK. NO TEXT BEFORE CODE.**

```typescript
// filepath: src/__tests__/unit/[name].spec.ts

import { describe, it, expect } from 'vitest';
import { functionName } from '../../utils/fileName';

describe('Feature Name', () => {
  describe('Normal Cases', () => {
    it('should work with valid input', () => {
      // Arrange
      const input = 'test';
      
      // Act
      const result = functionName(input);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Cases', () => {
    it('should handle null', () => {
      // Arrange
      const input = null;
      
      // Act
      const result = functionName(input);
      
      // Assert
      expect(result.isValid).toBe(false);
    });
  });
});
```

### FORBIDDEN:
- ❌ "I need permission to..."
- ❌ "Please approve..."
- ❌ "..." or "existing code"

### MANDATORY:
- ✅ Start with ```typescript
- ✅ Include // filepath: comment
- ✅ Write complete code
- ✅ 15+ test cases

## 🚀 BEGIN NOW
