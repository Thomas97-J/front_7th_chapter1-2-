# 테스트 설계 문서: Schedule Recurring Rule

## 📋 테스트 개요

**대상 모듈**: `scheduleRecurringRule`  
**테스트 프레임워크**: Vitest  
**테스트 파일 위치**: `src/__tests__/unit/scheduleRecurringRule.spec.ts`  
**테스트 타입**: Unit Tests (순수 함수 검증)

---

## 🎯 테스트 전략

1. **가장 단순한 케이스부터 시작** (매일 반복)
2. **각 반복 유형별로 독립적 검증**
3. **경계 조건 및 예외 상황 집중 검증** (31일, 윤년)
4. **외부 의존성 없음** (순수 함수 가정)

---

## 🧪 테스트 스위트: Daily Recurrence

### 테스트 케이스 1.1
- **이름**: `should generate next day when recurring daily`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `daily`이고 1개의 반복 일정을 생성할 때
- **Then**: `2024-02-01` 날짜가 반환되어야 함

### 테스트 케이스 1.2
- **이름**: `should generate multiple consecutive days when recurring daily`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `daily`이고 3개의 반복 일정을 생성할 때
- **Then**: `['2024-02-01', '2024-02-02', '2024-02-03']` 배열이 반환되어야 함

### 테스트 케이스 1.3
- **이름**: `should handle month boundary correctly when recurring daily`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-30`
- **When**: 반복 유형이 `daily`이고 5개의 반복 일정을 생성할 때
- **Then**: 1월 31일 → 2월 1일 경계를 올바르게 넘어야 함

---

## 🧪 테스트 스위트: Weekly Recurrence

### 테스트 케이스 2.1
- **이름**: `should generate same weekday when recurring weekly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31` (수요일)
- **When**: 반복 유형이 `weekly`이고 1개의 반복 일정을 생성할 때
- **Then**: `2024-02-07` (수요일)이 반환되어야 함

### 테스트 케이스 2.2
- **이름**: `should generate multiple weeks with same weekday when recurring weekly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31` (수요일)
- **When**: 반복 유형이 `weekly`이고 3개의 반복 일정을 생성할 때
- **Then**: `['2024-02-07', '2024-02-14', '2024-02-21']` 배열이 반환되어야 함 (모두 수요일)

### 테스트 케이스 2.3
- **이름**: `should preserve weekday across month boundaries when recurring weekly`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-31` (수요일)
- **When**: 반복 유형이 `weekly`이고 5개의 반복 일정을 생성할 때
- **Then**: 모든 날짜가 수요일이어야 하며, 정확히 7일 간격이어야 함

---

## 🧪 테스트 스위트: Monthly Recurrence

### 테스트 케이스 3.1
- **이름**: `should skip February when starting on 31st and recurring monthly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `monthly`이고 1개의 반복 일정을 생성할 때
- **Then**: `2024-03-31`이 반환되어야 함 (2월은 31일이 없으므로 스킵)

### 테스트 케이스 3.2
- **이름**: `should only generate on 31st when recurring monthly from 31st`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `monthly`이고 2개의 반복 일정을 생성할 때
- **Then**: `['2024-03-31', '2024-05-31']`이 반환되어야 함 (2월, 4월 스킵)

### 테스트 케이스 3.3
- **이름**: `should generate all months when starting from a day that exists in all months`
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-15`
- **When**: 반복 유형이 `monthly`이고 3개의 반복 일정을 생성할 때
- **Then**: `['2024-02-15', '2024-03-15', '2024-04-15']`이 반환되어야 함

### 테스트 케이스 3.4
- **이름**: `should handle 30th correctly when recurring monthly`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-30`
- **When**: 반복 유형이 `monthly`이고 3개의 반복 일정을 생성할 때
- **Then**: 2월(28일까지)을 스킵하고 `['2024-03-30', '2024-04-30', '2024-05-30']`이 반환되어야 함

### 테스트 케이스 3.5
- **이름**: `should handle year boundary when recurring monthly`
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 `2024-11-15`
- **When**: 반복 유형이 `monthly`이고 3개의 반복 일정을 생성할 때
- **Then**: `['2024-12-15', '2025-01-15', '2025-02-15']`이 반환되어야 함

---

## 🧪 테스트 스위트: Yearly Recurrence

### 테스트 케이스 4.1
- **이름**: `should skip non-leap years when starting from Feb 29th and recurring yearly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-02-29` (윤년)
- **When**: 반복 유형이 `yearly`이고 1개의 반복 일정을 생성할 때
- **Then**: `2028-02-29`이 반환되어야 함 (2025, 2026, 2027은 윤년이 아니므로 스킵)

### 테스트 케이스 4.2
- **이름**: `should generate only leap years when starting from Feb 29th and recurring yearly`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-02-29`
- **When**: 반복 유형이 `yearly`이고 2개의 반복 일정을 생성할 때
- **Then**: `['2028-02-29', '2032-02-29']`이 반환되어야 함

### 테스트 케이스 4.3
- **이름**: `should generate every year when starting from a regular date and recurring yearly`
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `yearly`이고 3개의 반복 일정을 생성할 때
- **Then**: `['2025-01-31', '2026-01-31', '2027-01-31']`이 반환되어야 함

### 테스트 케이스 4.4
- **이름**: `should handle century leap year rule correctly when recurring yearly`
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 `2096-02-29` (윤년)
- **When**: 반복 유형이 `yearly`이고 2개의 반복 일정을 생성할 때
- **Then**: `2100-02-29`를 스킵하고 (400의 배수가 아니므로 평년) `['2104-02-29', '2108-02-29']`이 반환되어야 함

---

## 🧪 테스트 스위트: Edge Cases & Validation

### 테스트 케이스 5.1
- **이름**: `should return empty array when count is 0`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `daily`이고 0개의 반복 일정을 생성할 때
- **Then**: 빈 배열 `[]`이 반환되어야 함

### 테스트 케이스 5.2
- **이름**: `should handle negative count gracefully`
- **타입**: edge
- **우선순위**: low
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `daily`이고 -1개의 반복 일정을 생성할 때
- **Then**: 빈 배열 `[]`이 반환되거나 에러를 던져야 함

### 테스트 케이스 5.3
- **이름**: `should handle invalid date format`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `invalid-date`
- **When**: 반복 유형이 `daily`이고 1개의 반복 일정을 생성할 때
- **Then**: 에러를 던지거나 빈 배열을 반환해야 함

### 테스트 케이스 5.4
- **이름**: `should handle invalid recurrence type`
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `invalid-type`일 때
- **Then**: 에러를 던지거나 빈 배열을 반환해야 함

### 테스트 케이스 5.5
- **이름**: `should allow duplicate dates (no overlap check)`
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 `2024-01-31`
- **When**: 반복 유형이 `daily`로 일정을 생성하고, 이미 같은 날짜에 다른 일정이 존재할 때
- **Then**: 겹침 여부와 관계없이 새로운 일정 날짜를 반환해야 함 (중복 생성 허용)

---

## 🏗️ 함수 시그니처 추론

```typescript
type RecurrenceType = 'daily' | 'weekly' | 'monthly' | 'yearly';

interface RecurrenceOptions {
  startDate: string; // YYYY-MM-DD format
  recurrenceType: RecurrenceType;
  count: number; // 생성할 반복 일정 개수
}

function scheduleRecurringRule(options: RecurrenceOptions): string[];
```

---

## �� Mocking/Stubbing 필요성

- **필요 없음**: 순수 함수로 가정
- 날짜 계산 로직만 검증
- 외부 의존성 없음 (API, localStorage, DB 등)

---

## ✅ 테스트 작성 순서 (TDD Red-Green-Refactor)

1. **RED**: 테스트 케이스 1.1 작성 → 실패 확인
2. **GREEN**: 매일 반복 최소 구현 → 테스트 통과
3. **RED**: 테스트 케이스 1.2 작성 → 실패 확인
4. **GREEN**: 다중 일정 생성 구현 → 테스트 통과
5. **REFACTOR**: 중복 제거, 코드 정리
6. **반복**: 매주 → 매월 → 매년 순서로 진행

---

## 📊 우선순위별 테스트 분류

### High Priority (11개)
- 각 반복 유형의 기본 동작 검증
- 31일, 윤년 예외 처리
- 중복 생성 허용 검증

### Medium Priority (6개)
- 월/년 경계 처리
- 모든 달에 존재하는 날짜 검증
- 유효성 검사

### Low Priority (3개)
- 400년 주기 윤년 규칙
- 음수 카운트 처리
- 년도 경계 처리

---

## 🎯 품질 체크리스트

- [x] 각 테스트는 단일 동작만 검증
- [x] AAA 패턴 준수
- [x] 테스트 이름이 의도를 명확히 표현
- [x] 외부 의존성 없음
- [x] 명세의 모든 시나리오 커버
- [x] 경계값 및 예외 케이스 포함
- [x] 테스트 독립성 보장
