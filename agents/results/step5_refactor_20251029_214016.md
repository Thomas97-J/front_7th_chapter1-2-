## 1단계: 개선 포인트

```markdown
- 중복된 null/undefined 체크 로직을 단일 헬퍼 함수로 통합
- 중복된 날짜 검증 로직 (parseDate + isValidDate) 통합
- 매직 넘버 (365.25, 24, 60, 1000, 100) 상수로 추출
- 에러 메시지를 상수 객체로 관리
- 날짜 파싱 및 검증을 하나의 함수로 리팩토링
- 100년 계산 로직을 별도 함수로 분리
- JSDoc 주석 추가로 가독성 향상
```

## 2단계: 개선된 전체 코드

```typescript
// filepath: src/utils/validateDateRange.ts

/**
 * 날짜 범위 검증 결과
 */
export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

/**
 * 날짜 입력 타입
 */
type DateInput = Date | string | null | undefined;

/**
 * 에러 메시지 상수
 */
const ERROR_MESSAGES = {
  BOTH_REQUIRED: '시작일과 종료일은 필수입니다',
  START_REQUIRED: '시작일은 필수입니다',
  END_REQUIRED: '종료일은 필수입니다',
  INVALID_START_FORMAT: '시작일 형식이 올바르지 않습니다',
  INVALID_END_FORMAT: '종료일 형식이 올바르지 않습니다',
  START_AFTER_END: '시작일은 종료일보다 이전이어야 합니다',
} as const;

/**
 * 경고 메시지 상수
 */
const WARNING_MESSAGES = {
  EXCEEDS_CENTURY: '날짜 범위가 100년을 초과합니다',
} as const;

/**
 * 시간 계산 상수
 */
const TIME_CONSTANTS = {
  HOURS_PER_DAY: 24,
  MINUTES_PER_HOUR: 60,
  SECONDS_PER_MINUTE: 60,
  MILLISECONDS_PER_SECOND: 1000,
  DAYS_PER_YEAR: 365.25,
  WARNING_THRESHOLD_YEARS: 100,
} as const;

/**
 * 두 날짜 사이의 기간이 유효한지 검증합니다.
 * 
 * @param startDate - 시작일 (Date 객체 또는 ISO 8601 문자열)
 * @param endDate - 종료일 (Date 객체 또는 ISO 8601 문자열)
 * @returns 검증 결과 객체
 * 
 * @example
 * ```typescript
 * validateDateRange('2024-01-01', '2024-12-31');
 * // => { isValid: true }
 * 
 * validateDateRange('2024-12-31', '2024-01-01');
 * // => { isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }
 * ```
 */
export function validateDateRange(
  startDate: DateInput,
  endDate: DateInput
): ValidationResult {
  // 1. 필수 입력값 검증
  const requiredCheckResult = validateRequiredInputs(startDate, endDate);
  if (requiredCheckResult) {
    return requiredCheckResult;
  }

  // 2. 날짜 파싱 및 형식 검증
  const parsedStartDate = parseAndValidateDate(startDate, 'start');
  if ('error' in parsedStartDate) {
    return parsedStartDate;
  }

  const parsedEndDate = parseAndValidateDate(endDate, 'end');
  if ('error' in parsedEndDate) {
    return parsedEndDate;
  }

  // 3. 날짜 순서 검증
  const orderCheckResult = validateDateOrder(parsedStartDate.date, parsedEndDate.date);
  if (orderCheckResult) {
    return orderCheckResult;
  }

  // 4. 날짜 범위 경고 검증
  const rangeWarning = checkDateRangeWarning(parsedStartDate.date, parsedEndDate.date);
  if (rangeWarning) {
    return {
      isValid: true,
      warning: rangeWarning,
    };
  }

  return { isValid: true };
}

/**
 * 필수 입력값 검증
 */
function validateRequiredInputs(
  startDate: DateInput,
  endDate: DateInput
): ValidationResult | null {
  if (!startDate && !endDate) {
    return {
      isValid: false,
      error: ERROR_MESSAGES.BOTH_REQUIRED,
    };
  }

  if (!startDate) {
    return {
      isValid: false,
      error: ERROR_MESSAGES.START_REQUIRED,
    };
  }

  if (!endDate) {
    return {
      isValid: false,
      error: ERROR_MESSAGES.END_REQUIRED,
    };
  }

  return null;
}

/**
 * 날짜 파싱 및 검증 결과
 */
type ParseResult = { date: Date } | ValidationResult;

/**
 * 날짜를 파싱하고 유효성을 검증합니다.
 * 
 * @param dateInput - 파싱할 날짜
 * @param type - 날짜 타입 ('start' 또는 'end')
 * @returns 파싱된 Date 객체 또는 에러 결과
 */
function parseAndValidateDate(
  dateInput: DateInput,
  type: 'start' | 'end'
): ParseResult {
  const errorMessage = type === 'start'
    ? ERROR_MESSAGES.INVALID_START_FORMAT
    : ERROR_MESSAGES.INVALID_END_FORMAT;

  const parsedDate = parseDate(dateInput);

  if (!parsedDate || !isValidDate(parsedDate)) {
    return {
      isValid: false,
      error: errorMessage,
    };
  }

  return { date: parsedDate };
}

/**
 * Date 객체 또는 문자열을 Date 객체로 파싱합니다.
 */
function parseDate(date: DateInput): Date | null {
  if (date instanceof Date) {
    return date;
  }

  if (typeof date === 'string') {
    return new Date(date);
  }

  return null;
}

/**
 * Date 객체가 유효한지 확인합니다.
 */
function isValidDate(date: Date): boolean {
  return date instanceof Date && !isNaN(date.getTime());
}

/**
 * 시작일이 종료일보다 이전인지 검증합니다.
 */
function validateDateOrder(
  startDate: Date,
  endDate: Date
): ValidationResult | null {
  if (startDate > endDate) {
    return {
      isValid: false,
      error: ERROR_MESSAGES.START_AFTER_END,
    };
  }

  return null;
}

/**
 * 날짜 범위가 경고 임계값을 초과하는지 확인합니다.
 * 
 * @returns 경고 메시지 또는 null
 */
function checkDateRangeWarning(
  startDate: Date,
  endDate: Date
): string | null {
  const differenceInYears = calculateYearsDifference(startDate, endDate);

  if (differenceInYears > TIME_CONSTANTS.WARNING_THRESHOLD_YEARS) {
    return WARNING_MESSAGES.EXCEEDS_CENTURY;
  }

  return null;
}

/**
 * 두 날짜 사이의 연도 차이를 계산합니다.
 */
function calculateYearsDifference(startDate: Date, endDate: Date): number {
  const millisecondsPerYear = 
    TIME_CONSTANTS.DAYS_PER_YEAR *
    TIME_CONSTANTS.HOURS_PER_DAY *
    TIME_CONSTANTS.MINUTES_PER_HOUR *
    TIME_CONSTANTS.SECONDS_PER_MINUTE *
    TIME_CONSTANTS.MILLISECONDS_PER_SECOND;

  const differenceInMilliseconds = endDate.getTime() - startDate.getTime();

  return differenceInMilliseconds / millisecondsPerYear;
}
```
