```typescript
// filepath: src/__tests__/unit/validateDateRange.spec.ts

import { describe, it, expect } from 'vitest';
import { validateDateRange } from '../../utils/validateDateRange';

describe('validateDateRange', () => {
  describe('기본 동작', () => {
    it('should return isValid true when startDate is before endDate', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid true when startDate equals endDate', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid false when startDate is after endDate', () => {
      // Arrange
      const startDate = '2024-12-31';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('입력 형식', () => {
    it('should accept Date objects as input', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should accept ISO 8601 string as input', () => {
      // Arrange
      const startDate = '2024-01-01T00:00:00Z';
      const endDate = '2024-12-31T23:59:59Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle mixed input types (Date object and ISO string)', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = '2024-12-31T23:59:59Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('에러 처리', () => {
    it('should return error when startDate is null', () => {
      // Arrange
      const startDate = null;
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate as any, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('startDate');
    });

    it('should return error when endDate is undefined', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = undefined;
      
      // Act
      const result = validateDateRange(startDate, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('endDate');
    });

    it('should return error when startDate is invalid date format', () => {
      // Arrange
      const startDate = 'invalid-date';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('날짜 형식');
    });

    it('should return error when endDate is invalid date format', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = 'not-a-date';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('날짜 형식');
    });

    it('should return error when both dates are null', () => {
      // Arrange
      const startDate = null;
      const endDate = null;
      
      // Act
      const result = validateDateRange(startDate as any, endDate as any);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('엣지 케이스', () => {
    it('should return isValid true for same date with time', () => {
      // Arrange
      const startDate = '2024-01-01T12:00:00Z';
      const endDate = '2024-01-01T12:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid true for 1 day difference', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2024-01-02';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should return isValid true with warning for 100+ years difference', () => {
      // Arrange
      const startDate = '1900-01-01';
      const endDate = '2024-01-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toContain('100년');
    });

    it('should handle leap year dates correctly', () => {
      // Arrange
      const startDate = '2024-02-29';
      const endDate = '2024-03-01';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle year boundary correctly', () => {
      // Arrange
      const startDate = '2023-12-31T23:59:59Z';
      const endDate = '2024-01-01T00:00:00Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle timezone differences in ISO strings', () => {
      // Arrange
      const startDate = '2024-01-01T23:00:00+09:00';
      const endDate = '2024-01-01T15:00:00+01:00';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toBeDefined();
      expect(result.isValid).toBeDefined();
    });

    it('should handle very distant future dates', () => {
      // Arrange
      const startDate = '2024-01-01';
      const endDate = '2999-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
      expect(result.warning).toBeDefined();
    });

    it('should handle millisecond precision', () => {
      // Arrange
      const startDate = '2024-01-01T12:00:00.000Z';
      const endDate = '2024-01-01T12:00:00.001Z';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('통합 테스트', () => {
    it('should handle sequential validation calls independently', () => {
      // Arrange
      const testCases = [
        { start: '2024-01-01', end: '2024-12-31', expected: true },
        { start: '2024-12-31', end: '2024-01-01', expected: false },
        { start: '2024-06-01', end: '2024-06-01', expected: true },
      ];
      
      // Act & Assert
      testCases.forEach(({ start, end, expected }) => {
        const result = validateDateRange(start, end);
        expect(result.isValid).toBe(expected);
      });
    });

    it('should work correctly with Date constructor', () => {
      // Arrange
      const startDate = new Date(2024, 0, 1);
      const endDate = new Date(2024, 11, 31);
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle empty string input', () => {
      // Arrange
      const startDate = '';
      const endDate = '2024-12-31';
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBeDefined();
    });

    it('should handle numeric timestamp input', () => {
      // Arrange
      const startDate = new Date(1704067200000); // 2024-01-01
      const endDate = new Date(1735603199000); // 2024-12-31
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(true);
    });

    it('should handle invalid Date object', () => {
      // Arrange
      const startDate = new Date('invalid');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result.isValid).toBe(false);
      expect(result.error).toBeDefined();
    });
  });
});
```
