```typescript
// filepath: src/utils/scheduleRecurringRule.ts

import { Event, RepeatType } from '../types';

/**
 * 반복 일정 생성 결과 인터페이스
 */
export interface RecurringEventResult {
  date: string;
  event: Event;
}

/**
 * 반복 일정 생성 옵션
 */
export interface RecurringRuleOptions {
  interval?: number;
  count?: number;
}

/**
 * 주어진 일정에 대해 반복 규칙에 따라 다음 일정 날짜들을 생성합니다.
 * 
 * @param baseEvent - 기준이 되는 일정
 * @param repeatType - 반복 유형 ('daily' | 'weekly' | 'monthly' | 'yearly')
 * @param count - 생성할 반복 일정 개수 (기본값: 10)
 * @returns 생성된 반복 일정 날짜 배열
 */
export function generateRecurringDates(
  baseEvent: Event,
  repeatType: RepeatType,
  count: number = 10
): string[] {
  if (!baseEvent || !baseEvent.date) {
    return [];
  }

  const dates: string[] = [];
  const baseDate = new Date(baseEvent.date);

  if (isNaN(baseDate.getTime())) {
    return [];
  }

  const baseDay = baseDate.getDate();
  const baseMonth = baseDate.getMonth();
  const baseYear = baseDate.getFullYear();
  const baseDayOfWeek = baseDate.getDay();

  let currentDate = new Date(baseDate);
  let attempts = 0;
  const maxAttempts = count * 1000; // 무한루프 방지

  while (dates.length < count && attempts < maxAttempts) {
    attempts++;

    switch (repeatType) {
      case 'daily':
        currentDate.setDate(currentDate.getDate() + 1);
        dates.push(formatDate(currentDate));
        break;

      case 'weekly':
        currentDate.setDate(currentDate.getDate() + 7);
        dates.push(formatDate(currentDate));
        break;

      case 'monthly':
        // 매월 같은 일(day)에만 생성
        currentDate.setMonth(currentDate.getMonth() + 1);
        
        // 해당 월에 기준일이 존재하는지 확인
        if (currentDate.getDate() === baseDay) {
          dates.push(formatDate(currentDate));
        } else {
          // 날짜가 넘어간 경우 (예: 31일이 없는 달)
          // 다음 달로 이미 넘어갔으므로, 날짜를 기준일로 맞춰서 다시 시도
          currentDate.setDate(0); // 이전 달 마지막 날
          const lastDayOfPrevMonth = currentDate.getDate();
          
          if (baseDay > lastDayOfPrevMonth) {
            // 기준일이 해당 월에 존재하지 않음 - 건너뜀
            currentDate.setMonth(currentDate.getMonth() + 1);
            currentDate.setDate(baseDay);
          } else {
            currentDate.setDate(baseDay);
            dates.push(formatDate(currentDate));
          }
        }
        break;

      case 'yearly':
        // 매년 같은 월-일에만 생성
        currentDate.setFullYear(currentDate.getFullYear() + 1);
        
        // 윤년 2월 29일 처리
        if (baseMonth === 1 && baseDay === 29) {
          // 윤년인지 확인
          if (isLeapYear(currentDate.getFullYear())) {
            currentDate.setMonth(baseMonth);
            currentDate.setDate(baseDay);
            dates.push(formatDate(currentDate));
          } else {
            // 윤년이 아니면 건너뜀
            currentDate.setMonth(baseMonth);
            currentDate.setDate(1); // 날짜 리셋
          }
        } else {
          // 일반적인 경우
          if (currentDate.getDate() === baseDay && currentDate.getMonth() === baseMonth) {
            dates.push(formatDate(currentDate));
          } else {
            // 날짜가 맞지 않으면 (월말 처리)
            currentDate.setMonth(baseMonth);
            currentDate.setDate(baseDay);
            
            // 해당 월에 그 날짜가 존재하는지 확인
            if (currentDate.getDate() === baseDay) {
              dates.push(formatDate(currentDate));
            }
          }
        }
        break;

      default:
        return dates;
    }
  }

  return dates;
}

/**
 * 윤년 여부를 확인합니다.
 * 
 * @param year - 확인할 연도
 * @returns 윤년이면 true, 아니면 false
 */
function isLeapYear(year: number): boolean {
  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

/**
 * Date 객체를 YYYY-MM-DD 형식 문자열로 변환합니다.
 * 
 * @param date - 변환할 Date 객체
 * @returns YYYY-MM-DD 형식의 날짜 문자열
 */
function formatDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * 반복 일정을 생성하고 Event 객체 배열로 반환합니다.
 * 
 * @param baseEvent - 기준 일정
 * @param count - 생성할 반복 일정 개수
 * @returns 생성된 반복 일정 배열
 */
export function createRecurringEvents(
  baseEvent: Event,
  count: number = 10
): Event[] {
  if (!baseEvent || !baseEvent.repeat.type || baseEvent.repeat.type === 'none') {
    return [];
  }

  const dates = generateRecurringDates(baseEvent, baseEvent.repeat.type, count);
  
  return dates.map((date, index) => ({
    ...baseEvent,
    id: `${baseEvent.id}_recurring_${index + 1}`,
    date,
    repeat: {
      ...baseEvent.repeat
    }
  }));
}
```
