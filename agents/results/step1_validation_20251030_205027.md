Now I have a complete understanding of the project. Let me provide a comprehensive validation report:

---

# ✅ 검증 결과

## 1. 프로젝트 통합성
**평가:** 🔴 **개선 필요**

**발견 사항:**

**🔥 중대한 문제: 이미 구현된 기능입니다!**

프로젝트에 **이미 동일한 기능의 구현체가 3개** 존재합니다:

1. **`src/utils/scheduleRecurringRule.ts`** (Line 1-167)
   - 함수: `generateRecurringDates(options: RecurringOptions)`
   - 타입: `RepeatType = 'daily' | 'weekly' | 'monthly' | 'yearly'`
   - 완전히 구현되어 동작하는 코드

2. **`src/utils/scheduleRecurringRule.spec.ts.ts`** (Line 1-194)
   - 함수: `generateRecurringSchedule(startDate, repeatType, count)`
   - 타입: `RepeatType = 'daily' | 'weekly' | 'monthly' | 'yearly'`
   - 입력 검증 포함한 완전한 구현

3. **`src/utils/scheduleRecurringRule.ts.ts`** (Line 1-219)
   - 함수: `generateRecurringSchedule(startDate, recurrenceType, count)`
   - 타입: `RecurrenceType = '매일' | '매주' | '매월' | '매년'`
   - 한글 기반 완전한 구현

**기존 테스트 파일:**
- **`src/__tests__/unit/scheduleRecurringRule.spec.ts`** (330줄)
  - 명세서의 모든 시나리오를 이미 테스트하고 있음
  - 매일/매주/매월/매년 반복 테스트 완료
  - 입력 검증 테스트 완료
  - 엣지 케이스(윤년, 31일) 테스트 완료

**기존 타입 시스템:**
- **src/types.ts**에 `RepeatType = 'none' | 'daily' | 'weekly' | 'monthly' | 'yearly'` 정의됨
- `RepeatInfo` 인터페이스에 `type`, `interval`, `endDate` 필드 존재
- **명세서의 타입과 불일치** ('매일' vs 'daily')

**개선 사항:**

1. **중복 제거 필요:**
   - 3개의 구현체 중 **하나만 선택**하여 표준으로 사용
   - 나머지는 삭제하거나 마이그레이션
   - 권장: `scheduleRecurringRule.ts` (영문 타입, 프로젝트 컨벤션 일치)

2. **타입 일관성 확보:**
   - 명세서: `'매일' | '매주' | '매월' | '매년'` (한글)
   - 프로젝트: `'daily' | 'weekly' | 'monthly' | 'yearly'` (영문)
   - **권장: 영문 타입 사용** (src/types.ts 기준)

3. **파일 위치 정리:**
   - ✅ 올바른 위치: `src/utils/scheduleRecurringRule.ts`
   - ❌ 잘못된 파일명:
     - `scheduleRecurringRule.ts.ts` (`.ts.ts` 중복 확장자)
     - `scheduleRecurringRule.spec.ts.ts` (`.spec.ts.ts` 잘못된 확장자)

4. **테스트 파일 위치:**
   - ✅ 올바른 위치: `src/__tests__/unit/scheduleRecurringRule.spec.ts`
   - 이미 존재하며 완전한 테스트 커버리지

---

## 2. 명확성
**평가:** ⚠️ **개선 필요**

**발견 사항:**

1. **타입 불일치:**
   - 명세서: 한글 타입 (`'매일'`, `'매주'`, `'매월'`, `'매년'`)
   - 프로젝트 표준: 영문 타입 (`'daily'`, `'weekly'`, `'monthly'`, `'yearly'`)
   - 혼란을 야기할 수 있음

2. **함수 시그니처 모호함:**
   - 명세서는 "함수 시그니처를 명시하지 말라"고 했지만, 실제 구현체가 이미 존재하므로 기존 함수와의 관계가 불명확

3. **"일정 겹침 무시" 요구사항:**
   - 명세서: "일정 겹침은 고려하지 않음"
   - 실제로 이 기능은 **날짜 생성 유틸리티**이므로, 원래 겹침을 확인하지 않음
   - 이는 요구사항이 아니라 **자연스러운 동작**임

**개선 사항:**

1. **타입 표준화:**
   - 영문 타입으로 통일
   - src/types.ts의 `RepeatType`과 일치시키기

2. **명세서 목적 명확화:**
   - 새로운 기능인지, 기존 기능 개선인지 명시
   - 기존 구현체와의 차이점 명확화

3. **불필요한 요구사항 제거:**
   - "일정 겹침 무시"는 이 유틸리티의 책임이 아님
   - 별도의 overlap checking은 `eventOverlap.ts`에 이미 존재

---

## 3. 완전성
**평가:** 🟢 **통과**

**발견 사항:**

✅ **명세서가 다루는 시나리오:**
- 매일 반복: 날짜 경계 처리 ✅
- 매주 반복: 요일 유지 ✅
- 매월 반복: 31일 없는 달 건너뛰기 ✅
- 매년 반복: 윤년 2월 29일 처리 ✅

✅ **에러 처리:**
- 잘못된 날짜 형식
- 유효하지 않은 반복 타입
- 음수 또는 0 count

✅ **엣지 케이스:**
- 윤년 처리
- 월/연도 경계 넘기
- 100년 단위 윤년 규칙

**기존 구현체와 비교:**
- 명세서의 모든 시나리오가 **이미 구현되어 있음**
- 테스트도 모두 작성되어 있음

**추가할 내용:**
- ✅ 완전함 - 추가 사항 없음

---

## 4. 테스트 가능성
**평가:** 🟢 **통과**

**발견 사항:**

✅ **기존 테스트 패턴 일치:**
```typescript
// 프로젝트 표준 테스트 패턴 (Arrange-Act-Assert)
describe('매일 반복', () => {
  it('should generate next day schedule from 2024-01-31', () => {
    // Arrange
    const startDate = '2024-01-31';
    const repeatType = 'daily';
    const count = 1;

    // Act
    const result = generateRecurringSchedule(startDate, repeatType, count);

    // Assert
    expect(result).toEqual(['2024-02-01']);
  });
});
```

✅ **테스트 커버리지:**
- 정상 케이스: 모든 반복 유형
- 예외 케이스: 입력 검증
- 엣지 케이스: 경계값, 윤년

**테스트 전략:**
- **이미 완전한 테스트 스위트 존재**: `src/__tests__/unit/scheduleRecurringRule.spec.ts`
- 330줄의 포괄적인 테스트
- Vitest 프레임워크 사용

---

## 5. 일관성
**평가:** 🔴 **실패**

**충돌 사항:**

1. **타입 시스템 충돌:**
   - 명세서: `'매일' | '매주' | '매월' | '매년'` (한글)
   - src/types.ts: `'daily' | 'weekly' | 'monthly' | 'yearly'` (영문)
   - 프로젝트는 **영문 컨벤션** 사용 (파일명, 변수명 모두 영문)

2. **함수명 충돌:**
   - 명세서 없음 (개념적 명세만)
   - 기존 구현체 #1: `generateRecurringDates()`
   - 기존 구현체 #2 & #3: `generateRecurringSchedule()`

3. **인터페이스 충돌:**
   - 기존 구현체 #1: `RecurringOptions` / `RecurringResult`
   - 기존 구현체 #2: 파라미터만 사용
   - 기존 구현체 #3: `RecurringScheduleResult` (객체 배열 반환)

4. **네이밍 컨벤션:**
   - 프로젝트는 **camelCase 함수명** 사용
   - 프로젝트는 **영문 변수/타입명** 사용
   - 명세서의 한글 타입은 **일관성 위배**

---

## 6. 성능 고려사항
**평가:** 🟢 **통과**

**성능 분석:**

✅ **시간 복잡도:**
- 매일/매주: O(n) - n은 count
- 매월/매년: O(n × m) - m은 스킵하는 월/년 수 (평균 O(n))
- 최악의 경우 (2월 31일 → 영원히 생성 불가): **무한 루프 위험** 있음

⚠️ **기존 구현체의 무한 루프 방지:**
- 구현체 #1 (`scheduleRecurringRule.ts`): 최대 반복 없음 ⚠️
- 구현체 #2 (`scheduleRecurringRule.spec.ts.ts`): 입력 검증으로 예방 ✅
- 구현체 #3 (`scheduleRecurringRule.ts.ts`): `maxIterations` 제한 있음 ✅

**최적화 필요 여부:**
- ✅ count가 크지 않은 경우 (< 100) 성능 문제 없음
- ⚠️ 대량 생성 시 (count > 1000) 고려 필요

---

# 📝 개선된 명세 (요구사항 수준)

## 🚨 선행 결정 필요

**이 명세를 진행하기 전에 다음을 결정해야 합니다:**

### 옵션 A: 기존 구현체 정리 및 개선
- 3개의 중복 구현체 중 하나만 선택
- 나머지 파일 삭제 (`.ts.ts` 잘못된 확장자 파일들)
- 기존 테스트 유지 및 보강
- **권장 사항**

### 옵션 B: 새로운 구현 (기존 대체)
- 기존 구현을 모두 삭제하고 새로 작성
- 타입 시스템 재설계
- 전체 테스트 재작성
- **비권장** (중복 작업)

### 옵션 C: 병합 및 통합
- 3개 구현체의 장점 결합
- 통합 인터페이스 설계
- 하위 호환성 고려
- **복잡도 높음**

---

## ⚠️ 권장 액션 플랜

### Phase 1: 정리 (Clean Up)
1. **중복 파일 삭제:**
   - `src/utils/scheduleRecurringRule.ts.ts` 삭제
   - `src/utils/scheduleRecurringRule.spec.ts.ts` 삭제

2. **표준 구현체 선정:**
   - **선택: `src/utils/scheduleRecurringRule.spec.ts.ts`**
   - 이유:
     - 완전한 입력 검증
     - 명확한 에러 메시지
     - 테스트와 일치하는 시그니처
   - 파일명 변경: → `src/utils/scheduleRecurringRule.ts`

3. **타입 통합:**
   - src/types.ts의 `RepeatType` 사용
   - 한글 타입 제거

### Phase 2: 개선 (Enhance)
1. **무한 루프 방지:**
   - 매월/매년에서 불가능한 날짜 조기 감지
   - 최대 검색 횟수 제한

2. **문서화 강화:**
   - JSDoc 주석 추가/개선
   - 사용 예시 추가

### Phase 3: 테스트 보강 (Test)
1. **기존 테스트 유지:**
   - `src/__tests__/unit/scheduleRecurringRule.spec.ts` (이미 완전함)

2. **추가 테스트:**
   - 불가능한 날짜 케이스 (2월 30일, 2월 31일)
   - 대량 생성 성능 테스트 (count > 100)

---

## 📄 정리된 명세서

# 반복 일정 날짜 생성 유틸리티

## 개요
주어진 시작 날짜와 반복 유형에 따라 N개의 반복 일정 날짜를 생성하는 유틸리티 함수. 일정 겹침 검사는 수행하지 않으며, 순수하게 날짜 목록만 생성한다.

## 위치
**현재 파일 경로:** `src/utils/scheduleRecurringRule.ts`

**관련 파일:**
- 타입 정의: `src/types.ts` (`RepeatType`)
- 테스트: `src/__tests__/unit/scheduleRecurringRule.spec.ts`

**선정 이유:**
- 기존 `dateUtils.ts`와 같은 utils 디렉토리
- 날짜 계산 로직의 응집도
- 테스트 가능한 순수 함수

## 기능 설명
- **핵심 기능:** 반복 규칙에 따라 미래 날짜 목록 생성
- **주요 동작:**
  1. 시작 날짜를 기준으로 반복 유형 적용
  2. 지정된 개수만큼 유효한 날짜 생성
  3. 해당 날짜가 존재하지 않는 월/년은 자동 건너뛰기
- **제약 조건:**
  - ISO 8601 날짜 형식 (YYYY-MM-DD) 필수
  - 일정 겹침은 확인하지 않음 (순수 날짜 생성만)
  - 매월: 시작일의 "일(day)"에만 생성 (예: 31일 → 31일 있는 달만)
  - 매년: 시작일의 "월/일"에만 생성 (예: 2/29 → 윤년만)

## 입력 (개념적)
- **파라미터 1: 시작 날짜**
  - 타입 힌트: string (ISO 8601 형식)
  - 필수/선택: 필수
  - 예시: `'2024-01-31'`, `'2024-02-29'`
  - 제약: YYYY-MM-DD 형식, 유효한 날짜

- **파라미터 2: 반복 유형**
  - 타입 힌트: RepeatType ('daily' | 'weekly' | 'monthly' | 'yearly')
  - 필수/선택: 필수
  - 예시: `'daily'`, `'monthly'`
  - 제약: src/types.ts의 RepeatType 중 하나 (단, 'none' 제외)

- **파라미터 3: 생성 개수**
  - 타입 힌트: number (양의 정수)
  - 필수/선택: 필수
  - 예시: `3`, `10`
  - 제약: 0 이상의 정수

## 출력 (개념적)
- **반환 타입:** 날짜 문자열 배열 (string[])
  - 성공 시: YYYY-MM-DD 형식의 날짜 문자열 배열
  - 실패 시: Error throw (예외 발생)

**예시:**
```typescript
// 성공 케이스
Input: ('2024-01-31', 'monthly', 2)
Output: ['2024-03-31', '2024-05-31']  // 2월 건너뜀

// 매일 반복
Input: ('2024-01-31', 'daily', 3)
Output: ['2024-02-01', '2024-02-02', '2024-02-03']

// 매년 윤년
Input: ('2024-02-29', 'yearly', 2)
Output: ['2028-02-29', '2032-02-29']  // 2025-2027 건너뜀
```

## 관련 타입 (기존 재사용)
- **RepeatType** (src/types.ts) - 반복 유형 정의
  - 사용할 값: `'daily' | 'weekly' | 'monthly' | 'yearly'`
  - 제외할 값: `'none'` (반복 없음은 이 함수의 책임이 아님)

- **새 타입 필요 여부:** 아니오
  - 반환 타입은 `string[]`로 충분
  - 추가 메타데이터가 필요하다면 Step 2에서 결정

## 상세 요구사항

### 1. 입력 검증 규칙
**파라미터 1 (시작 날짜) 검증:**
1. null/undefined 체크 → Error: "Starting date is required"
2. 형식 검증 (YYYY-MM-DD) → Error: "Invalid date format. Expected YYYY-MM-DD"
3. 유효한 날짜인지 확인 → Error: "Invalid date"

**파라미터 2 (반복 유형) 검증:**
1. null/undefined 체크 → Error: "Repeat type is required"
2. 허용된 값인지 확인 → Error: "Invalid repeat type. Must be one of: daily, weekly, monthly, yearly"

**파라미터 3 (개수) 검증:**
1. null/undefined 체크 → Error: "Count is required"
2. 음수 체크 → Error: "Count must be a non-negative number"
3. 0인 경우 → 빈 배열 반환 (에러 아님)

### 2. 비즈니스 로직

#### 2.1 매일 반복 (daily)
- 시작일 다음 날부터 하루씩 증가
- 월/년 경계 자동 처리
- count만큼 생성 (항상 성공)

**예시:**
- Input: `('2024-01-31', 'daily', 3)`
- Output: `['2024-02-01', '2024-02-02', '2024-02-03']`

#### 2.2 매주 반복 (weekly)
- 시작일과 같은 요일에 생성
- 정확히 7일 간격
- count만큼 생성 (항상 성공)

**예시:**
- Input: `('2024-01-31', 'weekly', 3)`  // 2024-01-31은 수요일
- Output: `['2024-02-07', '2024-02-14', '2024-02-21']`  // 모두 수요일

#### 2.3 매월 반복 (monthly)
- 시작일의 **"일(day)"에만** 생성
- 해당 일이 없는 달은 건너뛰기
- 예: 31일 시작 → 31일 있는 달만 (1, 3, 5, 7, 8, 10, 12월)

**예시:**
- Input: `('2024-01-31', 'monthly', 5)`
- Output: `['2024-03-31', '2024-05-31', '2024-07-31', '2024-08-31', '2024-10-31']`
- 건너뛴 달: 2월 (28/29일), 4월 (30일), 6월 (30일), 9월 (30일)

**특수 케이스:**
- 29일 시작 (윤년): 2월도 포함 (윤년인 경우)
- 30일 시작: 2월 제외, 나머지 포함
- 31일 시작: 7개 월만 포함

#### 2.4 매년 반복 (yearly)
- 시작일의 **"월/일"에만** 생성
- 해당 날짜가 없는 연도는 건너뛰기
- 주요 케이스: 2월 29일 → 윤년만

**예시:**
- Input: `('2024-02-29', 'yearly', 3)`
- Output: `['2028-02-29', '2032-02-29', '2036-02-29']`
- 건너뛴 년도: 2025, 2026, 2027, 2029, 2030, 2031, 2033, 2034, 2035

**윤년 규칙:**
- 4로 나누어떨어짐: 윤년
- 단, 100으로 나누어떨어짐: 평년
- 단, 400으로 나누어떨어짐: 윤년
- 예: 2000(윤년), 1900(평년), 2100(평년), 2400(윤년)

### 3. 에러 처리 시나리오

| 상황 | 에러 메시지 | 심각도 |
|------|------------|--------|
| startDate null/undefined | "Starting date is required" | Error (throw) |
| startDate 형식 오류 | "Invalid date format. Expected YYYY-MM-DD" | Error (throw) |
| startDate 유효하지 않음 | "Invalid date" | Error (throw) |
| repeatType null/undefined | "Repeat type is required" | Error (throw) |
| repeatType 유효하지 않음 | "Invalid repeat type. Must be one of: ..." | Error (throw) |
| count < 0 | "Count must be a non-negative number" | Error (throw) |
| count = 0 | (에러 없음, 빈 배열 반환) | - |

### 4. 엣지 케이스

#### 4.1 날짜 경계
1. **월 경계:**
   - Input: `('2024-01-31', 'daily', 2)`
   - Output: `['2024-02-01', '2024-02-02']`
   - 1월 → 2월 자동 넘김

2. **년 경계:**
   - Input: `('2024-12-30', 'daily', 3)`
   - Output: `['2024-12-31', '2025-01-01', '2025-01-02']`
   - 2024년 → 2025년 자동 넘김

3. **윤년 처리:**
   - Input: `('2024-02-28', 'daily', 2)`
   - Output: `['2024-02-29', '2024-03-01']`
   - 2024년은 윤년 (2월 29일 존재)

#### 4.2 불가능한 날짜
1. **매월 31일 (2월):**
   - Input: `('2024-01-31', 'monthly', 1)`
   - Output: `['2024-03-31']`
   - 2월은 자동 건너뜀

2. **매년 2월 29일 (평년):**
   - Input: `('2024-02-29', 'yearly', 1)`
   - Output: `['2028-02-29']`
   - 2025-2027년 건너뜀

#### 4.3 성능 제한
1. **매우 큰 count:**
   - 불가능한 날짜 (예: 매년 2월 30일)는 영원히 생성 불가
   - → **무한 루프 방지 필요**
   - 해결: 최대 검색 횟수 제한 (예: count × 100년)

## 테스트 시나리오 (개념적)

### 정상 케이스

#### 1. 매일 반복
- **입력:** `('2024-01-31', 'daily', 3)`
- **예상 출력:** `['2024-02-01', '2024-02-02', '2024-02-03']`
- **검증:** 연속된 날짜, 월 경계 처리

#### 2. 매주 반복
- **입력:** `('2024-01-31', 'weekly', 3)`
- **예상 출력:** `['2024-02-07', '2024-02-14', '2024-02-21']`
- **검증:** 7일 간격, 같은 요일 유지

#### 3. 매월 반복 (31일)
- **입력:** `('2024-01-31', 'monthly', 2)`
- **예상 출력:** `['2024-03-31', '2024-05-31']`
- **검증:** 2월 건너뜀, 4월 건너뜀

#### 4. 매년 반복 (윤년)
- **입력:** `('2024-02-29', 'yearly', 2)`
- **예상 출력:** `['2028-02-29', '2032-02-29']`
- **검증:** 평년 건너뜀, 윤년만 포함

### 예외 케이스

#### 1. null 날짜
- **입력:** `(null, 'daily', 1)`
- **예상 출력:** Error throw
- **에러 메시지:** "Starting date is required"

#### 2. 잘못된 형식
- **입력:** `('invalid-date', 'daily', 1)`
- **예상 출력:** Error throw
- **에러 메시지:** "Invalid date format..."

#### 3. 유효하지 않은 반복 유형
- **입력:** `('2024-01-31', 'hourly', 1)`
- **예상 출력:** Error throw
- **에러 메시지:** "Invalid repeat type..."

#### 4. 음수 count
- **입력:** `('2024-01-31', 'daily', -1)`
- **예상 출력:** Error throw
- **에러 메시지:** "Count must be a non-negative number"

### 엣지 케이스

#### 1. count = 0
- **입력:** `('2024-01-31', 'daily', 0)`
- **예상 출력:** `[]` (빈 배열, 에러 아님)

#### 2. 윤년 경계 (100년 규칙)
- **입력:** `('2096-02-29', 'yearly', 2)`
- **예상 출력:** `['2104-02-29', '2108-02-29']`
- **검증:** 2100년은 평년 (100으로 나누어떨어지지만 400으로는 안됨)

#### 3. 매월 30일
- **입력:** `('2024-01-30', 'monthly', 3)`
- **예상 출력:** `['2024-03-30', '2024-04-30', '2024-05-30']`
- **검증:** 2월만 건너뜀

## 통합 가이드

### 기존 코드와의 관계

**재사용할 유틸리티:**
- ❌ `formatDate()` - dateUtils.ts에 있지만 시그니처 다름
  - 기존: `formatDate(currentDate: Date, day?: number)`
  - 필요: 내부적으로 자체 구현 또는 Date 객체 사용

**연관되지 않는 컴포넌트:**
- `eventOverlap.ts` - 일정 겹침 확인 (이 함수의 책임 아님)
- `isOverlapping()` - 별도로 호출되어야 함

**영향받는 타입:**
- `RepeatInfo` (src/types.ts) - interval, endDate 필드는 이 함수에서 사용 안 함
- 이 함수는 순수하게 **startDate + repeatType + count만** 사용

### 예상 사용처 (개념적)

```typescript
// App.tsx 또는 이벤트 생성 로직에서
import { generateRecurringSchedule } from './utils/scheduleRecurringRule';

// 사용자가 반복 일정 생성 요청
const handleCreateRecurring = (eventForm: EventForm) => {
  const { date, repeat } = eventForm;
  
  // 반복 일정 날짜 생성
  try {
    const futureDates = generateRecurringSchedule(
      date,              // '2024-01-31'
      repeat.type,       // 'monthly'
      10                 // 10개 생성
    );
    
    // 생성된 날짜로 이벤트 생성
    futureDates.forEach(futureDate => {
      createEvent({
        ...eventForm,
        date: futureDate,
        id: generateId()
      });
    });
    
  } catch (error) {
    showError(error.message);
  }
};
```

### 일정 겹침 확인 (별도 처리)

```typescript
// 겹침 확인은 별도로 수행
import { findOverlappingEvents } from './utils/eventOverlap';

const futureDates = generateRecurringSchedule(...);

futureDates.forEach(date => {
  const newEvent = { ...eventForm, date };
  
  // 겹침 확인 (선택적)
  const overlaps = findOverlappingEvents(newEvent, existingEvents);
  
  if (overlaps.length > 0) {
    // 사용자에게 경고 또는 확인 요청
    showWarning(`${date}에 ${overlaps.length}개의 일정과 겹칩니다.`);
  }
  
  createEvent(newEvent);
});
```

## 성능 고려사항

- **시간 복잡도:**
  - 매일/매주: O(n) - n은 count
  - 매월: O(n × 12) - 최악의 경우 1년 탐색 (31일 시작)
  - 매년: O(n × 4) - 최악의 경우 윤년 주기 (2/29 시작)

- **공간 복잡도:** O(n) - 생성된 날짜 배열

- **최적화 필요:**
  - ⚠️ 매월/매년에서 불가능한 날짜 조기 감지
  - ⚠️ 무한 루프 방지 (최대 검색 횟수 제한)

- **대용량 데이터:**
  - count < 100: 성능 문제 없음
  - count > 1000: 성능 테스트 권장

## 마이그레이션 가이드

### 현재 상황
프로젝트에 이미 3개의 구현체가 존재합니다:
1. `scheduleRecurringRule.ts` (기본 구현)
2. `scheduleRecurringRule.spec.ts.ts` (테스트용 구현, 잘못된 파일명)
3. `scheduleRecurringRule.ts.ts` (한글 타입 구현, 잘못된 파일명)

### 영향받는 파일
- `src/utils/scheduleRecurringRule.*.ts` - 모든 구현체
- `src/__tests__/unit/scheduleRecurringRule.spec.ts` - 테스트 파일

### 마이그레이션 단계

**Step 1: 중복 제거**
```bash
# 잘못된 확장자 파일 삭제
rm src/utils/scheduleRecurringRule.ts.ts
rm src/utils/scheduleRecurringRule.spec.ts.ts
```

**Step 2: 표준 구현 선택**
- 선택: `scheduleRecurringRule.spec.ts.ts`의 구현
- 이유: 완전한 입력 검증 + 명확한 에러 메시지
- 복사 후 타입 수정 (한글 → 영문)

**Step 3: 타입 통합**
```typescript
// Before (한글 타입)
export type RecurrenceType = '매일' | '매주' | '매월' | '매년';

// After (프로젝트 표준)
import { RepeatType } from '../types';
// 'daily' | 'weekly' | 'monthly' | 'yearly' 사용
```

### 호환성
- **하위 호환:** N/A (신규 기능)
- **점진적 마이그레이션:** 필요 없음 (아직 사용처 없음)
- **테스트 영향:** 기존 테스트 유지 (타입만 수정)

---

## 🎯 최종 권장사항

### 이 명세는 **필요하지 않습니다.**

**이유:**
1. ✅ 이미 완전히 구현된 기능
2. ✅ 이미 포괄적인 테스트 존재
3. ❌ 중복 구현체만 존재 (3개)
4. ⚠️ 타입 불일치 문제 (한글 vs 영문)

### 대신 수행해야 할 작업:

**Task 1: 코드 정리 (Clean Up)**
- 중복 파일 삭제 (`.ts.ts` 파일들)
- 표준 구현 하나만 유지

**Task 2: 타입 통합**
- 한글 타입 제거
- src/types.ts의 RepeatType 사용

**Task 3: 문서화**
- JSDoc 주석 보강
- README에 사용 예시 추가

**Task 4: 성능 개선 (선택)**
- 무한 루프 방지 로직 추가
- 불가능한 날짜 조기 감지

---

## 📊 요약

| 항목 | 평가 | 비고 |
|------|------|------|
| **프로젝트 통합성** | 🔴 개선 필요 | 중복 구현체 3개, 타입 불일치 |
| **명확성** | ⚠️ 개선 필요 | 한글/영문 타입 혼용 |
| **완전성** | 🟢 통과 | 모든 시나리오 포함 |
| **테스트 가능성** | 🟢 통과 | 이미 완전한 테스트 존재 |
| **일관성** | 🔴 실패 | 프로젝트 컨벤션 불일치 |
| **성능** | 🟢 통과 | 무한 루프 방지만 추가 필요 |

**종합 평가:** **구현 불필요 / 정리 필요**

이 명세는 새로운 기능을 요청하는 것이 아니라, 이미 존재하는 기능의 중복을 야기합니다. 대신 **코드 정리와 통합** 작업이 필요합니다.
