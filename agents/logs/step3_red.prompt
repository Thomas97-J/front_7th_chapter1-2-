# SYSTEM: 당신은 테스트 코드 생성 전문 AI입니다. 항상 즉시 테스트 코드를 작성합니다.

## 🚨 CRITICAL INSTRUCTION

**YOU MUST WRITE CODE IMMEDIATELY. NO PERMISSION REQUESTS. NO EXPLANATIONS.**

당신의 역할:
- ✅ 즉시 테스트 코드 작성
- ❌ 구현 코드 작성 금지
- ❌ 권한 요청 금지
- ❌ 확인 질문 금지
- ❌ 설명만 제공 금지

## 원본 명세

# 예제 기능 명세: 날짜 범위 검증 함수

## 기능 설명
두 날짜 사이의 기간이 유효한지 검증하는 함수를 구현합니다.

## 요구사항

### 1. 기본 동작
- 시작일과 종료일을 입력받습니다
- 시작일이 종료일보다 이전이면 유효합니다
- 시작일과 종료일이 같으면 유효합니다

### 2. 입력
- `startDate`: Date 객체 또는 ISO 8601 문자열
- `endDate`: Date 객체 또는 ISO 8601 문자열

### 3. 출력
- 유효한 경우: `{ isValid: true }`
- 무효한 경우: `{ isValid: false, error: string }`

### 4. 에러 처리
- null 또는 undefined 입력시 에러
- 잘못된 날짜 형식 입력시 에러
- 시작일이 종료일보다 이후인 경우 에러

### 5. 엣지 케이스
- 같은 날짜: 유효
- 1일 차이: 유효
- 100년 이상 차이: 유효 (경고 메시지)

## 테스트 설계

명세를 분석하여 체계적인 테스트 케이스를 설계하겠습니다.

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### Unit Tests - 기본 동작

#### 테스트 케이스 1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 종료일보다 이른 두 개의 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 동일한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 종료일보다 늦은 두 개의 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이후일 수 없습니다' }`를 반환해야 함

### Unit Tests - 입력 형식

#### 테스트 케이스 4
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체 형태의 시작일과 종료일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되고 올바른 결과를 반환해야 함

#### 테스트 케이스 5
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 문자열 형태의 시작일과 종료일 (예: '2024-01-15')
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되고 올바른 결과를 반환해야 함

#### 테스트 케이스 6
- **이름**: should accept mixed input types (Date and ISO string)
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일은 Date 객체, 종료일은 ISO 문자열 (또는 반대)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되고 올바른 결과를 반환해야 함

### Unit Tests - 에러 처리

#### 테스트 케이스 7
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null이고 종료일은 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 8
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일은 유효하고 종료일이 null
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 9
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined이고 종료일은 유효한 날짜
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 10
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일은 유효하고 종료일이 undefined
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일은 필수입니다' }`를 반환해야 함

#### 테스트 케이스 11
- **이름**: should return error when start date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 잘못된 날짜 문자열 (예: 'invalid-date', '2024-13-45')
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '시작일 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 12
- **이름**: should return error when end date has invalid format
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일은 유효하고 종료일이 잘못된 형식
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '종료일 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 13
- **이름**: should return error when date string is empty
- **타입**: unit
- **우선순위**: medium
- **Given**: 빈 문자열('')을 날짜로 전달
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '[시작일/종료일] 형식이 올바르지 않습니다' }`를 반환해야 함

### Edge Cases - 경계값

#### 테스트 케이스 14
- **이름**: should return valid when dates differ by exactly 1 day
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일과 종료일이 정확히 1일 차이
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 15
- **이름**: should return valid with warning when dates differ by more than 100 years
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일과 종료일이 100년 이상 차이 (예: 1900-01-01 ~ 2024-01-01)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환해야 함

#### 테스트 케이스 16
- **이름**: should return valid when dates differ by exactly 100 years
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일과 종료일이 정확히 100년 차이
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함 (경고 없음)

#### 테스트 케이스 17
- **이름**: should handle dates at year boundary (December 31 to January 1)
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 12월 31일, 종료일 다음 해 1월 1일
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 18
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: medium
- **Given**: 윤년의 2월 29일을 포함하는 날짜 범위
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 처리되고 `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 19
- **이름**: should handle very old dates (historical dates)
- **타입**: edge
- **우선순위**: low
- **Given**: 매우 오래된 날짜 (예: 1900년 이전)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되어야 함

#### 테스트 케이스 20
- **이름**: should handle far future dates
- **타입**: edge
- **우선순위**: low
- **Given**: 먼 미래의 날짜 (예: 2100년 이후)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 검증되어야 함

### Edge Cases - 시간대 및 정밀도

#### 테스트 케이스 21
- **이름**: should compare dates by day only, ignoring time
- **타입**: edge
- **우선순위**: high
- **Given**: 같은 날짜이지만 다른 시간 (예: 2024-01-01 09:00 vs 2024-01-01 23:59)
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 같은 날짜로 간주하고 `{ isValid: true }`를 반환해야 함

#### 테스트 케이스 22
- **이름**: should handle ISO strings with timezone information
- **타입**: edge
- **우선순위**: medium
- **Given**: 시간대 정보가 포함된 ISO 8601 문자열 (예: '2024-01-01T00:00:00Z')
- **When**: validateDateRange 함수를 호출할 때
- **Then**: 정상적으로 파싱되고 검증되어야 함

### Edge Cases - 특수 입력

#### 테스트 케이스 23
- **이름**: should return error when passed Invalid Date object
- **타입**: edge
- **우선순위**: high
- **Given**: new Date('invalid')로 생성된 Invalid Date 객체
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '[시작일/종료일] 형식이 올바르지 않습니다' }`를 반환해야 함

#### 테스트 케이스 24
- **이름**: should return error when passed non-date types (number, object, array)
- **타입**: edge
- **우선순위**: medium
- **Given**: 숫자, 일반 객체, 배열 등 날짜가 아닌 타입
- **When**: validateDateRange 함수를 호출할 때
- **Then**: `{ isValid: false, error: '[시작일/종료일] 형식이 올바르지 않습니다' }`를 반환해야 함

---

## 테스트 구현 우선순위

### Phase 1 - Critical Path (우선순위: high)
- 테스트 케이스 1, 2, 3: 핵심 비즈니스 로직
- 테스트 케이스 4, 5: 주요 입력 형식
- 테스트 케이스 7, 8, 9, 10, 11, 12: 필수 에러 처리
- 테스트 케이스 15: 중요한 경계 조건
- 테스트 케이스 21, 23: 중요한 엣지 케이스

### Phase 2 - Extended Coverage (우선순위: medium)
- 테스트 케이스 6, 13: 추가 입력 검증
- 테스트 케이스 14, 16, 17, 18, 22, 24: 경계값 및 특수 케이스

### Phase 3 - Comprehensive (우선순위: low)
- 테스트 케이스 19, 20: 극단적 케이스

---

## 테스트 구현 가이드

각 테스트는 다음 구조를 따릅니다:

```typescript
describe('validateDateRange', () => {
  describe('기본 동작', () => {
    it('should return valid when start date is before end date', () => {
      // Arrange
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-12-31');
      
      // Act
      const result = validateDateRange(startDate, endDate);
      
      // Assert
      expect(result).toEqual({ isValid: true });
    });
  });
});
```

이 설계를 바탕으로 TDD RED 단계의 실패하는 테스트를 작성하시겠습니까?

---

## TASK: Write Vitest Test Code

### Requirements:
- Vitest framework
- TypeScript
- AAA pattern
- 15+ test cases
- All edge cases
- Ready to run

### Output Format:

**START YOUR RESPONSE WITH CODE BLOCK. NO TEXT BEFORE CODE.**

```typescript
// filepath: src/__tests__/unit/[name].spec.ts

import { describe, it, expect } from 'vitest';
import { functionName } from '../../utils/fileName';

describe('Feature Name', () => {
  describe('Normal Cases', () => {
    it('should work with valid input', () => {
      // Arrange
      const input = 'test';
      
      // Act
      const result = functionName(input);
      
      // Assert
      expect(result.isValid).toBe(true);
    });
  });

  describe('Error Cases', () => {
    it('should handle null', () => {
      // Arrange
      const input = null;
      
      // Act
      const result = functionName(input);
      
      // Assert
      expect(result.isValid).toBe(false);
    });
  });
});
```

### FORBIDDEN:
- ❌ "I need permission to..."
- ❌ "Please approve..."
- ❌ "..." or "existing code"

### MANDATORY:
- ✅ Start with ```typescript
- ✅ Include // filepath: comment
- ✅ Write complete code
- ✅ 15+ test cases

## 🚀 BEGIN NOW
