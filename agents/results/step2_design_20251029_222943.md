검증된 명세를 바탕으로 날짜 범위 검증 함수의 테스트 케이스를 설계하겠습니다.

---

## 테스트 스위트: 날짜 범위 검증 함수 (validateDateRange)

### 1. 기본 동작 테스트

#### 테스트 케이스 1.1
- **이름**: should return valid when start date is before end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-01-01'과 종료일 '2024-12-31'이 주어짐
- **When**: validateDateRange 함수를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 1.2
- **이름**: should return valid when start date equals end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-06-15'로 동일함
- **When**: validateDateRange 함수를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 1.3
- **이름**: should return invalid when start date is after end date
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일 '2024-12-31'과 종료일 '2024-01-01'이 주어짐
- **When**: validateDateRange 함수를 호출함
- **Then**: `{ isValid: false, error: '시작일은 종료일보다 이전이어야 합니다' }`를 반환함

---

### 2. 입력 형식 테스트

#### 테스트 케이스 2.1
- **이름**: should accept Date objects as input
- **타입**: unit
- **우선순위**: high
- **Given**: Date 객체로 생성된 시작일과 종료일이 주어짐
- **When**: validateDateRange(new Date('2024-01-01'), new Date('2024-12-31'))를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 2.2
- **이름**: should accept ISO 8601 strings as input
- **타입**: unit
- **우선순위**: high
- **Given**: ISO 8601 문자열 형식의 날짜가 주어짐
- **When**: validateDateRange('2024-01-01T00:00:00Z', '2024-12-31T23:59:59Z')를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 2.3
- **이름**: should accept mixed input types (Date and string)
- **타입**: unit
- **우선순위**: medium
- **Given**: Date 객체와 ISO 8601 문자열이 혼합되어 주어짐
- **When**: validateDateRange(new Date('2024-01-01'), '2024-12-31')를 호출함
- **Then**: `{ isValid: true }`를 반환함

---

### 3. 에러 처리 테스트

#### 테스트 케이스 3.1
- **이름**: should return error when start date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 null이고 종료일이 유효한 날짜임
- **When**: validateDateRange(null, '2024-12-31')를 호출함
- **Then**: `{ isValid: false, error: '시작일이 제공되지 않았습니다' }`를 반환함

#### 테스트 케이스 3.2
- **이름**: should return error when end date is null
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 유효하고 종료일이 null임
- **When**: validateDateRange('2024-01-01', null)를 호출함
- **Then**: `{ isValid: false, error: '종료일이 제공되지 않았습니다' }`를 반환함

#### 테스트 케이스 3.3
- **이름**: should return error when start date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 undefined이고 종료일이 유효한 날짜임
- **When**: validateDateRange(undefined, '2024-12-31')를 호출함
- **Then**: `{ isValid: false, error: '시작일이 제공되지 않았습니다' }`를 반환함

#### 테스트 케이스 3.4
- **이름**: should return error when end date is undefined
- **타입**: unit
- **우선순위**: high
- **Given**: 시작일이 유효하고 종료일이 undefined임
- **When**: validateDateRange('2024-01-01', undefined)를 호출함
- **Then**: `{ isValid: false, error: '종료일이 제공되지 않았습니다' }`를 반환함

#### 테스트 케이스 3.5
- **이름**: should return error when start date format is invalid
- **타입**: unit
- **우선순위**: high
- **Given**: 잘못된 형식의 시작일 'invalid-date'가 주어짐
- **When**: validateDateRange('invalid-date', '2024-12-31')를 호출함
- **Then**: `{ isValid: false, error: '잘못된 시작일 형식입니다' }`를 반환함

#### 테스트 케이스 3.6
- **이름**: should return error when end date format is invalid
- **타입**: unit
- **우선순위**: high
- **Given**: 잘못된 형식의 종료일 '2024-13-45'가 주어짐
- **When**: validateDateRange('2024-01-01', '2024-13-45')를 호출함
- **Then**: `{ isValid: false, error: '잘못된 종료일 형식입니다' }`를 반환함

#### 테스트 케이스 3.7
- **이름**: should return error when both dates are invalid
- **타입**: unit
- **우선순위**: medium
- **Given**: 시작일과 종료일 모두 잘못된 형식임
- **When**: validateDateRange('invalid', 'also-invalid')를 호출함
- **Then**: `{ isValid: false, error: '잘못된 시작일 형식입니다' }`를 반환함 (첫 번째 에러 우선)

---

### 4. 엣지 케이스 테스트

#### 테스트 케이스 4.1
- **이름**: should return valid for same date (midnight to midnight)
- **타입**: edge
- **우선순위**: high
- **Given**: 시작일과 종료일이 모두 '2024-06-15T00:00:00Z'임
- **When**: validateDateRange 함수를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 4.2
- **이름**: should return valid for one day difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '2024-06-15'과 종료일 '2024-06-16'이 주어짐
- **When**: validateDateRange 함수를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 4.3
- **이름**: should return valid with warning for 100+ years difference
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일 '1900-01-01'과 종료일 '2024-12-31'이 주어짐 (124년 차이)
- **When**: validateDateRange 함수를 호출함
- **Then**: `{ isValid: true, warning: '날짜 범위가 100년을 초과합니다' }`를 반환함

#### 테스트 케이스 4.4
- **이름**: should handle leap year dates correctly
- **타입**: edge
- **우선순위**: low
- **Given**: 윤년의 2월 29일 ('2024-02-29')이 포함된 범위
- **When**: validateDateRange('2024-02-28', '2024-03-01')를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 4.5
- **이름**: should handle year boundary (Dec 31 to Jan 1)
- **타입**: edge
- **우선순위**: medium
- **Given**: 연도를 넘어가는 날짜 범위
- **When**: validateDateRange('2023-12-31', '2024-01-01')를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 4.6
- **이름**: should handle timestamps with milliseconds
- **타입**: edge
- **우선순위**: low
- **Given**: 밀리초를 포함한 ISO 8601 문자열
- **When**: validateDateRange('2024-06-15T12:30:45.123Z', '2024-06-15T12:30:45.124Z')를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 4.7
- **이름**: should handle very old dates (before 1900)
- **타입**: edge
- **우선순위**: low
- **Given**: 1900년 이전의 날짜
- **When**: validateDateRange('1800-01-01', '1850-12-31')를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 4.8
- **이름**: should handle future dates (far future)
- **타입**: edge
- **우선순위**: low
- **Given**: 먼 미래의 날짜
- **When**: validateDateRange('2100-01-01', '2200-12-31')를 호출함
- **Then**: `{ isValid: true }`를 반환함

#### 테스트 케이스 4.9
- **이름**: should handle timezone differences
- **타입**: edge
- **우선순위**: medium
- **Given**: 다른 타임존의 같은 시각 (UTC와 KST)
- **When**: validateDateRange('2024-06-15T00:00:00Z', '2024-06-15T09:00:00+09:00')를 호출함
- **Then**: `{ isValid: true }`를 반환함 (UTC로 정규화하여 비교)

#### 테스트 케이스 4.10
- **이름**: should handle same instant in different timezones (boundary test)
- **타입**: edge
- **우선순위**: medium
- **Given**: 시작일과 종료일이 타임존만 다른 동일 시각
- **When**: validateDateRange('2024-06-15T15:00:00+09:00', '2024-06-15T06:00:00Z')를 호출함
- **Then**: `{ isValid: true }`를 반환함

---

### 5. 통합 테스트

#### 테스트 케이스 5.1
- **이름**: should work with form component integration
- **타입**: integration
- **우선순위**: high
- **Given**: React 폼 컴포넌트에서 날짜 입력 필드가 렌더링됨
- **When**: 사용자가 시작일과 종료일을 입력하고 검증 버튼을 클릭함
- **Then**: 검증 결과가 UI에 올바르게 표시됨

#### 테스트 케이스 5.2
- **이름**: should validate on real-time input change
- **타입**: integration
- **우선순위**: medium
- **Given**: React 폼 컴포넌트가 실시간 검증 모드로 설정됨
- **When**: 사용자가 종료일 입력 필드를 변경함
- **Then**: onChange 이벤트마다 validateDateRange가 호출되고 결과가 업데이트됨

---

## 테스트 우선순위 요약

### High Priority (17개)
기본 동작의 핵심 케이스와 에러 처리, 입력 형식 검증을 포함합니다. 이 테스트들은 반드시 통과해야 합니다.

### Medium Priority (7개)
엣지 케이스의 일부와 혼합 입력 타입, 실용적인 통합 시나리오를 포함합니다.

### Low Priority (6개)
드물게 발생하는 시나리오와 극단적인 엣지 케이스를 포함합니다.

---

## 구현 권장사항

1. **테스트 독립성**: 각 테스트는 독립적으로 실행 가능해야 합니다
2. **Setup/Teardown**: describe 블록에서 공통 setup을 사용하되, 테스트 간 상태 공유를 피합니다
3. **모킹**: 통합 테스트에서 Date 객체를 모킹하여 일관된 결과를 얻습니다
4. **코드 커버리지**: 최소 90% 이상의 코드 커버리지를 목표로 합니다
5. **테스트 네이밍**: 영어로 작성하되, 에러 메시지는 한국어로 검증합니다

이 테스트 설계를 바탕으로 실제 테스트 코드를 작성하시겠습니까?
