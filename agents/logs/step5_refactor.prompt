# SYSTEM INSTRUCTION

You are a CODE REFACTORING AI. You MUST output complete, refactored TypeScript code immediately.

## ğŸš¨ ABSOLUTE RULES

**FORBIDDEN RESPONSES:**
- âŒ "ê°œì„ ëœ ì „ì²´ ì½”ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤"
- âŒ "ë¦¬íŒ©í† ë§ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"
- âŒ "ë‹¤ìŒê³¼ ê°™ì´ ê°œì„ í–ˆìŠµë‹ˆë‹¤:" without showing code
- âŒ Any explanation without actual code
- âŒ "I refactored..." without showing code

**MANDATORY:**
- âœ… START with: ```typescript
- âœ… SHOW complete refactored code
- âœ… Include // filepath: comment
- âœ… Write ALL functions (no ...)
- âœ… Code must be copy-paste ready

---

## Example of FORBIDDEN Response (âŒ):

"ë¦¬íŒ©í† ë§ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.

**ê°œì„  ì‚¬í•­:**
1. ì¤‘ë³µ ì œê±°
2. í•¨ìˆ˜ ë¶„ë¦¬
3. íƒ€ì… ê°œì„ 

**2ë‹¨ê³„: ê°œì„ ëœ ì „ì²´ ì½”ë“œ**

ê°œì„ ëœ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤..."

**This is WRONG! You MUST show the actual refactored code!**

---

## Example of CORRECT Response (âœ…):

**ê°œì„  í¬ì¸íŠ¸:**
- ì¤‘ë³µ ì œê±° (DRY)
- ìƒìˆ˜ ì¶”ì¶œ
- í—¬í¼ í•¨ìˆ˜ ë¶„ë¦¬

**ê°œì„ ëœ ì „ì²´ ì½”ë“œ:**

```typescript
// filepath: src/utils/[YOUR-ACTUAL-FILENAME].ts

// Import statements (if needed)
import { SomeType } from './types';

/**
 * Type definitions
 */
export interface YourResultType {
  // Define your interface
}

/**
 * Constants (extract magic numbers/strings)
 */
const YOUR_CONSTANTS = {
  KEY_1: 'value1',
  KEY_2: 100
} as const;

/**
 * Main exported function with JSDoc
 * 
 * @param param1 - Description
 * @param param2 - Description
 * @returns Description
 */
export function yourMainFunction(
  param1: Type1,
  param2: Type2
): ReturnType {
  // Implement using helper functions
  // Apply refactoring principles:
  // - DRY (Don't Repeat Yourself)
  // - Single Responsibility
  // - Clear naming
  
  const result = helperFunction1(param1);
  
  if (!result) {
    return createError('Error message');
  }
  
  return processResult(result, param2);
}

/**
 * Helper function 1
 */
function helperFunction1(param: Type): ResultType | null {
  // Complete implementation
}

/**
 * Helper function 2
 */
function helperFunction2(param: Type): ResultType {
  // Complete implementation
}

/**
 * Error factory
 */
function createError(message: string): ErrorType {
  return { success: false, error: message };
}
```

**REMEMBER:**
- Replace `[YOUR-ACTUAL-FILENAME]` with actual file path from spec
- Replace `yourMainFunction` with actual function name
- Replace `YourResultType` with actual types
- Write COMPLETE implementation (no `...` placeholders)

---


## ì›ë³¸ ëª…ì„¸

# ğŸ“… Schedule Recurring Rule Spec

_ë°˜ë³µ ì¼ì • ìƒì„± ë¡œì§ í…ŒìŠ¤íŠ¸ ëª…ì„¸_

---

## ğŸ§¾ ëª©ì 

ë°˜ë³µ ì¼ì • ìƒì„± ë¡œì§ì´ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ”ì§€ ê²€ì¦í•œë‹¤.  
ê° ë°˜ë³µ ìœ í˜•(ë§¤ì¼, ë§¤ì£¼, ë§¤ì›”, ë§¤ë…„)ì— ëŒ€í•´ ì •í™•í•œ ë‚ ì§œ ê³„ì‚°ê³¼ ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•´ì•¼ í•œë‹¤.

---

## âš™ï¸ ì‚¬ì „ ì¡°ê±´

- ê¸°ì¤€ ì¼ì •: **2024-01-31 (ìˆ˜ìš”ì¼)**
- ë°˜ë³µ ì˜µì…˜: `ë§¤ì¼`, `ë§¤ì£¼`, `ë§¤ì›”`, `ë§¤ë…„`
- ë‚ ì§œ í˜•ì‹: `YYYY-MM-DD` (ISO 8601)
- **ì¼ì • ê²¹ì¹¨ì€ ê³ ë ¤í•˜ì§€ ì•ŠìŒ**

---

## ğŸ§© í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### 1ï¸âƒ£ ë§¤ì¼ ë°˜ë³µ

**Given:** ì‹œì‘ì¼ì´ `2024-01-31`  
**When:** ë°˜ë³µ ìœ í˜•ì´ `ë§¤ì¼`ì¼ ë•Œ  
**Then:**

- ë‹¤ìŒ ì¼ì •ì€ `2024-02-01`ì— ìƒì„±ë˜ì–´ì•¼ í•œë‹¤.
- ì´í›„ ì¼ì •ì€ í•˜ë£¨ì”© ì¦ê°€í•œë‹¤.

| ë°˜ë³µ íšŸìˆ˜ | ì˜ˆìƒ ë‚ ì§œ  |
| :-------: | :--------: |
|   1íšŒì°¨   | 2024-02-01 |
|   2íšŒì°¨   | 2024-02-02 |
|   3íšŒì°¨   | 2024-02-03 |

---

### 2ï¸âƒ£ ë§¤ì£¼ ë°˜ë³µ

**Given:** ì‹œì‘ì¼ì´ `2024-01-31 (ìˆ˜ìš”ì¼)`  
**When:** ë°˜ë³µ ìœ í˜•ì´ `ë§¤ì£¼`ì¼ ë•Œ  
**Then:**

- ë§¤ì£¼ ê°™ì€ ìš”ì¼(ìˆ˜ìš”ì¼)ì— ìƒì„±ëœë‹¤.
- ë‹¤ìŒ ì¼ì •ì€ `2024-02-07`ì´ë‹¤.

| ë°˜ë³µ íšŸìˆ˜ | ì˜ˆìƒ ë‚ ì§œ  |
| :-------: | :--------: |
|   1íšŒì°¨   | 2024-02-07 |
|   2íšŒì°¨   | 2024-02-14 |
|   3íšŒì°¨   | 2024-02-21 |

---

### 3ï¸âƒ£ ë§¤ì›” ë°˜ë³µ

**Given:** ì‹œì‘ì¼ì´ `2024-01-31`  
**When:** ë°˜ë³µ ìœ í˜•ì´ `ë§¤ì›”`ì¼ ë•Œ  
**Then:**

- â€œë§¤ì›” ë§ˆì§€ë§‰ì¼â€ì´ ì•„ë‹Œ, â€œ**31ì¼ì—ë§Œ**â€ ìƒì„±ë˜ì–´ì•¼ í•œë‹¤.
- 2ì›”ì—ëŠ” 31ì¼ì´ ì—†ìœ¼ë¯€ë¡œ ì¼ì •ì´ ìƒì„±ë˜ì§€ ì•ŠëŠ”ë‹¤.
- ë‹¤ìŒ ìƒì„±ì¼ì€ `2024-03-31`ì´ë‹¤.

| ë°˜ë³µ íšŸìˆ˜ | ì˜ˆìƒ ë‚ ì§œ  |
| :-------: | :--------: |
|   1íšŒì°¨   | 2024-03-31 |
|   2íšŒì°¨   | 2024-05-31 |

---

### 4ï¸âƒ£ ë§¤ë…„ ë°˜ë³µ

**Given:** ì‹œì‘ì¼ì´ `2024-02-29 (ìœ¤ë…„)`  
**When:** ë°˜ë³µ ìœ í˜•ì´ `ë§¤ë…„`ì¼ ë•Œ  
**Then:**

- **2ì›” 29ì¼ì—ë§Œ ìƒì„±ë˜ì–´ì•¼ í•œë‹¤.**
- ë‹¤ìŒ ì¼ì •ì€ ë‹¤ìŒ ìœ¤ë…„ì¸ `2028-02-29`ì´ë‹¤.

| ë°˜ë³µ íšŸìˆ˜ | ì˜ˆìƒ ë‚ ì§œ  |
| :-------: | :--------: |
|   1íšŒì°¨   | 2028-02-29 |
|   2íšŒì°¨   | 2032-02-29 |

---

### 5ï¸âƒ£ ë°˜ë³µ ì¼ì • ê²¹ì¹¨ ë¬´ì‹œ

**Given:** ì´ë¯¸ ë‹¤ë¥¸ ì¼ì •ì´ ì¡´ì¬í•˜ëŠ” ë‚ ì§œì—ë„  
**When:** ë°˜ë³µ ìƒì„± ë¡œì§ì´ ì‹¤í–‰ë  ë•Œ  
**Then:**

- ì¼ì • ê²¹ì¹¨ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ì§€ ì•ŠëŠ”ë‹¤.
- ë™ì¼í•œ ë‚ ì§œì— ì¤‘ë³µ ìƒì„±ì´ í—ˆìš©ëœë‹¤.

---

## âœ… ê¸°ëŒ€ ê²°ê³¼

- ëª¨ë“  ë°˜ë³µ ìœ í˜•ì— ëŒ€í•´ ì˜ˆì™¸ ë‚ ì§œ ë° ê·œì¹™ì´ ì •í™•íˆ ì ìš©ëœë‹¤.
- ì¼ì • ê²¹ì¹¨ê³¼ ë¬´ê´€í•˜ê²Œ ë°˜ë³µ ì¼ì •ì´ ìƒì„±ëœë‹¤.
- ë§¤ì›”/ë§¤ë…„ ì˜ˆì™¸ ì¡°ê±´(31ì¼, ìœ¤ë…„ 29ì¼) ì²˜ë¦¬ ë¡œì§ì´ ì •í™•íˆ ë™ì‘í•œë‹¤.

---

## ğŸ“ íŒŒì¼ëª…

## í˜„ì¬ GREEN ë‹¨ê³„ êµ¬í˜„ ì½”ë“œ

```typescript
// filepath: src/utils/scheduleRecurringRule.ts

import { Event, RepeatType } from '../types';

/**
 * ë°˜ë³µ ì¼ì • ìƒì„± ê²°ê³¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface RecurringEventResult {
  date: string;
  event: Event;
}

/**
 * ë°˜ë³µ ì¼ì • ìƒì„± ì˜µì…˜
 */
export interface RecurringRuleOptions {
  interval?: number;
  count?: number;
}

/**
 * ì£¼ì–´ì§„ ì¼ì •ì— ëŒ€í•´ ë°˜ë³µ ê·œì¹™ì— ë”°ë¼ ë‹¤ìŒ ì¼ì • ë‚ ì§œë“¤ì„ ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @param baseEvent - ê¸°ì¤€ì´ ë˜ëŠ” ì¼ì •
 * @param repeatType - ë°˜ë³µ ìœ í˜• ('daily' | 'weekly' | 'monthly' | 'yearly')
 * @param count - ìƒì„±í•  ë°˜ë³µ ì¼ì • ê°œìˆ˜ (ê¸°ë³¸ê°’: 10)
 * @returns ìƒì„±ëœ ë°˜ë³µ ì¼ì • ë‚ ì§œ ë°°ì—´
 */
export function generateRecurringDates(
  baseEvent: Event,
  repeatType: RepeatType,
  count: number = 10
): string[] {
  if (!baseEvent || !baseEvent.date) {
    return [];
  }

  const dates: string[] = [];
  const baseDate = new Date(baseEvent.date);

  if (isNaN(baseDate.getTime())) {
    return [];
  }

  const baseDay = baseDate.getDate();
  const baseMonth = baseDate.getMonth();
  const baseYear = baseDate.getFullYear();
  const baseDayOfWeek = baseDate.getDay();

  let currentDate = new Date(baseDate);
  let attempts = 0;
  const maxAttempts = count * 1000; // ë¬´í•œë£¨í”„ ë°©ì§€

  while (dates.length < count && attempts < maxAttempts) {
    attempts++;

    switch (repeatType) {
      case 'daily':
        currentDate.setDate(currentDate.getDate() + 1);
        dates.push(formatDate(currentDate));
        break;

      case 'weekly':
        currentDate.setDate(currentDate.getDate() + 7);
        dates.push(formatDate(currentDate));
        break;

      case 'monthly':
        // ë§¤ì›” ê°™ì€ ì¼(day)ì—ë§Œ ìƒì„±
        currentDate.setMonth(currentDate.getMonth() + 1);
        
        // í•´ë‹¹ ì›”ì— ê¸°ì¤€ì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        if (currentDate.getDate() === baseDay) {
          dates.push(formatDate(currentDate));
        } else {
          // ë‚ ì§œê°€ ë„˜ì–´ê°„ ê²½ìš° (ì˜ˆ: 31ì¼ì´ ì—†ëŠ” ë‹¬)
          // ë‹¤ìŒ ë‹¬ë¡œ ì´ë¯¸ ë„˜ì–´ê°”ìœ¼ë¯€ë¡œ, ë‚ ì§œë¥¼ ê¸°ì¤€ì¼ë¡œ ë§ì¶°ì„œ ë‹¤ì‹œ ì‹œë„
          currentDate.setDate(0); // ì´ì „ ë‹¬ ë§ˆì§€ë§‰ ë‚ 
          const lastDayOfPrevMonth = currentDate.getDate();
          
          if (baseDay > lastDayOfPrevMonth) {
            // ê¸°ì¤€ì¼ì´ í•´ë‹¹ ì›”ì— ì¡´ì¬í•˜ì§€ ì•ŠìŒ - ê±´ë„ˆëœ€
            currentDate.setMonth(currentDate.getMonth() + 1);
            currentDate.setDate(baseDay);
          } else {
            currentDate.setDate(baseDay);
            dates.push(formatDate(currentDate));
          }
        }
        break;

      case 'yearly':
        // ë§¤ë…„ ê°™ì€ ì›”-ì¼ì—ë§Œ ìƒì„±
        currentDate.setFullYear(currentDate.getFullYear() + 1);
        
        // ìœ¤ë…„ 2ì›” 29ì¼ ì²˜ë¦¬
        if (baseMonth === 1 && baseDay === 29) {
          // ìœ¤ë…„ì¸ì§€ í™•ì¸
          if (isLeapYear(currentDate.getFullYear())) {
            currentDate.setMonth(baseMonth);
            currentDate.setDate(baseDay);
            dates.push(formatDate(currentDate));
          } else {
            // ìœ¤ë…„ì´ ì•„ë‹ˆë©´ ê±´ë„ˆëœ€
            currentDate.setMonth(baseMonth);
            currentDate.setDate(1); // ë‚ ì§œ ë¦¬ì…‹
          }
        } else {
          // ì¼ë°˜ì ì¸ ê²½ìš°
          if (currentDate.getDate() === baseDay && currentDate.getMonth() === baseMonth) {
            dates.push(formatDate(currentDate));
          } else {
            // ë‚ ì§œê°€ ë§ì§€ ì•Šìœ¼ë©´ (ì›”ë§ ì²˜ë¦¬)
            currentDate.setMonth(baseMonth);
            currentDate.setDate(baseDay);
            
            // í•´ë‹¹ ì›”ì— ê·¸ ë‚ ì§œê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
            if (currentDate.getDate() === baseDay) {
              dates.push(formatDate(currentDate));
            }
          }
        }
        break;

      default:
        return dates;
    }
  }

  return dates;
}

/**
 * ìœ¤ë…„ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 * 
 * @param year - í™•ì¸í•  ì—°ë„
 * @returns ìœ¤ë…„ì´ë©´ true, ì•„ë‹ˆë©´ false
 */
function isLeapYear(year: number): boolean {
  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

/**
 * Date ê°ì²´ë¥¼ YYYY-MM-DD í˜•ì‹ ë¬¸ìì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * 
 * @param date - ë³€í™˜í•  Date ê°ì²´
 * @returns YYYY-MM-DD í˜•ì‹ì˜ ë‚ ì§œ ë¬¸ìì—´
 */
function formatDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * ë°˜ë³µ ì¼ì •ì„ ìƒì„±í•˜ê³  Event ê°ì²´ ë°°ì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
 * 
 * @param baseEvent - ê¸°ì¤€ ì¼ì •
 * @param count - ìƒì„±í•  ë°˜ë³µ ì¼ì • ê°œìˆ˜
 * @returns ìƒì„±ëœ ë°˜ë³µ ì¼ì • ë°°ì—´
 */
export function createRecurringEvents(
  baseEvent: Event,
  count: number = 10
): Event[] {
  if (!baseEvent || !baseEvent.repeat.type || baseEvent.repeat.type === 'none') {
    return [];
  }

  const dates = generateRecurringDates(baseEvent, baseEvent.repeat.type, count);
  
  return dates.map((date, index) => ({
    ...baseEvent,
    id: `${baseEvent.id}_recurring_${index + 1}`,
    date,
    repeat: {
      ...baseEvent.repeat
    }
  }));
}
```

---

## YOUR TASK: Refactor the Code Above

### Refactoring Checklist:
- [ ] Remove duplication (DRY principle)
- [ ] Extract magic numbers/strings to constants
- [ ] Split large functions (Single Responsibility Principle)
- [ ] Improve naming (clear, descriptive names)
- [ ] Add/improve TypeScript types
- [ ] Add JSDoc comments to public APIs
- [ ] Reduce complexity (cyclomatic complexity)
- [ ] Improve error messages

### Critical Requirements:
1. **Keep the same functionality** - All existing tests MUST pass
2. **Use EXACT file path** from current implementation
3. **Keep same exports** (function names, interface names)
4. **Write COMPLETE code** - No `...` or `// existing code` placeholders
5. **Ready to run** - Copy & paste should work immediately

**BEGIN NOW. Output format:**

## âœ… REQUIRED

You MUST respond with:
- Actual refactored TypeScript code
- Starting with ```typescript
- Complete implementation
- All functions fully written
- Ready to use immediately

**BEGIN NOW. WRITE THE COMPLETE REFACTORED CODE:**

